/*
 * xeogl V0.7.0
 *
 * A WebGL-based 3D visualization engine from xeoLabs
 * http://xeogl.org/
 *
 * Built on 2018-05-02
 *
 * MIT License
 * Copyright 2018, Lindsay Kay
 * http://xeolabs.com/
 *
 */

/**
 The xeogl namespace.

 @class xeogl
 @main xeogl
 @static
 @author xeolabs / http://xeolabs.com/
 */
(function () {

    "use strict";

    // Fast queue that avoids using potentially inefficient array .shift() calls
    // Based on https://github.com/creationix/fastqueue
    var Queue = function () {

        var head = [];
        var headLength = 0;
        var tail = [];
        var index = 0;
        this.length = 0;

        this.shift = function () {
            if (index >= headLength) {
                var t = head;
                t.length = 0;
                head = tail;
                tail = t;
                index = 0;
                headLength = head.length;
                if (!headLength) {
                    return;
                }
            }
            var value = head[index];
            if (index < 0) {
                delete head[index++];
            }
            else {
                head[index++] = undefined;
            }
            this.length--;
            return value;
        };

        this.push = function (item) {
            this.length++;
            tail.push(item);
            return this;
        };

        this.unshift = function (item) {
            head[--index] = item;
            this.length++;
            return this;
        };
    };

    var xeogl = function () {

        this._debug = {
            forceHighShaderPrecision: false
        };

        /**
         * Semantic version number. The value for this is set by an expression that's concatenated to
         * the end of the built binary by the xeogl build script.
         * @property version
         * @namespace xeogl
         * @type {String}
         */
        this.version = null;

        /**
         * Information about available WebGL support
         */
        this.WEBGL_INFO = (function () {
            var info = {
                WEBGL: false
            };

            var canvas = document.createElement("canvas");

            if (!canvas) {
                return info;
            }

            var gl = canvas.getContext("webgl", {antialias: true}) || canvas.getContext("experimental-webgl", {antialias: true});

            info.WEBGL = !!gl;

            if (!info.WEBGL) {
                return info;
            }

            info.ANTIALIAS = gl.getContextAttributes().antialias;

            if (gl.getShaderPrecisionFormat) {
                if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                    info.FS_MAX_FLOAT_PRECISION = "highp";
                } else if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                    info.FS_MAX_FLOAT_PRECISION = "mediump";
                } else {
                    info.FS_MAX_FLOAT_PRECISION = "lowp";
                }
            } else {
                info.FS_MAX_FLOAT_PRECISION = "mediump";
            }

            info.DEPTH_BUFFER_BITS = gl.getParameter(gl.DEPTH_BITS);
            info.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            info.MAX_CUBE_MAP_SIZE = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            info.MAX_RENDERBUFFER_SIZE = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
            info.MAX_TEXTURE_UNITS = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            info.MAX_TEXTURE_IMAGE_UNITS = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            info.MAX_VERTEX_ATTRIBS = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            info.MAX_VERTEX_UNIFORM_VECTORS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            info.MAX_FRAGMENT_UNIFORM_VECTORS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
            info.MAX_VARYING_VECTORS = gl.getParameter(gl.MAX_VARYING_VECTORS);

            info.SUPPORTED_EXTENSIONS = {};

            gl.getSupportedExtensions().forEach(function (ext) {
                info.SUPPORTED_EXTENSIONS[ext] = true;
            });

            return info;
        })();

        /**
         * Tracks statistics within xeogl, such as numbers of
         * scenes, textures, geometries etc.
         * @final
         * @property stats
         * @type {*}
         */
        this.stats = {
            build: {
                version: xeogl.version
            },
            client: {
                browser: (navigator && navigator.userAgent) ? navigator.userAgent : "n/a"
            },

            // TODO: replace 'canvas' with 'pixels'
            //canvas: {
            //    width: 0,
            //    height: 0
            //},
            components: {
                scenes: 0,
                models: 0,
                entities: 0
            },
            memory: {

                // Note that these counts will include any positions, colors,
                // normals and indices that xeogl internally creates on-demand
                // to support color-index triangle picking.

                meshes: 0,
                positions: 0,
                colors: 0,
                normals: 0,
                uvs: 0,
                indices: 0,
                textures: 0,
                transforms: 0,
                materials: 0,
                programs: 0
            },
            frame: {
                frameCount: 0,
                fps: 0,
                useProgram: 0,
                bindTexture: 0,
                bindArray: 0,
                drawElements: 0,
                drawArrays: 0,
                tasksRun: 0,
                tasksScheduled: 0
            }
        };

        // Ensures unique scene IDs
        // Lazy-instantiated because its class is on the
        // namespace of this object, and so won't be defined yet
        this._sceneIDMap = null;

        // Default singleton Scene, lazy-initialized in getter
        this._scene = null;

        /**
         * Existing {{#crossLink "Scene"}}Scene{{/crossLink}}s , mapped to their IDs
         * @property scenes
         * @namespace xeogl
         * @type {{String:xeogl.Scene}}
         */
        this.scenes = {};

        // Used for throttling FPS for each Scene
        this._scenesRenderInfo = {};

        /**
         * For each component type, a list of its supertypes, ordered upwards in the hierarchy.
         * @type {{}}
         * @private
         */
        this._superTypes = {};

        // Task queue, which is pumped on each frame;
        // tasks are pushed to it with calls to xeogl.schedule

        this._taskQueue = new Queue();

        //-----------------------------------------------------------------------
        // Game loop
        //
        // https://developer.mozilla.org/en-US/docs/Games/Anatomy
        //
        // http://gameprogrammingpatterns.com/game-loop.html
        //-----------------------------------------------------------------------

        var self = this;

        (function () {

            var tickEvent = {
                sceneId: null,
                time: null,
                startTime: null,
                prevTime: null,
                deltaTime: null
            };

            // Hoisted vars

            var taskBudget = 10; // Millisecs we're allowed to spend on tasks in each frame
            var frameTime;
            var lastFrameTime = 0;
            var elapsedFrameTime;
            var newFPS;
            var fpsSamples = [];
            var numFPSSamples = 30;
            var totalFPS = 0;
            var updateTime;
            var id;
            var scene;

            var frame = function () {

                frameTime = Date.now();

                // Moving average of FPS

                if (lastFrameTime > 0) {
                    elapsedFrameTime = frameTime - lastFrameTime;
                    newFPS = 1000 / elapsedFrameTime;
                    totalFPS += newFPS;
                    fpsSamples.push(newFPS);
                    if (fpsSamples.length >= numFPSSamples) {
                        totalFPS -= fpsSamples.shift();
                    }
                    self.stats.frame.fps = Math.round(totalFPS / fpsSamples.length);

                }

                update();

                render();

                lastFrameTime = frameTime;

                window.requestAnimationFrame(frame);
            };


            function update() {

                updateTime = Date.now();

                // Process as many enqueued tasks as we can
                // within the per-frame task budget

                var tasksRun = self._runScheduledTasks(updateTime + taskBudget);
                var tasksScheduled = self._taskQueue.length;

                self.stats.frame.tasksRun = tasksRun;
                self.stats.frame.tasksScheduled = tasksScheduled;
                self.stats.frame.tasksBudget = taskBudget;

                tickEvent.time = updateTime;

                // Fire a "tick" event at the scene, which will in turn cause
                // all sorts of scene components to schedule more tasks

                for (id in self.scenes) {
                    if (self.scenes.hasOwnProperty(id)) {

                        scene = self.scenes[id];

                        // Fire the tick event at the scene

                        tickEvent.sceneId = id;
                        tickEvent.startTime = scene.startTime;
                        tickEvent.deltaTime = tickEvent.prevTime != null ? tickEvent.time - tickEvent.prevTime : 0;

                        /**
                         * Fired on each game loop iteration.
                         *
                         * @event tick
                         * @param {String} sceneID The ID of this Scene.
                         * @param {Number} startTime The time in seconds since 1970 that this Scene was instantiated.
                         * @param {Number} time The time in seconds since 1970 of this "tick" event.
                         * @param {Number} prevTime The time of the previous "tick" event from this Scene.
                         * @param {Number} deltaTime The time in seconds since the previous "tick" event from this Scene.
                         */
                        scene.fire("tick", tickEvent, true);
                    }
                }

                tickEvent.prevTime = updateTime;
            }

            function render() {

                var scenes = self.scenes;
                var scenesRenderInfo = self._scenesRenderInfo;
                var scene;
                var renderInfo;
                var ticksPerRender;

                var forceRender = false;
                for (id in scenes) {
                    if (scenes.hasOwnProperty(id)) {

                        scene = scenes[id];
                        renderInfo = scenesRenderInfo[id];

                        ticksPerRender = scene.ticksPerRender;

                        if (renderInfo.ticksPerRender !== ticksPerRender) {
                            renderInfo.ticksPerRender = ticksPerRender;
                            renderInfo.renderCountdown = ticksPerRender;
                        }

                        if (--renderInfo.renderCountdown === 0) {
                            scene.render(forceRender);
                            renderInfo.renderCountdown = ticksPerRender;
                        }
                    }
                }
            }

            window.requestAnimationFrame(frame);

        })();
    };

    xeogl.prototype = {

        constructor: xeogl,

        /**
         The default {{#crossLink "Scene"}}Scene{{/crossLink}}.

         Components created without an explicit parent {{#crossLink "Scene"}}Scene{{/crossLink}} will be created within this
         {{#crossLink "Scene"}}Scene{{/crossLink}} by default.

         xeogl creates the default {{#crossLink "Scene"}}Scene{{/crossLink}} as soon as you either
         reference this property for the first time, or create your first {{#crossLink "Entity"}}Entity{{/crossLink}} without
         a specified {{#crossLink "Scene"}}Scene{{/crossLink}}.

         @property scene
         @namespace xeogl
         @final
         @type Scene
         */
        get scene() {

            // xeogl.Scene constructor will call this._addScene
            // to register itself on xeogl

            return this._scene || (this._scene = new window.xeogl.Scene({
                    id: "default.scene"
                }));
        },

        set scene(value) {
            this._scene = value;
        },

        /**
         * Registers a scene on xeogl.
         * This is called within the xeogl.Scene constructor.
         *
         * @method _addScene
         * @param {Scene} scene The scene
         * @private
         */
        _addScene: function (scene) {

            this._sceneIDMap = this._sceneIDMap || new window.xeogl.utils.Map();

            if (scene.id) {

                // User-supplied ID

                if (this.scenes[scene.id]) {
                    console.error("[ERROR] Scene " + xeogl._inQuotes(scene.id) + " already exists");
                    return;
                }

            } else {

                // Auto-generated ID

                scene.id = this._sceneIDMap.addItem(scene);
            }

            this.scenes[scene.id] = scene;

            var ticksPerRender = scene.ticksPerRender;

            this._scenesRenderInfo[scene.id] = {
                ticksPerRender: ticksPerRender,
                renderCountdown: ticksPerRender
            };

            this.stats.components.scenes++;

            var self = this;

            // Unregister destroyed scenes

            scene.on("destroyed",
                function () {

                    self._sceneIDMap.removeItem(scene.id);

                    delete self.scenes[scene.id];
                    delete self._scenesRenderInfo[scene.id];

                    self.stats.components.scenes--;
                });
        },

        /**
         * Schedule a task for xeogl to run at the next frame.
         *
         * Internally, this pushes the task to a FIFO queue. Within each frame interval, xeogl processes the queue
         * for a certain period of time, popping tasks and running them. After each frame interval, tasks that did not
         * get a chance to run during the task are left in the queue to be run next time.
         *
         * @method scheduleTask
         * @param {Function} callback Callback that runs the task.
         * @param {Object} [scope] Scope for the callback.
         */
        scheduleTask: function (callback, scope) {
            this._taskQueue.push(callback);
            this._taskQueue.push(scope);
        },

        deferTask: function (callback, scope) {
            if (scope) {
                callback.call(scope);
            } else {
                callback();
            }
        },

        // Pops and propcesses tasks in the queue, until the
        // given number of milliseconds has elapsed.
        _runScheduledTasks: function (until) {

            var time = (new Date()).getTime();
            var taskQueue = this._taskQueue;
            var callback;
            var scope;
            var tasksRun = 0;

            while (taskQueue.length > 0 && time < until) {
                callback = taskQueue.shift();
                scope = taskQueue.shift();
                if (scope) {
                    callback.call(scope);
                } else {
                    callback();
                }
                time = (new Date()).getTime();
                tasksRun++;
            }

            return tasksRun;
        },

        /**
         * Destroys all user-created {{#crossLink "Scene"}}Scenes{{/crossLink}} and
         * clears the default {{#crossLink "Scene"}}Scene{{/crossLink}}.
         *
         * @method clear
         * @demo foo
         */
        clear: function () {

            var scene;

            for (var id in this.scenes) {
                if (this.scenes.hasOwnProperty(id)) {

                    scene = this.scenes[id];

                    // Only clear the default Scene
                    // but destroy all the others

                    if (id === "default.scene") {
                        scene.clear();
                    } else {
                        scene.destroy();
                    }
                }
            }
            this.scenes = {};
        },

        /**
         * Tests if the given object is an array
         * @private
         */
        _isArray: function (testEntity) {
            return testEntity && !(testEntity.propertyIsEnumerable('length')) && typeof testEntity === 'object' && typeof testEntity.length === 'number';
        },

        /**
         * Tests if the given value is a string
         * @param value
         * @returns {boolean}
         * @private
         */
        _isString: function (value) {
            return (typeof value === 'string' || value instanceof String);
        },

        /**
         * Tests if the given value is a number
         * @param value
         * @returns {boolean}
         * @private
         */
        _isNumeric: function (value) {
            return !isNaN(parseFloat(value)) && isFinite(value);
        },

        /**
         * Tests if the given value is an ID
         * @param value
         * @returns {boolean}
         * @private
         */
        _isID: function (value) {
            return xeogl._isString(value) || xeogl._isNumeric(value);
        },

        /**
         * Tests if the given components are the same, where the components can be either IDs or instances.
         * @param c1
         * @param c2
         * @returns {boolean}
         * @private
         */
        _isSameComponent: function (c1, c2) {

            if (!c1 || !c2) {
                return false;
            }

            var id1 = (xeogl.prototype._isNumeric(c1) || xeogl.prototype._isString(c1)) ? "" + c1 : c1.id;
            var id2 = (xeogl.prototype._isNumeric(c2) || xeogl.prototype._isString(c2)) ? "" + c2 : c2.id;

            return id1 === id2;
        },

        /**
         * Tests if the given value is a function
         * @param value
         * @returns {boolean}
         * @private
         */
        _isFunction: function (value) {
            return (typeof value === "function");
        },

        /**
         * Tests if the given value is a JavaScript JSON object, eg, ````{ foo: "bar" }````.
         * @param value
         * @returns {boolean}
         * @private
         */
        _isObject: (function () {
            var objectConstructor = {}.constructor;
            return function (value) {
                return (!!value && value.constructor === objectConstructor);
            };
        })(),

        /**
         * Tests if the given component type is a subtype of another component supertype.
         * @param {String} type
         * @param {String} [superType="xeogl.Component"]
         * @returns {boolean}
         * @private
         */
        _isComponentType: function (type, superType) {

            superType = superType || "xeogl.Component";

            if (type === superType) {
                return true;
            }

            var superTypes = this._superTypes[type];

            if (!superTypes) {
                return false;
            }

            for (var i = superTypes.length - 1; i >= 0; i--) {
                if (superTypes[i] === superType) {
                    return true;
                }
            }

            return false;
        },

        /** Returns a shallow copy
         */
        _copy: function (o) {
            return this._apply(o, {});
        },

        /** Add properties of o to o2, overwriting them on o2 if already there
         */
        _apply: function (o, o2) {
            for (var name in o) {
                if (o.hasOwnProperty(name)) {
                    o2[name] = o[name];
                }
            }
            return o2;
        },

        /**
         * Add non-null/defined properties of o to o2
         * @private
         */
        _apply2: function (o, o2) {
            for (var name in o) {
                if (o.hasOwnProperty(name)) {
                    if (o[name] !== undefined && o[name] !== null) {
                        o2[name] = o[name];
                    }
                }
            }
            return o2;
        },

        /**
         * Add properties of o to o2 where undefined or null on o2
         * @private
         */
        _applyIf: function (o, o2) {
            for (var name in o) {
                if (o.hasOwnProperty(name)) {
                    if (o2[name] === undefined || o2[name] === null) {
                        o2[name] = o[name];
                    }
                }
            }
            return o2;
        },

        /**
         * Returns true if the given map is empty.
         * @param obj
         * @returns {boolean}
         * @private
         */
        _isEmptyObject: function (obj) {
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Returns the given ID as a string, in quotes if the ID was a string to begin with.
         *
         * This is useful for logging IDs.
         *
         * @param {Number| String} id The ID
         * @returns {String}
         * @private
         */
        _inQuotes: function (id) {
            return this._isNumeric(id) ? ("" + id) : ("'" + id + "'");
        },

        /**
         * Returns the concatenation of two typed arrays.
         * @param a
         * @param b
         * @returns {*|a}
         * @private
         */
        _concat: function (a, b) {
            var c = new a.constructor(a.length + b.length);
            c.set(a);
            c.set(b, a.length);
            return c;
        }
    };

    // Have a lower-case xeogl namespace as well,
    // just because it's easier to type when live-coding

    window.xeogl = window.xeogl = new xeogl();

})
();
;/*
 * Canvas2Image v0.1
 * Copyright (c) 2008 Jacob Seidelin, cupboy@gmail.com
 * MIT License [http://www.opensource.org/licenses/mit-license.php]
 */

var Canvas2Image = (function () {
    // check if we have canvas support
    var oCanvas = document.createElement("canvas"),
        sc = String.fromCharCode,
        strDownloadMime = "image/octet-stream",
        bReplaceDownloadMime = false;

    // no canvas, bail out.
    if (!oCanvas.getContext) {
        return {
            saveAsBMP: function () {
            },
            saveAsPNG: function () {
            },
            saveAsJPEG: function () {
            }
        }
    }

    var bHasImageData = !!(oCanvas.getContext("2d").getImageData),
        bHasDataURL = !!(oCanvas.toDataURL),
        bHasBase64 = !!(window.btoa);

    // ok, we're good
    var readCanvasData = function (oCanvas) {
        var iWidth = parseInt(oCanvas.width),
            iHeight = parseInt(oCanvas.height);
        return oCanvas.getContext("2d").getImageData(0, 0, iWidth, iHeight);
    };

    // base64 encodes either a string or an array of charcodes
    var encodeData = function (data) {
        var i, aData, strData = "";

        if (typeof data == "string") {
            strData = data;
        } else {
            aData = data;
            for (i = 0; i < aData.length; i++) {
                strData += sc(aData[i]);
            }
        }
        return btoa(strData);
    };

    // creates a base64 encoded string containing BMP data takes an imagedata object as argument
    var createBMP = function (oData) {
        var strHeader = '',
            iWidth = oData.width,
            iHeight = oData.height;

        strHeader += 'BM';

        var iFileSize = iWidth * iHeight * 4 + 54; // total header size = 54 bytes
        strHeader += sc(iFileSize % 256);
        iFileSize = Math.floor(iFileSize / 256);
        strHeader += sc(iFileSize % 256);
        iFileSize = Math.floor(iFileSize / 256);
        strHeader += sc(iFileSize % 256);
        iFileSize = Math.floor(iFileSize / 256);
        strHeader += sc(iFileSize % 256);

        strHeader += sc(0, 0, 0, 0, 54, 0, 0, 0); // data offset
        strHeader += sc(40, 0, 0, 0); // info header size

        var iImageWidth = iWidth;
        strHeader += sc(iImageWidth % 256);
        iImageWidth = Math.floor(iImageWidth / 256);
        strHeader += sc(iImageWidth % 256);
        iImageWidth = Math.floor(iImageWidth / 256);
        strHeader += sc(iImageWidth % 256);
        iImageWidth = Math.floor(iImageWidth / 256);
        strHeader += sc(iImageWidth % 256);

        var iImageHeight = iHeight;
        strHeader += sc(iImageHeight % 256);
        iImageHeight = Math.floor(iImageHeight / 256);
        strHeader += sc(iImageHeight % 256);
        iImageHeight = Math.floor(iImageHeight / 256);
        strHeader += sc(iImageHeight % 256);
        iImageHeight = Math.floor(iImageHeight / 256);
        strHeader += sc(iImageHeight % 256);

        strHeader += sc(1, 0, 32, 0); // num of planes & num of bits per pixel
        strHeader += sc(0, 0, 0, 0); // compression = none

        var iDataSize = iWidth * iHeight * 4;
        strHeader += sc(iDataSize % 256);
        iDataSize = Math.floor(iDataSize / 256);
        strHeader += sc(iDataSize % 256);
        iDataSize = Math.floor(iDataSize / 256);
        strHeader += sc(iDataSize % 256);
        iDataSize = Math.floor(iDataSize / 256);
        strHeader += sc(iDataSize % 256);

        strHeader += sc(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); // these bytes are not used

        var aImgData = oData.data,
            strPixelData = "",
            c, x, y = iHeight,
            iOffsetX, iOffsetY, strPixelRow;

        do {
            iOffsetY = iWidth * (y - 1) * 4;
            strPixelRow = "";
            for (x = 0; x < iWidth; x++) {
                iOffsetX = 4 * x;
                strPixelRow += sc(
                    aImgData[iOffsetY + iOffsetX + 2], // B
                    aImgData[iOffsetY + iOffsetX + 1], // G
                    aImgData[iOffsetY + iOffsetX],     // R
                    aImgData[iOffsetY + iOffsetX + 3]  // A
                );
            }
            strPixelData += strPixelRow;
        } while (--y);

        return encodeData(strHeader + strPixelData);
    };

    // sends the generated file to the client
    var saveFile = function (strData) {
        if (!window.open(strData)) {
            document.location.href = strData;
        }
    };

    var makeDataURI = function (strData, strMime) {
        return "data:" + strMime + ";base64," + strData;
    };

    // generates a <img> object containing the imagedata
    var makeImageObject = function (strSource) {
        var oImgElement = document.createElement("img");
        oImgElement.src = strSource;
        return oImgElement;
    };

    var scaleCanvas = function (oCanvas, iWidth, iHeight) {
        if (iWidth && iHeight) {
            var oSaveCanvas = document.createElement("canvas");

            oSaveCanvas.width = iWidth;
            oSaveCanvas.height = iHeight;
            oSaveCanvas.style.width = iWidth + "px";
            oSaveCanvas.style.height = iHeight + "px";

            var oSaveCtx = oSaveCanvas.getContext("2d");

            oSaveCtx.drawImage(oCanvas, 0, 0, oCanvas.width, oCanvas.height, 0, 0, iWidth, iWidth);

            return oSaveCanvas;
        }
        return oCanvas;
    };

    return {
        saveAsPNG: function (oCanvas, bReturnImg, iWidth, iHeight) {
            if (!bHasDataURL) return false;

            var oScaledCanvas = scaleCanvas(oCanvas, iWidth, iHeight),
                strMime = "image/png",
                strData = oScaledCanvas.toDataURL(strMime);

            if (bReturnImg) {
                return makeImageObject(strData);
            } else {
                saveFile(bReplaceDownloadMime ? strData.replace(strMime, strDownloadMime) : strData);
            }
            return true;
        },

        saveAsJPEG: function (oCanvas, bReturnImg, iWidth, iHeight) {
            if (!bHasDataURL) return false;

            var oScaledCanvas = scaleCanvas(oCanvas, iWidth, iHeight),
                strMime = "image/jpeg",
                strData = oScaledCanvas.toDataURL(strMime);

            // check if browser actually supports jpeg by looking for the mime type in the data uri. if not, return false
            if (strData.indexOf(strMime) != 5) return false;

            if (bReturnImg) {
                return makeImageObject(strData);
            } else {
                saveFile(bReplaceDownloadMime ? strData.replace(strMime, strDownloadMime) : strData);
            }
            return true;
        },

        saveAsBMP: function (oCanvas, bReturnImg, iWidth, iHeight) {
            if (!(bHasDataURL && bHasImageData && bHasBase64)) return false;

            var oScaledCanvas = scaleCanvas(oCanvas, iWidth, iHeight),
                strMime = "image/bmp",
                oData = readCanvasData(oScaledCanvas),
                strImgData = createBMP(oData);

            if (bReturnImg) {
                return makeImageObject(makeDataURI(strImgData, strMime));
            } else {
                saveFile(makeDataURI(strImgData, strMime));
            }
            return true;
        }
    };
})();;/*
 Based on Simple JavaScript Inheritance
 By John Resig http://ejohn.org/
 MIT Licensed.
 */
// Inspired by base2 and Prototype
(function () {

    var initializing = false;

    var fnTest = /xyz/.test(function () {xyz;}) ? /\b_super\b/ : /.*/;

    // The base Class implementation (does nothing)
    this.Class = function () {
    };

    // Create a new Class that inherits from this class
    Class.extend = function (prop) {

        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {

            //
            if (name === "_props") {
                var props = prop[name];
                var descriptor;
                for (var key in props) {
                    descriptor = props[key];
                    if (key.indexOf(",") >= 0) { // Aliased property name of form "foo, bar, baz": { .. }
                        var aliases = key.split(",");
                        for (var i = 0, len = aliases.length; i < len; i++) {
                            var alias = aliases[i].trim();
                            if (!descriptor.set) {
                                (function () {
                                    var name3 = alias;
                                    descriptor.set = function () {
                                        this.warn("Property '" + name3 + "' is read-only, ignoring assignment");
                                    };
                                })();
                            }
                            descriptor.enumerable = true; // Want property to show up in inspectors
                            Object.defineProperty(prototype, alias, descriptor);
                        }
                    } else {

                        // If no setter is provided, then the property
                        // is strictly read-only. Insert a dummy setter
                        // to log a warning.

                        if (!descriptor.set) {
                            (function () {
                                var name = key;
                                descriptor.set = function () {
                                    this.warn("Property '" + name + "' is read-only, ignoring assignment");
                                };
                            })();
                        }
                        descriptor.enumerable = true; // Want property to show up in inspectors
                        Object.defineProperty(prototype, key, descriptor);
                    }
                }
                continue;
            }

            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] === "function" && typeof _super[name] === "function" && fnTest.test(prop[name]) ?
                (function (name, fn) {
                    return function () {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) : prop[name];
        }

        // Create array of type names to indicate inheritance chain,
        // to support "isType" queries on components
        prototype.superTypes = _super.superTypes ? _super.superTypes.concat(_super.type) : [];

        if (!prop.type) {
            prop.type = _super.type + "_" + createUUID();
        } else {
            xeogl._superTypes[prop.type] = prototype.superTypes;
        }

        // The dummy class constructor
        function Class() {

            // All construction is actually done in the init method
            if (!initializing && this.__init)
                this.__init.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = arguments.callee;

        window[prop.type] = Class;

        return Class;
    };

    /**
     * Returns a new UUID.
     * @method createUUID
     * @static
     * @return string The new UUID
     */
    var createUUID = (function () {
        // http://www.broofa.com/Tools/Math.uuid.htm
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        var uuid = new Array(36);
        var rnd = 0, r;
        return function () {
            for (var i = 0; i < 36; i++) {
                if (i === 8 || i === 13 || i === 18 || i === 23) {
                    uuid[i] = '-';
                } else if (i === 14) {
                    uuid[i] = '4';
                } else {
                    if (rnd <= 0x02) {
                        rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
                    }
                    r = rnd & 0xf;
                    rnd = rnd >> 4;
                    uuid[i] = chars[( i === 19 ) ? ( r & 0x3 ) | 0x8 : r];
                }
            }
            return uuid.join('');
        };
    })();
})();

;xeogl.utils = xeogl.utils || {};

/**
 * Generic map of IDs to items - can generate own IDs or accept given IDs. IDs should be strings in order to not
 * clash with internally generated IDs, which are numbers.
 */
xeogl.utils.Map = function (items, baseId) {

    this.items = items || [];

    baseId = baseId || 0;
    var lastUniqueId = baseId + 1;

    /**
     * Usage:
     *
     * id = myMap.addItem("foo") // ID internally generated
     * id = myMap.addItem("foo", "bar") // ID is "foo"
     */
    this.addItem = function () {
        var item;
        if (arguments.length === 2) {
            var id = arguments[0];
            item = arguments[1];
            if (this.items[id]) { // Won't happen if given ID is string
                throw "ID clash: '" + id + "'";
            }
            this.items[id] = item;
            return id;

        } else {
            item = arguments[0] || {};
            while (true) {
                var findId = lastUniqueId++;
                if (!this.items[findId]) {
                    this.items[findId] = item;
                    return findId;
                }
            }
        }
    };

    this.removeItem = function (id) {
        var item = this.items[id];
        delete this.items[id];
        return item;
    };
};
;/**
 * Math utilities.
 *
 * @module xeogl
 * @submodule math
 */;(function () {

    "use strict";

    // Some temporary vars to help avoid garbage collection

    var tempMat1 = new Float32Array(16);
    var tempMat2 = new Float32Array(16);

    var tempVec4 = new Float32Array(4);

    /**
     * This utility object provides math functions that are used within xeogl. These functions are also part of xeogl's
     * public API and are therefore available for you to use within your application code.
     * @module xeogl
     * @submodule math
     * @class math
     * @static
     */
    var math = xeogl.math = {

        MAX_DOUBLE: +100000000,
        MIN_DOUBLE: -100000000,
        /**
         * The number of radiians in a degree (0.0174532925).
         * @property DEGTORAD
         * @namespace xeogl.math
         * @type {Number}
         */
        DEGTORAD: 0.0174532925,

        /**
         * Returns a new, uninitialized two-element vector.
         * @method vec2
         * @param [values] Initial values.
         * @static
         * @returns {Float32Array}
         */
        vec2: function (values) {
            return new Float32Array(values || 2);
        },

        /**
         * Returns a new, uninitialized three-element vector.
         * @method vec3
         * @param [values] Initial values.
         * @static
         * @returns {Float32Array}
         */
        vec3: function (values) {
            return new Float32Array(values || 3);
        },

        /**
         * Returns a new, uninitialized four-element vector.
         * @method vec4
         * @param [values] Initial values.
         * @static
         * @returns {Float32Array}
         */
        vec4: function (values) {
            return new Float32Array(values || 4);
        },

        /**
         * Returns a new, uninitialized 3x3 matrix.
         * @method mat3
         * @param [values] Initial values.
         * @static
         * @returns {Float32Array}
         */
        mat3: function (values) {
            return new Float32Array(values || 9);
        },

        /**
         * Converts a 3x3 matrix to 4x4
         * @method mat3ToMat4
         * @param mat3 3x3 matrix.
         * @param mat4 4x4 matrix
         * @static
         * @returns {Float32Array}
         */
        mat3ToMat4: function (mat3, mat4) { // TODO
            //return new Float32Array(values || 9);
        },

        /**
         * Returns a new, uninitialized 4x4 matrix.
         * @method mat4
         * @param [values] Initial values.
         * @static
         * @returns {Float32Array}
         */
        mat4: function (values) {
            return new Float32Array(values || 16);
        },

        /**
         * Converts a 4x4 matrix to 3x3
         * @method mat4ToMat3
         * @param mat4 4x4 matrix.
         * @param mat3 3x3 matrix
         * @static
         * @returns {Float32Array}
         */
        mat4ToMat3: function (mat4, mat3) { // TODO
            //return new Float32Array(values || 9);
        },

        /**
         * Returns a new UUID.
         * @method createUUID
         * @static
         * @return string The new UUID
         */
        //createUUID: function () {
        //    // http://www.broofa.com/Tools/Math.uuid.htm
        //    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        //    var uuid = new Array(36);
        //    var rnd = 0;
        //    var r;
        //    return function () {
        //        for (var i = 0; i < 36; i++) {
        //            if (i === 8 || i === 13 || i === 18 || i === 23) {
        //                uuid[i] = '-';
        //            } else if (i === 14) {
        //                uuid[i] = '4';
        //            } else {
        //                if (rnd <= 0x02) {
        //                    rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
        //                }
        //                r = rnd & 0xf;
        //                rnd = rnd >> 4;
        //                uuid[i] = chars[( i === 19 ) ? ( r & 0x3 ) | 0x8 : r];
        //            }
        //        }
        //        return uuid.join('');
        //    };
        //}(),
        //
        createUUID: (function () {
            var self = {};
            var lut = [];
            for (var i = 0; i < 256; i++) {
                lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
            }
            return function () {
                var d0 = Math.random() * 0xffffffff | 0;
                var d1 = Math.random() * 0xffffffff | 0;
                var d2 = Math.random() * 0xffffffff | 0;
                var d3 = Math.random() * 0xffffffff | 0;
                return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' +
                    lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' +
                    lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] +
                    lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
            };
        })(),

        /**
         * Clamps a value to the given range.
         * @param {Number} value Value to clamp.
         * @param {Number} min Lower bound.
         * @param {Number} max Upper bound.
         * @returns {Number} Clamped result.
         */
        clamp: function (value, min, max) {
            return Math.max(min, Math.min(max, value));
        },

        /**
         * Floating-point modulus
         * @method fmod
         * @static
         * @param {Number} a
         * @param {Number} b
         * @returns {*}
         */
        fmod: function (a, b) {
            if (a < b) {
                console.error("xeogl.math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring");
                return a;
            }
            while (b <= a) {
                a -= b;
            }
            return a;
        },

        /**
         * Negates a four-element vector.
         * @method negateVec4
         * @static
         * @param {Array(Number)} v Vector to negate
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        negateVec4: function (v, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = -v[0];
            dest[1] = -v[1];
            dest[2] = -v[2];
            dest[3] = -v[3];
            return dest;
        },

        /**
         * Adds one four-element vector to another.
         * @method addVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        addVec4: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] + v[0];
            dest[1] = u[1] + v[1];
            dest[2] = u[2] + v[2];
            dest[3] = u[3] + v[3];
            return dest;
        },

        /**
         * Adds a scalar value to each element of a four-element vector.
         * @method addVec4Scalar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        addVec4Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] + s;
            dest[1] = v[1] + s;
            dest[2] = v[2] + s;
            dest[3] = v[3] + s;
            return dest;
        },

        /**
         * Adds one three-element vector to another.
         * @method addVec3
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        addVec3: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] + v[0];
            dest[1] = u[1] + v[1];
            dest[2] = u[2] + v[2];
            return dest;
        },

        /**
         * Adds a scalar value to each element of a three-element vector.
         * @method addVec4Scalar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        addVec3Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] + s;
            dest[1] = v[1] + s;
            dest[2] = v[2] + s;
            return dest;
        },

        /**
         * Subtracts one four-element vector from another.
         * @method subVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Vector to subtract
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        subVec4: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] - v[0];
            dest[1] = u[1] - v[1];
            dest[2] = u[2] - v[2];
            dest[3] = u[3] - v[3];
            return dest;
        },

        /**
         * Subtracts one three-element vector from another.
         * @method subVec3
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Vector to subtract
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        subVec3: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] - v[0];
            dest[1] = u[1] - v[1];
            dest[2] = u[2] - v[2];
            return dest;
        },

        /**
         * Subtracts one two-element vector from another.
         * @method subVec2
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Vector to subtract
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        subVec2: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] - v[0];
            dest[1] = u[1] - v[1];
            return dest;
        },

        /**
         * Subtracts a scalar value from each element of a four-element vector.
         * @method subVec4Scalar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        subVec4Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] - s;
            dest[1] = v[1] - s;
            dest[2] = v[2] - s;
            dest[3] = v[3] - s;
            return dest;
        },

        /**
         * Sets each element of a 4-element vector to a scalar value minus the value of that element.
         * @method subScalarVec4
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        subScalarVec4: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = s - v[0];
            dest[1] = s - v[1];
            dest[2] = s - v[2];
            dest[3] = s - v[3];
            return dest;
        },

        /**
         * Multiplies one three-element vector by another.
         * @method mulVec3
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        mulVec4: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] * v[0];
            dest[1] = u[1] * v[1];
            dest[2] = u[2] * v[2];
            dest[3] = u[3] * v[3];
            return dest;
        },

        /**
         * Multiplies each element of a four-element vector by a scalar.
         * @method mulVec34calar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        mulVec4Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] * s;
            dest[1] = v[1] * s;
            dest[2] = v[2] * s;
            dest[3] = v[3] * s;
            return dest;
        },

        /**
         * Multiplies each element of a three-element vector by a scalar.
         * @method mulVec3Scalar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        mulVec3Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] * s;
            dest[1] = v[1] * s;
            dest[2] = v[2] * s;
            return dest;
        },

        /**
         * Multiplies each element of a two-element vector by a scalar.
         * @method mulVec2Scalar
         * @static
         * @param {Array(Number)} v The vector
         * @param {Number} s The scalar
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, v otherwise
         */
        mulVec2Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] * s;
            dest[1] = v[1] * s;
            return dest;
        },

        /**
         * Divides one three-element vector by another.
         * @method divVec3
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        divVec3: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] / v[0];
            dest[1] = u[1] / v[1];
            dest[2] = u[2] / v[2];
            return dest;
        },

        /**
         * Divides one four-element vector by another.
         * @method divVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @param  {Array(Number)} [dest] Destination vector
         * @return {Array(Number)} dest if specified, u otherwise
         */
        divVec4: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            dest[0] = u[0] / v[0];
            dest[1] = u[1] / v[1];
            dest[2] = u[2] / v[2];
            dest[3] = u[3] / v[3];
            return dest;
        },

        /**
         * Divides a scalar by a three-element vector, returning a new vector.
         * @method divScalarVec3
         * @static
         * @param v vec3
         * @param s scalar
         * @param dest vec3 - optional destination
         * @return [] dest if specified, v otherwise
         */
        divScalarVec3: function (s, v, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = s / v[0];
            dest[1] = s / v[1];
            dest[2] = s / v[2];
            return dest;
        },

        /**
         * Divides a three-element vector by a scalar.
         * @method divVec3Scalar
         * @static
         * @param v vec3
         * @param s scalar
         * @param dest vec3 - optional destination
         * @return [] dest if specified, v otherwise
         */
        divVec3Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] / s;
            dest[1] = v[1] / s;
            dest[2] = v[2] / s;
            return dest;
        },

        /**
         * Divides a four-element vector by a scalar.
         * @method divVec4Scalar
         * @static
         * @param v vec4
         * @param s scalar
         * @param dest vec4 - optional destination
         * @return [] dest if specified, v otherwise
         */
        divVec4Scalar: function (v, s, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = v[0] / s;
            dest[1] = v[1] / s;
            dest[2] = v[2] / s;
            dest[3] = v[3] / s;
            return dest;
        },


        /**
         * Divides a scalar by a four-element vector, returning a new vector.
         * @method divScalarVec4
         * @static
         * @param s scalar
         * @param v vec4
         * @param dest vec4 - optional destination
         * @return [] dest if specified, v otherwise
         */
        divScalarVec4: function (s, v, dest) {
            if (!dest) {
                dest = v;
            }
            dest[0] = s / v[0];
            dest[1] = s / v[1];
            dest[2] = s / v[2];
            dest[3] = s / v[3];
            return dest;
        },

        /**
         * Returns the dot product of two four-element vectors.
         * @method dotVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @return The dot product
         */
        dotVec4: function (u, v) {
            return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);
        },

        /**
         * Returns the cross product of two four-element vectors.
         * @method cross3Vec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @return The cross product
         */
        cross3Vec4: function (u, v) {
            var u0 = u[0], u1 = u[1], u2 = u[2];
            var v0 = v[0], v1 = v[1], v2 = v[2];
            return [
                u1 * v2 - u2 * v1,
                u2 * v0 - u0 * v2,
                u0 * v1 - u1 * v0,
                0.0];
        },

        /**
         * Returns the cross product of two three-element vectors.
         * @method cross3Vec3
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @return The cross product
         */
        cross3Vec3: function (u, v, dest) {
            if (!dest) {
                dest = u;
            }
            var x = u[0], y = u[1], z = u[2];
            var x2 = v[0], y2 = v[1], z2 = v[2];
            dest[0] = y * z2 - z * y2;
            dest[1] = z * x2 - x * z2;
            dest[2] = x * y2 - y * x2;
            return dest;
        },


        sqLenVec4: function (v) { // TODO
            return math.dotVec4(v, v);
        },

        /**
         * Returns the length of a four-element vector.
         * @method lenVec4
         * @static
         * @param {Array(Number)} v The vector
         * @return The length
         */
        lenVec4: function (v) {
            return Math.sqrt(math.sqLenVec4(v));
        },

        /**
         * Returns the dot product of two three-element vectors.
         * @method dotVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @return The dot product
         */
        dotVec3: function (u, v) {
            return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);
        },

        /**
         * Returns the dot product of two two-element vectors.
         * @method dotVec4
         * @static
         * @param {Array(Number)} u First vector
         * @param {Array(Number)} v Second vector
         * @return The dot product
         */
        dotVec2: function (u, v) {
            return (u[0] * v[0] + u[1] * v[1]);
        },


        sqLenVec3: function (v) {
            return math.dotVec3(v, v);
        },


        sqLenVec2: function (v) {
            return math.dotVec2(v, v);
        },

        /**
         * Returns the length of a three-element vector.
         * @method lenVec3
         * @static
         * @param {Array(Number)} v The vector
         * @return The length
         */
        lenVec3: function (v) {
            return Math.sqrt(math.sqLenVec3(v));
        },

        /**
         * Returns the length of a two-element vector.
         * @method lenVec2
         * @static
         * @param {Array(Number)} v The vector
         * @return The length
         */
        lenVec2: function (v) {
            return Math.sqrt(math.sqLenVec2(v));
        },

        distVec2: (function () {
            var vec = new Float32Array(2);
            return function (v, w) {
                return math.lenVec2(math.subVec2(v, w, vec));
            };
        })(),

        /**
         * @method rcpVec3
         * @static
         * @param v vec3
         * @param dest vec3 - optional destination
         * @return [] dest if specified, v otherwise
         *
         */
        rcpVec3: function (v, dest) {
            return math.divScalarVec3(1.0, v, dest);
        },

        /**
         * Normalizes a four-element vector
         * @method normalizeVec4
         * @static
         * @param v vec4
         * @param dest vec4 - optional destination
         * @return [] dest if specified, v otherwise
         *
         */
        normalizeVec4: function (v, dest) {
            var f = 1.0 / math.lenVec4(v);
            return math.mulVec4Scalar(v, f, dest);
        },

        /**
         * Normalizes a three-element vector
         * @method normalizeVec4
         * @static
         */
        normalizeVec3: function (v, dest) {
            var f = 1.0 / math.lenVec3(v);
            return math.mulVec3Scalar(v, f, dest);
        },

        /**
         * Normalizes a two-element vector
         * @method normalizeVec2
         * @static
         */
        normalizeVec2: function (v, dest) {
            var f = 1.0 / math.lenVec2(v);
            return math.mulVec2Scalar(v, f, dest);
        },

        /**
         * Gets the angle between two vectors
         * @method angleVec3
         * @param v
         * @param w
         * @returns {number}
         */
        angleVec3: function (v, w) {
            var theta = xeogl.math.dotVec3(v, w) / ( Math.sqrt(xeogl.math.sqLenVec3(v) * xeogl.math.sqLenVec3(w)) );
            theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems
            return Math.acos(theta);
        },

        /**
         * Creates a three-element vector from the rotation part of a sixteen-element matrix.
         * @param m
         * @param dest
         */
        vec3FromMat4Scale: (function () {

            var tempVec3 = new Float32Array(3);

            return function (m, dest) {

                tempVec3[0] = m[0];
                tempVec3[1] = m[1];
                tempVec3[2] = m[2];

                dest[0] = math.lenVec3(tempVec3);

                tempVec3[0] = m[4];
                tempVec3[1] = m[5];
                tempVec3[2] = m[6];

                dest[1] = math.lenVec3(tempVec3);

                tempVec3[0] = m[8];
                tempVec3[1] = m[9];
                tempVec3[2] = m[10];

                dest[2] = math.lenVec3(tempVec3);

                return dest;
            };
        })(),

        /**
         * Converts an n-element vector to a JSON-serializable
         * array with values rounded to two decimal places.
         */
        vecToArray: (function () {
            function trunc(v) {
                return Math.round(v * 100000) / 100000
            }

            return function (v) {
                v = Array.prototype.slice.call(v);
                for (var i = 0, len = v.length; i < len; i++) {
                    v[i] = trunc(v[i]);
                }
                return v;
            };
        })(),

        /**
         * Duplicates a 4x4 identity matrix.
         * @method dupMat4
         * @static
         */
        dupMat4: function (m) {
            return m.slice(0, 16);
        },

        /**
         * Extracts a 3x3 matrix from a 4x4 matrix.
         * @method mat4To3
         * @static
         */
        mat4To3: function (m) {
            return [
                m[0], m[1], m[2],
                m[4], m[5], m[6],
                m[8], m[9], m[10]
            ];
        },

        /**
         * Returns a 4x4 matrix with each element set to the given scalar value.
         * @method m4s
         * @static
         */
        m4s: function (s) {
            return [
                s, s, s, s,
                s, s, s, s,
                s, s, s, s,
                s, s, s, s
            ];
        },

        /**
         * Returns a 4x4 matrix with each element set to zero.
         * @method setMat4ToZeroes
         * @static
         */
        setMat4ToZeroes: function () {
            return math.m4s(0.0);
        },

        /**
         * Returns a 4x4 matrix with each element set to 1.0.
         * @method setMat4ToOnes
         * @static
         */
        setMat4ToOnes: function () {
            return math.m4s(1.0);
        },

        /**
         * Returns a 4x4 matrix with each element set to 1.0.
         * @method setMat4ToOnes
         * @static
         */
        diagonalMat4v: function (v) {
            return new Float32Array([
                v[0], 0.0, 0.0, 0.0,
                0.0, v[1], 0.0, 0.0,
                0.0, 0.0, v[2], 0.0,
                0.0, 0.0, 0.0, v[3]
            ]);
        },

        /**
         * Returns a 4x4 matrix with diagonal elements set to the given vector.
         * @method diagonalMat4c
         * @static
         */
        diagonalMat4c: function (x, y, z, w) {
            return math.diagonalMat4v([x, y, z, w]);
        },

        /**
         * Returns a 4x4 matrix with diagonal elements set to the given scalar.
         * @method diagonalMat4s
         * @static
         */
        diagonalMat4s: function (s) {
            return math.diagonalMat4c(s, s, s, s);
        },

        /**
         * Returns a 4x4 identity matrix.
         * @method identityMat4
         * @static
         */
        identityMat4: function (mat) {

            mat = mat || new Float32Array(16);

            mat[0] = 1.0;
            mat[1] = 0.0;
            mat[2] = 0.0;
            mat[3] = 0.0;

            mat[4] = 0.0;
            mat[5] = 1.0;
            mat[6] = 0.0;
            mat[7] = 0.0;

            mat[8] = 0.0;
            mat[9] = 0.0;
            mat[10] = 1.0;
            mat[11] = 0.0;

            mat[12] = 0.0;
            mat[13] = 0.0;
            mat[14] = 0.0;
            mat[15] = 1.0;

            return mat;
        },

        /**
         * Returns a 3x3 identity matrix.
         * @method identityMat3
         * @static
         */
        identityMat3: function (mat) {

            mat = mat || new Float32Array(9);

            mat[0] = 1.0;
            mat[1] = 0.0;
            mat[2] = 0.0;

            mat[3] = 0.0;
            mat[4] = 1.0;
            mat[5] = 0.0;

            mat[6] = 0.0;
            mat[7] = 0.0;
            mat[8] = 1.0;

            return mat;
        },

        /**
         * Tests if the given 4x4 matrix is the identity matrix.
         * @method isIdentityMat4
         * @static
         */
        isIdentityMat4: function (m) {
            if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||
                m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||
                m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||
                m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {
                return false;
            }
            return true;
        },

        /**
         * Negates the given 4x4 matrix.
         * @method negateMat4
         * @static
         */
        negateMat4: function (m, dest) {
            if (!dest) {
                dest = m;
            }
            dest[0] = -m[0];
            dest[1] = -m[1];
            dest[2] = -m[2];
            dest[3] = -m[3];
            dest[4] = -m[4];
            dest[5] = -m[5];
            dest[6] = -m[6];
            dest[7] = -m[7];
            dest[8] = -m[8];
            dest[9] = -m[9];
            dest[10] = -m[10];
            dest[11] = -m[11];
            dest[12] = -m[12];
            dest[13] = -m[13];
            dest[14] = -m[14];
            dest[15] = -m[15];
            return dest;
        },

        /**
         * Adds the given 4x4 matrices together.
         * @method addMat4
         * @static
         */
        addMat4: function (a, b, dest) {
            if (!dest) {
                dest = a;
            }
            dest[0] = a[0] + b[0];
            dest[1] = a[1] + b[1];
            dest[2] = a[2] + b[2];
            dest[3] = a[3] + b[3];
            dest[4] = a[4] + b[4];
            dest[5] = a[5] + b[5];
            dest[6] = a[6] + b[6];
            dest[7] = a[7] + b[7];
            dest[8] = a[8] + b[8];
            dest[9] = a[9] + b[9];
            dest[10] = a[10] + b[10];
            dest[11] = a[11] + b[11];
            dest[12] = a[12] + b[12];
            dest[13] = a[13] + b[13];
            dest[14] = a[14] + b[14];
            dest[15] = a[15] + b[15];
            return dest;
        },

        /**
         * Adds the given scalar to each element of the given 4x4 matrix.
         * @method addMat4Scalar
         * @static
         */
        addMat4Scalar: function (m, s, dest) {
            if (!dest) {
                dest = m;
            }
            dest[0] = m[0] + s;
            dest[1] = m[1] + s;
            dest[2] = m[2] + s;
            dest[3] = m[3] + s;
            dest[4] = m[4] + s;
            dest[5] = m[5] + s;
            dest[6] = m[6] + s;
            dest[7] = m[7] + s;
            dest[8] = m[8] + s;
            dest[9] = m[9] + s;
            dest[10] = m[10] + s;
            dest[11] = m[11] + s;
            dest[12] = m[12] + s;
            dest[13] = m[13] + s;
            dest[14] = m[14] + s;
            dest[15] = m[15] + s;
            return dest;
        },

        /**
         * Adds the given scalar to each element of the given 4x4 matrix.
         * @method addScalarMat4
         * @static
         */
        addScalarMat4: function (s, m, dest) {
            return math.addMat4Scalar(m, s, dest);
        },

        /**
         * Subtracts the second 4x4 matrix from the first.
         * @method subMat4
         * @static
         */
        subMat4: function (a, b, dest) {
            if (!dest) {
                dest = a;
            }
            dest[0] = a[0] - b[0];
            dest[1] = a[1] - b[1];
            dest[2] = a[2] - b[2];
            dest[3] = a[3] - b[3];
            dest[4] = a[4] - b[4];
            dest[5] = a[5] - b[5];
            dest[6] = a[6] - b[6];
            dest[7] = a[7] - b[7];
            dest[8] = a[8] - b[8];
            dest[9] = a[9] - b[9];
            dest[10] = a[10] - b[10];
            dest[11] = a[11] - b[11];
            dest[12] = a[12] - b[12];
            dest[13] = a[13] - b[13];
            dest[14] = a[14] - b[14];
            dest[15] = a[15] - b[15];
            return dest;
        },

        /**
         * Subtracts the given scalar from each element of the given 4x4 matrix.
         * @method subMat4Scalar
         * @static
         */
        subMat4Scalar: function (m, s, dest) {
            if (!dest) {
                dest = m;
            }
            dest[0] = m[0] - s;
            dest[1] = m[1] - s;
            dest[2] = m[2] - s;
            dest[3] = m[3] - s;
            dest[4] = m[4] - s;
            dest[5] = m[5] - s;
            dest[6] = m[6] - s;
            dest[7] = m[7] - s;
            dest[8] = m[8] - s;
            dest[9] = m[9] - s;
            dest[10] = m[10] - s;
            dest[11] = m[11] - s;
            dest[12] = m[12] - s;
            dest[13] = m[13] - s;
            dest[14] = m[14] - s;
            dest[15] = m[15] - s;
            return dest;
        },

        /**
         * Subtracts the given scalar from each element of the given 4x4 matrix.
         * @method subScalarMat4
         * @static
         */
        subScalarMat4: function (s, m, dest) {
            if (!dest) {
                dest = m;
            }
            dest[0] = s - m[0];
            dest[1] = s - m[1];
            dest[2] = s - m[2];
            dest[3] = s - m[3];
            dest[4] = s - m[4];
            dest[5] = s - m[5];
            dest[6] = s - m[6];
            dest[7] = s - m[7];
            dest[8] = s - m[8];
            dest[9] = s - m[9];
            dest[10] = s - m[10];
            dest[11] = s - m[11];
            dest[12] = s - m[12];
            dest[13] = s - m[13];
            dest[14] = s - m[14];
            dest[15] = s - m[15];
            return dest;
        },

        /**
         * Multiplies the two given 4x4 matrix by each other.
         * @method mulMat4
         * @static
         */
        mulMat4: function (a, b, dest) {
            if (!dest) {
                dest = a;
            }

            // Cache the matrix values (makes for huge speed increases!)
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

            var b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
            var b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
            var b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
            var b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];

            dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
            dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
            dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
            dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
            dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
            dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
            dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
            dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
            dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
            dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
            dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
            dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
            dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
            dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
            dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
            dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

            return dest;
        },

        /**
         * Multiplies the two given 3x3 matrices by each other.
         * @method mulMat4
         * @static
         */
        mulMat3: function (a, b, dest) {

            if (!dest) {
                dest = new Float32Array(9);
            }

            var a11 = a[0], a12 = a[3], a13 = a[6];
            var a21 = a[1], a22 = a[4], a23 = a[7];
            var a31 = a[2], a32 = a[5], a33 = a[8];

            var b11 = b[0], b12 = b[3], b13 = b[6];
            var b21 = b[1], b22 = b[4], b23 = b[7];
            var b31 = b[2], b32 = b[5], b33 = b[8];

            dest[0] = a11 * b11 + a12 * b21 + a13 * b31;
            dest[3] = a11 * b12 + a12 * b22 + a13 * b32;
            dest[6] = a11 * b13 + a12 * b23 + a13 * b33;

            dest[1] = a21 * b11 + a22 * b21 + a23 * b31;
            dest[4] = a21 * b12 + a22 * b22 + a23 * b32;
            dest[7] = a21 * b13 + a22 * b23 + a23 * b33;

            dest[2] = a31 * b11 + a32 * b21 + a33 * b31;
            dest[5] = a31 * b12 + a32 * b22 + a33 * b32;
            dest[8] = a31 * b13 + a32 * b23 + a33 * b33;

            return dest;
        },

        /**
         * Multiplies each element of the given 4x4 matrix by the given scalar.
         * @method mulMat4Scalar
         * @static
         */
        mulMat4Scalar: function (m, s, dest) {
            if (!dest) {
                dest = m;
            }
            dest[0] = m[0] * s;
            dest[1] = m[1] * s;
            dest[2] = m[2] * s;
            dest[3] = m[3] * s;
            dest[4] = m[4] * s;
            dest[5] = m[5] * s;
            dest[6] = m[6] * s;
            dest[7] = m[7] * s;
            dest[8] = m[8] * s;
            dest[9] = m[9] * s;
            dest[10] = m[10] * s;
            dest[11] = m[11] * s;
            dest[12] = m[12] * s;
            dest[13] = m[13] * s;
            dest[14] = m[14] * s;
            dest[15] = m[15] * s;
            return dest;
        },

        /**
         * Multiplies the given 4x4 matrix by the given four-element vector.
         * @method mulMat4v4
         * @static
         */
        mulMat4v4: function (m, v, dest) {
            dest = dest || math.vec4();
            var v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];
            dest[0] =  m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
            dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
            dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
            dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
            return dest;
        },

        /**
         * Transposes the given 4x4 matrix.
         * @method transposeMat4
         * @static
         */
        transposeMat4: function (mat, dest) {
            // If we are transposing ourselves we can skip a few steps but have to cache some values
            var m4 = mat[4], m14 = mat[14], m8 = mat[8];
            var m13 = mat[13], m12 = mat[12], m9 = mat[9];
            if (!dest || mat === dest) {
                var a01 = mat[1], a02 = mat[2], a03 = mat[3];
                var a12 = mat[6], a13 = mat[7];
                var a23 = mat[11];
                mat[1] = m4;
                mat[2] = m8;
                mat[3] = m12;
                mat[4] = a01;
                mat[6] = m9;
                mat[7] = m13;
                mat[8] = a02;
                mat[9] = a12;
                mat[11] = m14;
                mat[12] = a03;
                mat[13] = a13;
                mat[14] = a23;
                return mat;
            }
            dest[0] = mat[0];
            dest[1] = m4;
            dest[2] = m8;
            dest[3] = m12;
            dest[4] = mat[1];
            dest[5] = mat[5];
            dest[6] = m9;
            dest[7] = m13;
            dest[8] = mat[2];
            dest[9] = mat[6];
            dest[10] = mat[10];
            dest[11] = m14;
            dest[12] = mat[3];
            dest[13] = mat[7];
            dest[14] = mat[11];
            dest[15] = mat[15];
            return dest;
        },

        /**
         * Returns the determinant of the given 4x4 matrix.
         * @method determinantMat4
         * @static
         */
        determinantMat4: function (mat) {
            // Cache the matrix values (makes for huge speed increases!)
            var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
            var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
            var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
            var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
            return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
                a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
                a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
                a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
                a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
                a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;
        },

        /**
         * Returns the inverse of the given 4x4 matrix.
         * @method inverseMat4
         * @static
         */
        inverseMat4: function (mat, dest) {
            if (!dest) {
                dest = mat;
            }
            // Cache the matrix values (makes for huge speed increases!)
            var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
            var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
            var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
            var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
            var b00 = a00 * a11 - a01 * a10;
            var b01 = a00 * a12 - a02 * a10;
            var b02 = a00 * a13 - a03 * a10;
            var b03 = a01 * a12 - a02 * a11;
            var b04 = a01 * a13 - a03 * a11;
            var b05 = a02 * a13 - a03 * a12;
            var b06 = a20 * a31 - a21 * a30;
            var b07 = a20 * a32 - a22 * a30;
            var b08 = a20 * a33 - a23 * a30;
            var b09 = a21 * a32 - a22 * a31;
            var b10 = a21 * a33 - a23 * a31;
            var b11 = a22 * a33 - a23 * a32;

            // Calculate the determinant (inlined to avoid double-caching)
            var invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

            dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
            dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
            dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
            dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
            dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
            dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
            dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
            dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
            dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
            dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
            dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
            dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
            dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
            dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
            dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
            dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

            return dest;
        },

        /**
         * Returns the trace of the given 4x4 matrix.
         * @method traceMat4
         * @static
         */
        traceMat4: function (m) {
            return (m[0] + m[5] + m[10] + m[15]);
        },

        /**
         * Returns 4x4 translation matrix.
         * @method translationMat4
         * @static
         */
        translationMat4v: function (v, dest) {
            var m = dest || math.identityMat4();
            m[12] = v[0];
            m[13] = v[1];
            m[14] = v[2];
            return m;
        },

        /**
         * Returns 3x3 translation matrix.
         * @method translationMat3
         * @static
         */
        translationMat3v: function (v, dest) {
            var m = dest || math.identityMat3();
            m[6] = v[0];
            m[7] = v[1];
            return m;
        },

        /**
         * Returns 4x4 translation matrix.
         * @method translationMat4c
         * @static
         */
        translationMat4c: (function () {
            var xyz = new Float32Array(3);
            return function (x, y, z, dest) {
                xyz[0] = x;
                xyz[1] = y;
                xyz[2] = z;
                return math.translationMat4v(xyz, dest);
            };
        })(),

        /**
         * Returns 4x4 translation matrix.
         * @method translationMat4s
         * @static
         */
        translationMat4s: function (s, dest) {
            return math.translationMat4c(s, s, s, dest);
        },

        /**
         * Efficiently post-concatenates a translation to the given matrix.
         * @param v
         * @param m
         */
        translateMat4v: function (xyz, m) {
            return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);
        },

        /**
         * Efficiently post-concatenates a translation to the given matrix.
         * @param x
         * @param y
         * @param z
         * @param m
         */
        OLDtranslateMat4c: function (x, y, z, m) {

            var m12 = m[12];
            m[0] += m12 * x;
            m[4] += m12 * y;
            m[8] += m12 * z;

            var m13 = m[13];
            m[1] += m13 * x;
            m[5] += m13 * y;
            m[9] += m13 * z;

            var m14 = m[14];
            m[2] += m14 * x;
            m[6] += m14 * y;
            m[10] += m14 * z;

            var m15 = m[15];
            m[3] += m15 * x;
            m[7] += m15 * y;
            m[11] += m15 * z;

            return m;
        },

        translateMat4c: function (x, y, z, m) {

            var m3 = m[3];
            m[0] += m3 * x;
            m[1] += m3 * y;
            m[2] += m3 * z;

            var m7 = m[7];
            m[4] += m7 * x;
            m[5] += m7 * y;
            m[6] += m7 * z;

            var m11 = m[11];
            m[8] += m11 * x;
            m[9] += m11 * y;
            m[10] += m11 * z;

            var m15 = m[15];
            m[12] += m15 * x;
            m[13] += m15 * y;
            m[14] += m15 * z;

            return m;
        },
        /**
         * Returns 4x4 rotation matrix.
         * @method rotationMat4v
         * @static
         */
        rotationMat4v: function (anglerad, axis, m) {
            var ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);
            var s = Math.sin(anglerad);
            var c = Math.cos(anglerad);
            var q = 1.0 - c;

            var x = ax[0];
            var y = ax[1];
            var z = ax[2];

            var xy, yz, zx, xs, ys, zs;

            //xx = x * x; used once
            //yy = y * y; used once
            //zz = z * z; used once
            xy = x * y;
            yz = y * z;
            zx = z * x;
            xs = x * s;
            ys = y * s;
            zs = z * s;

            m = m || math.mat4();

            m[0] = (q * x * x) + c;
            m[1] = (q * xy) + zs;
            m[2] = (q * zx) - ys;
            m[3] = 0.0;

            m[4] = (q * xy) - zs;
            m[5] = (q * y * y) + c;
            m[6] = (q * yz) + xs;
            m[7] = 0.0;

            m[8] = (q * zx) + ys;
            m[9] = (q * yz) - xs;
            m[10] = (q * z * z) + c;
            m[11] = 0.0;

            m[12] = 0.0;
            m[13] = 0.0;
            m[14] = 0.0;
            m[15] = 1.0;

            return m;
        },

        /**
         * Returns 4x4 rotation matrix.
         * @method rotationMat4c
         * @static
         */
        rotationMat4c: function (anglerad, x, y, z, mat) {
            return math.rotationMat4v(anglerad, [x, y, z], mat);
        },

        /**
         * Returns 4x4 scale matrix.
         * @method scalingMat4v
         * @static
         */
        scalingMat4v: function (v, m) {
            m = m || math.identityMat4();
            m[0] = v[0];
            m[5] = v[1];
            m[10] = v[2];
            return m;
        },

        /**
         * Returns 3x3 scale matrix.
         * @method scalingMat3v
         * @static
         */
        scalingMat3v: function (v, m) {
            m = m || math.identityMat3();
            m[0] = v[0];
            m[4] = v[1];
            return m;
        },

        /**
         * Returns 4x4 scale matrix.
         * @method scalingMat4c
         * @static
         */
        scalingMat4c: (function () {
            var xyz = new Float32Array(3);
            return function (x, y, z, dest) {
                xyz[0] = x;
                xyz[1] = y;
                xyz[2] = z;
                return math.scalingMat4v(xyz, dest);
            };
        })(),

        /**
         * Efficiently post-concatenates a scaling to the given matrix.
         * @method scaleMat4c
         * @param x
         * @param y
         * @param z
         * @param m
         */
        scaleMat4c: function (x, y, z, m) {

            m[0] *= x;
            m[4] *= y;
            m[8] *= z;

            m[1] *= x;
            m[5] *= y;
            m[9] *= z;

            m[2] *= x;
            m[6] *= y;
            m[10] *= z;

            m[3] *= x;
            m[7] *= y;
            m[11] *= z;
            return m;
        },

        /**
         * Efficiently post-concatenates a scaling to the given matrix.
         * @method scaleMat4c
         * @param xyz
         * @param m
         */
        scaleMat4v: function (xyz, m) {

            var x = xyz[0];
            var y = xyz[1];
            var z = xyz[2];

            m[0] *= x;
            m[4] *= y;
            m[8] *= z;
            m[1] *= x;
            m[5] *= y;
            m[9] *= z;
            m[2] *= x;
            m[6] *= y;
            m[10] *= z;
            m[3] *= x;
            m[7] *= y;
            m[11] *= z;

            return m;
        },

        /**
         * Returns 4x4 scale matrix.
         * @method scalingMat4s
         * @static
         */
        scalingMat4s: function (s) {
            return math.scalingMat4c(s, s, s);
        },

        /**
         * Creates a matrix from a quaternion rotation and vector translation
         *
         * @param {Float32Array} q Rotation quaternion
         * @param {Float32Array} v Translation vector
         * @param {Float32Array} dest Destination matrix
         * @returns {Float32Array} dest
         */
        rotationTranslationMat4: function (q, v, dest) {

            dest = dest || math.mat4();

            var x = q[0];
            var y = q[1];
            var z = q[2];
            var w = q[3];

            var x2 = x + x;
            var y2 = y + y;
            var z2 = z + z;
            var xx = x * x2;
            var xy = x * y2;
            var xz = x * z2;
            var yy = y * y2;
            var yz = y * z2;
            var zz = z * z2;
            var wx = w * x2;
            var wy = w * y2;
            var wz = w * z2;

            dest[0] = 1 - (yy + zz);
            dest[1] = xy + wz;
            dest[2] = xz - wy;
            dest[3] = 0;
            dest[4] = xy - wz;
            dest[5] = 1 - (xx + zz);
            dest[6] = yz + wx;
            dest[7] = 0;
            dest[8] = xz + wy;
            dest[9] = yz - wx;
            dest[10] = 1 - (xx + yy);
            dest[11] = 0;
            dest[12] = v[0];
            dest[13] = v[1];
            dest[14] = v[2];
            dest[15] = 1;

            return dest;
        },

        /**
         * Gets Euler angles from a 4x4 matrix.
         *
         * @param {Float32Array} mat The 4x4 matrix.
         * @param {String} order Desired Euler angle order: "XYZ", "YXZ", "ZXY" etc.
         * @param {Float32Array} [dest] Destination Euler angles, created by default.
         * @returns {Float32Array} The Euler angles.
         */
        mat4ToEuler: function (mat, order, dest) {

            dest = dest || math.vec4();

            var clamp = math.clamp;

            // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

            var m11 = mat[0], m12 = mat[4], m13 = mat[8];
            var m21 = mat[1], m22 = mat[5], m23 = mat[9];
            var m31 = mat[2], m32 = mat[6], m33 = mat[10];

            if (order === 'XYZ') {

                dest[1] = Math.asin(clamp(m13, -1, 1));

                if (Math.abs(m13) < 0.99999) {
                    dest[0] = Math.atan2(-m23, m33);
                    dest[2] = Math.atan2(-m12, m11);
                } else {
                    dest[0] = Math.atan2(m32, m22);
                    dest[2] = 0;

                }

            } else if (order === 'YXZ') {

                dest[0] = Math.asin(-clamp(m23, -1, 1));

                if (Math.abs(m23) < 0.99999) {
                    dest[1] = Math.atan2(m13, m33);
                    dest[2] = Math.atan2(m21, m22);
                } else {
                    dest[1] = Math.atan2(-m31, m11);
                    dest[2] = 0;
                }

            } else if (order === 'ZXY') {

                dest[0] = Math.asin(clamp(m32, -1, 1));

                if (Math.abs(m32) < 0.99999) {
                    dest[1] = Math.atan2(-m31, m33);
                    dest[2] = Math.atan2(-m12, m22);
                } else {
                    dest[1] = 0;
                    dest[2] = Math.atan2(m21, m11);
                }

            } else if (order === 'ZYX') {

                dest[1] = Math.asin(-clamp(m31, -1, 1));

                if (Math.abs(m31) < 0.99999) {
                    dest[0] = Math.atan2(m32, m33);
                    dest[2] = Math.atan2(m21, m11);
                } else {
                    dest[0] = 0;
                    dest[2] = Math.atan2(-m12, m22);
                }

            } else if (order === 'YZX') {

                dest[2] = Math.asin(clamp(m21, -1, 1));

                if (Math.abs(m21) < 0.99999) {
                    dest[0] = Math.atan2(-m23, m22);
                    dest[1] = Math.atan2(-m31, m11);
                } else {
                    dest[0] = 0;
                    dest[1] = Math.atan2(m13, m33);
                }

            } else if (order === 'XZY') {

                dest[2] = Math.asin(-clamp(m12, -1, 1));

                if (Math.abs(m12) < 0.99999) {
                    dest[0] = Math.atan2(m32, m22);
                    dest[1] = Math.atan2(m13, m11);
                } else {
                    dest[0] = Math.atan2(-m23, m33);
                    dest[1] = 0;
                }
            }

            return dest;
        },

        /**
         * Returns a 4x4 'lookat' viewing transform matrix.
         * @method lookAtMat4v
         * @param pos vec3 position of the viewer
         * @param target vec3 point the viewer is looking at
         * @param up vec3 pointing "up"
         * @param dest mat4 Optional, mat4 matrix will be written into
         *
         * @return {mat4} dest if specified, a new mat4 otherwise
         */
        lookAtMat4v: function (pos, target, up, dest) {
            if (!dest) {
                dest = math.mat4();
            }

            var posx = pos[0],
                posy = pos[1],
                posz = pos[2],
                upx = up[0],
                upy = up[1],
                upz = up[2],
                targetx = target[0],
                targety = target[1],
                targetz = target[2];

            if (posx === targetx && posy === targety && posz === targetz) {
                return math.identityMat4();
            }

            var z0, z1, z2, x0, x1, x2, y0, y1, y2, len;

            //vec3.direction(eye, center, z);
            z0 = posx - targetx;
            z1 = posy - targety;
            z2 = posz - targetz;

            // normalize (no check needed for 0 because of early return)
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len;
            z1 *= len;
            z2 *= len;

            //vec3.normalize(vec3.cross(up, z, x));
            x0 = upy * z2 - upz * z1;
            x1 = upz * z0 - upx * z2;
            x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) {
                x0 = 0;
                x1 = 0;
                x2 = 0;
            } else {
                len = 1 / len;
                x0 *= len;
                x1 *= len;
                x2 *= len;
            }

            //vec3.normalize(vec3.cross(z, x, y));
            y0 = z1 * x2 - z2 * x1;
            y1 = z2 * x0 - z0 * x2;
            y2 = z0 * x1 - z1 * x0;

            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) {
                y0 = 0;
                y1 = 0;
                y2 = 0;
            } else {
                len = 1 / len;
                y0 *= len;
                y1 *= len;
                y2 *= len;
            }

            dest[0] = x0;
            dest[1] = y0;
            dest[2] = z0;
            dest[3] = 0;
            dest[4] = x1;
            dest[5] = y1;
            dest[6] = z1;
            dest[7] = 0;
            dest[8] = x2;
            dest[9] = y2;
            dest[10] = z2;
            dest[11] = 0;
            dest[12] = -(x0 * posx + x1 * posy + x2 * posz);
            dest[13] = -(y0 * posx + y1 * posy + y2 * posz);
            dest[14] = -(z0 * posx + z1 * posy + z2 * posz);
            dest[15] = 1;

            return dest;
        },

        /**
         * Returns a 4x4 'lookat' viewing transform matrix.
         * @method lookAtMat4c
         * @static
         */
        lookAtMat4c: function (posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {
            return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);
        },

        /**
         * Returns a 4x4 orthographic projection matrix.
         * @method orthoMat4c
         * @static
         */
        orthoMat4c: function (left, right, bottom, top, near, far, dest) {
            if (!dest) {
                dest = math.mat4();
            }
            var rl = (right - left);
            var tb = (top - bottom);
            var fn = (far - near);

            dest[0] = 2.0 / rl;
            dest[1] = 0.0;
            dest[2] = 0.0;
            dest[3] = 0.0;

            dest[4] = 0.0;
            dest[5] = 2.0 / tb;
            dest[6] = 0.0;
            dest[7] = 0.0;

            dest[8] = 0.0;
            dest[9] = 0.0;
            dest[10] = -2.0 / fn;
            dest[11] = 0.0;

            dest[12] = -(left + right) / rl;
            dest[13] = -(top + bottom) / tb;
            dest[14] = -(far + near) / fn;
            dest[15] = 1.0;

            return dest;
        },

        /**
         * Returns a 4x4 perspective projection matrix.
         * @method frustumMat4v
         * @static
         */
        frustumMat4v: function (fmin, fmax, m) {

            if (!m) {
                m = math.mat4();
            }

            var fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];
            var fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];

            math.addVec4(fmax4, fmin4, tempMat1);
            math.subVec4(fmax4, fmin4, tempMat2);

            var t = 2.0 * fmin4[2];

            var tempMat20 = tempMat2[0], tempMat21 = tempMat2[1], tempMat22 = tempMat2[2];

            m[0] = t / tempMat20;
            m[1] = 0.0;
            m[2] = 0.0;
            m[3] = 0.0;

            m[4] = 0.0;
            m[5] = t / tempMat21;
            m[6] = 0.0;
            m[7] = 0.0;

            m[8] = tempMat1[0] / tempMat20;
            m[9] = tempMat1[1] / tempMat21;
            m[10] = -tempMat1[2] / tempMat22;
            m[11] = -1.0;

            m[12] = 0.0;
            m[13] = 0.0;
            m[14] = -t * fmax4[2] / tempMat22;
            m[15] = 0.0;

            return m;
        },

        /**
         * Returns a 4x4 perspective projection matrix.
         * @method frustumMat4v
         * @static
         */
        frustumMat4: function (left, right, bottom, top, near, far, dest) {
            if (!dest) {
                dest = math.mat4();
            }
            var rl = (right - left);
            var tb = (top - bottom);
            var fn = (far - near);
            dest[0] = (near * 2) / rl;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            dest[4] = 0;
            dest[5] = (near * 2) / tb;
            dest[6] = 0;
            dest[7] = 0;
            dest[8] = (right + left) / rl;
            dest[9] = (top + bottom) / tb;
            dest[10] = -(far + near) / fn;
            dest[11] = -1;
            dest[12] = 0;
            dest[13] = 0;
            dest[14] = -(far * near * 2) / fn;
            dest[15] = 0;
            return dest;
        },

        /**
         * Returns a 4x4 perspective projection matrix.
         * @method perspectiveMat4v
         * @static
         */
        perspectiveMat4: function (fovyrad, aspectratio, znear, zfar, m) {
            var pmin = [];
            var pmax = [];

            pmin[2] = znear;
            pmax[2] = zfar;

            pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);
            pmin[1] = -pmax[1];

            pmax[0] = pmax[1] * aspectratio;
            pmin[0] = -pmax[0];

            return math.frustumMat4v(pmin, pmax, m);
        },

        /**
         * Transforms a three-element position by a 4x4 matrix.
         * @method transformPoint3
         * @static
         */
        transformPoint3: function (m, p, dest) {

            dest = dest || math.vec3();

            dest[0] = (m[0] * p[0]) + (m[4] * p[1]) + (m[8] * p[2]) + m[12];
            dest[1] = (m[1] * p[0]) + (m[5] * p[1]) + (m[9] * p[2]) + m[13];
            dest[2] = (m[2] * p[0]) + (m[6] * p[1]) + (m[10] * p[2]) + m[14];

            return dest;
        },

        /**
         * Transforms a homogeneous coordinate by a 4x4 matrix.
         * @method transformPoint3
         * @static
         */
        transformPoint4: function (m, v, dest) {

            dest = dest || math.vec4();

            dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];
            dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];
            dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];
            dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];

            return dest;
        },


        /**
         * Transforms an array of three-element positions by a 4x4 matrix.
         * @method transformPoints3
         * @static
         */
        transformPoints3: function (m, points, points2) {
            var result = points2 || [];
            var len = points.length;
            var p0, p1, p2;
            var pi;

            // cache values
            var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3];
            var m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7];
            var m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11];
            var m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15];

            var r;

            for (var i = 0; i < len; ++i) {

                // cache values
                pi = points[i];

                p0 = pi[0];
                p1 = pi[1];
                p2 = pi[2];

                r = result[i] || (result[i] = [0, 0, 0]);

                r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;
                r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;
                r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;
                r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;
            }

            result.length = len;

            return result;
        },

        /**
         * Transforms an array of positions by a 4x4 matrix.
         * @method transformPositions3
         * @static
         */
        transformPositions3: function (m, p, p2) {

            p2 = p2 || p;

            var i;
            var len = p.length;

            var x;
            var y;
            var z;

            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var m9 = m[9];
            var m10 = m[10];
            var m11 = m[11];
            var m12 = m[12];
            var m13 = m[13];
            var m14 = m[14];
            var m15 = m[15];

            for (i = 0; i < len; i += 3) {

                x = p[i + 0];
                y = p[i + 1];
                z = p[i + 2];

                p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;
                p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;
                p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;
                p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;
            }

            return p2;
        },

        /**
         * Transforms an array of positions by a 4x4 matrix.
         * @method transformPositions4
         * @static
         */
        transformPositions4: function (m, p, p2) {

            p2 = p2 || p;

            var i;
            var len = p.length;

            var x;
            var y;
            var z;

            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];
            var m9 = m[9];
            var m10 = m[10];
            var m11 = m[11];
            var m12 = m[12];
            var m13 = m[13];
            var m14 = m[14];
            var m15 = m[15];

            for (i = 0; i < len; i += 4) {

                x = p[i + 0];
                y = p[i + 1];
                z = p[i + 2];

                p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;
                p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;
                p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;
                p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;
            }

            return p2;
        },

        /**
         * Transforms a three-element vector by a 4x4 matrix.
         * @method transformVec3
         * @static
         */
        transformVec3: function (m, v, dest) {
            var v0 = v[0], v1 = v[1], v2 = v[2];
            dest = dest || this.vec3();
            dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);
            dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);
            dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);
            return dest;
        },

        /**
         * Transforms a four-element vector by a 4x4 matrix.
         * @method transformVec4
         * @static
         */
        transformVec4: function (m, v, dest) {
            var v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];
            dest = dest || math.vec4();
            dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
            dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
            dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
            dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
            return dest;
        },

        /**
         * Rotate a 3D vector around the x-axis
         *
         * @method rotateVec3X
         * @param {Float32Array} a The vec3 point to rotate
         * @param {Float32Array} b The origin of the rotation
         * @param {Number} c The angle of rotation
         * @param {Float32Array} dest The receiving vec3
         * @returns {Float32Array} dest
         * @static
         */
        rotateVec3X: function (a, b, c, dest) {

            var p = [], r = [];

            //Translate point to the origin
            p[0] = a[0] - b[0];
            p[1] = a[1] - b[1];
            p[2] = a[2] - b[2];

            //perform rotation
            r[0] = p[0];
            r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
            r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

            //translate to correct position
            dest[0] = r[0] + b[0];
            dest[1] = r[1] + b[1];
            dest[2] = r[2] + b[2];

            return dest;
        },

        /**
         * Rotate a 3D vector around the y-axis
         *
         * @method rotateVec3Y
         * @param {Float32Array} a The vec3 point to rotate
         * @param {Float32Array} b The origin of the rotation
         * @param {Number} c The angle of rotation
         * @param {Float32Array} dest The receiving vec3
         * @returns {Float32Array} dest
         * @static
         */
        rotateVec3Y: function (a, b, c, dest) {

            var p = [], r = [];

            //Translate point to the origin
            p[0] = a[0] - b[0];
            p[1] = a[1] - b[1];
            p[2] = a[2] - b[2];

            //perform rotation
            r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
            r[1] = p[1];
            r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

            //translate to correct position
            dest[0] = r[0] + b[0];
            dest[1] = r[1] + b[1];
            dest[2] = r[2] + b[2];

            return dest;
        },

        /**
         * Rotate a 3D vector around the z-axis
         *
         * @method rotateVec3Z
         * @param {Float32Array} a The vec3 point to rotate
         * @param {Float32Array} b The origin of the rotation
         * @param {Number} c The angle of rotation
         * @param {Float32Array} dest The receiving vec3
         * @returns {Float32Array} dest
         * @static
         */
        rotateVec3Z: function (a, b, c, dest) {

            var p = [], r = [];

            //Translate point to the origin
            p[0] = a[0] - b[0];
            p[1] = a[1] - b[1];
            p[2] = a[2] - b[2];

            //perform rotation
            r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
            r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
            r[2] = p[2];

            //translate to correct position
            dest[0] = r[0] + b[0];
            dest[1] = r[1] + b[1];
            dest[2] = r[2] + b[2];

            return dest;
        },

        /**
         * Transforms a four-element vector by a 4x4 projection matrix.
         *
         * @method projectVec4
         * @param {Float32Array} p 3D View-space coordinate
         * @param {Float32Array} q 2D Projected coordinate
         * @returns {Float32Array} 2D Projected coordinate
         * @static
         */
        projectVec4: function (p, q) {
            var f = 1.0 / p[3];
            q = q || math.vec2();
            q[0] = v[0] * f;
            q[1] = v[1] * f;
            return q;
        },

        /**
         * Unprojects a three-element vector.
         *
         * @method unprojectVec3
         * @param {Float32Array} p 3D Projected coordinate
         * @param {Float32Array} viewMat View matrix
         * @returns {Float32Array} projMat Projection matrix
         * @static
         */
        unprojectVec3: (function () {
            var mat = new Float32Array(16);
            var mat2 = new Float32Array(16);
            var mat3 = new Float32Array(16);
            return function (p, viewMat, projMat, q) {
                return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)
            };
        })(),

        /**
         * Linearly interpolates between two 3D vectors.
         * @method lerpVec3
         * @static
         */
        lerpVec3: function (t, t1, t2, p1, p2, dest) {
            var result = dest || math.vec3();
            var f = (t - t1) / (t2 - t1);
            result[0] = p1[0] + (f * (p2[0] - p1[0]));
            result[1] = p1[1] + (f * (p2[1] - p1[1]));
            result[2] = p1[2] + (f * (p2[2] - p1[2]));
            return result;
        },


        /**
         * Flattens a two-dimensional array into a one-dimensional array.
         *
         * @method flatten
         * @static
         * @param {Array of Arrays} a A 2D array
         * @returns Flattened 1D array
         */
        flatten: function (a) {

            var result = [];

            var i;
            var leni;
            var j;
            var lenj;
            var item;

            for (i = 0, leni = a.length; i < leni; i++) {
                item = a[i];
                for (j = 0, lenj = item.length; j < lenj; j++) {
                    result.push(item[j]);
                }
            }

            return result;
        },


        identityQuaternion: function (dest) {
            dest = dest || math.vec4();
            dest[0] = 0.0;
            dest[1] = 0.0;
            dest[2] = 0.0;
            dest[3] = 1.0;
            return dest;
        },

        /**
         * Initializes a quaternion from Euler angles.
         *
         * @param {Float32Array} euler The Euler angles.
         * @param {String} order Euler angle order: "XYZ", "YXZ", "ZXY" etc.
         * @param {Float32Array} [dest] Destination quaternion, created by default.
         * @returns {Float32Array} The quaternion.
         */
        eulerToQuaternion: function (euler, order, dest) {

            dest = dest || math.vec4();

            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m

            var a = (euler[0] * math.DEGTORAD) / 2;
            var b = (euler[1] * math.DEGTORAD) / 2;
            var c = (euler[2] * math.DEGTORAD) / 2;

            var c1 = Math.cos(a);
            var c2 = Math.cos(b);
            var c3 = Math.cos(c);
            var s1 = Math.sin(a);
            var s2 = Math.sin(b);
            var s3 = Math.sin(c);

            if (order === 'XYZ') {

                dest[0] = s1 * c2 * c3 + c1 * s2 * s3;
                dest[1] = c1 * s2 * c3 - s1 * c2 * s3;
                dest[2] = c1 * c2 * s3 + s1 * s2 * c3;
                dest[3] = c1 * c2 * c3 - s1 * s2 * s3;

            } else if (order === 'YXZ') {

                dest[0] = s1 * c2 * c3 + c1 * s2 * s3;
                dest[1] = c1 * s2 * c3 - s1 * c2 * s3;
                dest[2] = c1 * c2 * s3 - s1 * s2 * c3;
                dest[3] = c1 * c2 * c3 + s1 * s2 * s3;

            } else if (order === 'ZXY') {

                dest[0] = s1 * c2 * c3 - c1 * s2 * s3;
                dest[1] = c1 * s2 * c3 + s1 * c2 * s3;
                dest[2] = c1 * c2 * s3 + s1 * s2 * c3;
                dest[3] = c1 * c2 * c3 - s1 * s2 * s3;

            } else if (order === 'ZYX') {

                dest[0] = s1 * c2 * c3 - c1 * s2 * s3;
                dest[1] = c1 * s2 * c3 + s1 * c2 * s3;
                dest[2] = c1 * c2 * s3 - s1 * s2 * c3;
                dest[3] = c1 * c2 * c3 + s1 * s2 * s3;

            } else if (order === 'YZX') {

                dest[0] = s1 * c2 * c3 + c1 * s2 * s3;
                dest[1] = c1 * s2 * c3 + s1 * c2 * s3;
                dest[2] = c1 * c2 * s3 - s1 * s2 * c3;
                dest[3] = c1 * c2 * c3 - s1 * s2 * s3;

            } else if (order === 'XZY') {

                dest[0] = s1 * c2 * c3 - c1 * s2 * s3;
                dest[1] = c1 * s2 * c3 - s1 * c2 * s3;
                dest[2] = c1 * c2 * s3 + s1 * s2 * c3;
                dest[3] = c1 * c2 * c3 + s1 * s2 * s3;
            }

            return dest;
        },

        mat4ToQuaternion: function (m, dest) {

            dest = dest || math.vec4();

            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

            // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

            var m11 = m[0];
            var m12 = m[4];
            var m13 = m[8];
            var m21 = m[1];
            var m22 = m[5];
            var m23 = m[9];
            var m31 = m[2];
            var m32 = m[6];
            var m33 = m[10];
            var s;

            var trace = m11 + m22 + m33;

            if (trace > 0) {

                s = 0.5 / Math.sqrt(trace + 1.0);

                dest[3] = 0.25 / s;
                dest[0] = ( m32 - m23 ) * s;
                dest[1] = ( m13 - m31 ) * s;
                dest[2] = ( m21 - m12 ) * s;

            } else if (m11 > m22 && m11 > m33) {

                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

                dest[3] = ( m32 - m23 ) / s;
                dest[0] = 0.25 * s;
                dest[1] = ( m12 + m21 ) / s;
                dest[2] = ( m13 + m31 ) / s;

            } else if (m22 > m33) {

                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

                dest[3] = ( m13 - m31 ) / s;
                dest[0] = ( m12 + m21 ) / s;
                dest[1] = 0.25 * s;
                dest[2] = ( m23 + m32 ) / s;

            } else {

                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

                dest[3] = ( m21 - m12 ) / s;
                dest[0] = ( m13 + m31 ) / s;
                dest[1] = ( m23 + m32 ) / s;
                dest[2] = 0.25 * s;
            }

            return dest;
        },

        vec3PairToQuaternion: function (u, v, dest) {

            dest = dest || math.vec4();

            var norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));
            var real_part = norm_u_norm_v + math.dotVec3(u, v);

            if (real_part < 0.00000001 * norm_u_norm_v) {

                // If u and v are exactly opposite, rotate 180 degrees
                // around an arbitrary orthogonal axis. Axis normalisation
                // can happen later, when we normalise the quaternion.

                real_part = 0.0;

                if (Math.abs(u[0]) > Math.abs(u[2])) {

                    dest[0] = -u[1];
                    dest[1] = u[0];
                    dest[2] = 0;

                } else {
                    dest[0] = 0;
                    dest[1] = -u[2];
                    dest[2] = u[1]
                }

            } else {

                // Otherwise, build quaternion the standard way.
                math.cross3Vec3(u, v, dest);
            }

            dest[3] = real_part;

            return math.normalizeQuaternion(dest);
        },

        angleAxisToQuaternion: function (angleAxis, dest) {
            dest = dest || math.vec4();
            var halfAngle = angleAxis[3] / 2.0;
            var fsin = Math.sin(halfAngle);
            dest[0] = fsin * angleAxis[0];
            dest[1] = fsin * angleAxis[1];
            dest[2] = fsin * angleAxis[2];
            dest[3] = Math.cos(halfAngle);
            return dest;
        },

        quaternionToEuler: function (euler, order, dest) {
            dest = dest || math.vec4();
            var halfAngle = euler[3] / 2.0;
            var fsin = Math.sin(halfAngle);
            dest[0] = fsin * euler[0];
            dest[1] = fsin * euler[1];
            dest[2] = fsin * euler[2];
            dest[3] = Math.cos(halfAngle);
            return dest;
        },

        mulQuaternions: function (p, q, dest) {
            dest = dest || math.vec4();
            var p0 = p[0], p1 = p[1], p2 = p[2], p3 = p[3];
            var q0 = q[0], q1 = q[1], q2 = q[2], q3 = q[3];
            dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;
            dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;
            dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;
            dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;
            return dest;
        },

        vec3ApplyQuaternion: function (q, vec, dest) {

            dest = dest || math.vec3();

            var x = vec[0];
            var y = vec[1];
            var z = vec[2];

            var qx = q[0];
            var qy = q[1];
            var qz = q[2];
            var qw = q[3];

            // calculate quat * vector

            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;

            // calculate result * inverse quat

            dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

            return dest;
        },

        quaternionToMat4: function (q, dest) {

            dest = math.identityMat4(dest);

            var q0 = q[0];  //x
            var q1 = q[1];  //y
            var q2 = q[2];  //z
            var q3 = q[3];  //w

            var tx = 2.0 * q0;
            var ty = 2.0 * q1;
            var tz = 2.0 * q2;

            var twx = tx * q3;
            var twy = ty * q3;
            var twz = tz * q3;

            var txx = tx * q0;
            var txy = ty * q0;
            var txz = tz * q0;

            var tyy = ty * q1;
            var tyz = tz * q1;
            var tzz = tz * q2;

            dest[0] = 1.0 - (tyy + tzz);
            dest[1] = txy + twz;
            dest[2] = txz - twy;

            dest[4] = txy - twz;
            dest[5] = 1.0 - (txx + tzz);
            dest[6] = tyz + twx;

            dest[8] = txz + twy;
            dest[9] = tyz - twx;

            dest[10] = 1.0 - (txx + tyy);

            return dest;
        },

        quaternionToRotationMat4: function (q, m) {

            var x = q[0];
            var y = q[1];
            var z = q[2];
            var w = q[3];

            var x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;

            m[0] = 1 - ( yy + zz );
            m[4] = xy - wz;
            m[8] = xz + wy;

            m[1] = xy + wz;
            m[5] = 1 - ( xx + zz );
            m[9] = yz - wx;

            m[2] = xz - wy;
            m[6] = yz + wx;
            m[10] = 1 - ( xx + yy );

            // last column
            m[3] = 0;
            m[7] = 0;
            m[11] = 0;

            // bottom row
            m[12] = 0;
            m[13] = 0;
            m[14] = 0;
            m[15] = 1;

            return m;
        },

        normalizeQuaternion: function (q, dest) {
            dest = dest || q;
            var len = math.lenVec4([q[0], q[1], q[2], q[3]]);
            dest[0] = q[0] / len;
            dest[1] = q[1] / len;
            dest[2] = q[2] / len;
            dest[3] = q[3] / len;
            return dest;
        },

        conjugateQuaternion: function (q, dest) {
            dest = dest || q;
            dest[0] = -q[0];
            dest[1] = -q[1];
            dest[2] = -q[2];
            dest[3] = q[3];
            return dest;
        },

        inverseQuaternion: function (q, dest) {
            return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));
        },

        quaternionToAngleAxis: function (q, angleAxis) {
            angleAxis = angleAxis || math.vec4();
            q = math.normalizeQuaternion(q, tempVec4);
            var q3 = q[3];
            var angle = 2 * Math.acos(q3);
            var s = Math.sqrt(1 - q3 * q3);
            if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
                angleAxis[0] = q[0];
                angleAxis[1] = q[1];
                angleAxis[2] = q[2];
            } else {
                angleAxis[0] = q[0] / s;
                angleAxis[1] = q[1] / s;
                angleAxis[2] = q[2] / s;
            }
            angleAxis[3] = angle; // * 57.295779579;
            return angleAxis;
        },

        decompressPosition: function (position, decodeMatrix, dest) {
            dest[0] = position[0] * decodeMatrix[0] + decodeMatrix[12];
            dest[1] = position[1] * decodeMatrix[5] + decodeMatrix[13];
            dest[2] = position[2] * decodeMatrix[10] + decodeMatrix[14];
        },

        decompressPositions: function (positions, decodeMatrix, dest) {
            dest = dest || new Float32Array(positions.length);
            for (var i = 0, len = positions.length; i < len; i += 3) {
                dest[i + 0] = positions[i + 0] * decodeMatrix[0] + decodeMatrix[12];
                dest[i + 1] = positions[i + 1] * decodeMatrix[5] + decodeMatrix[13];
                dest[i + 2] = positions[i + 2] * decodeMatrix[10] + decodeMatrix[14];
            }
            return dest;
        },

        decompressUV: function (uv, decodeMatrix, dest) {
            dest[0] = uv[0] * decodeMatrix[0] + decodeMatrix[6];
            dest[1] = uv[1] * decodeMatrix[4] + decodeMatrix[7];
        },

        decompressUVs: function (uvs, decodeMatrix, dest) {
            dest = dest || new Float32Array(uvs.length);
            for (var i = 0, len = uvs.length; i < len; i += 3) {
                dest[i + 0] = uvs[i + 0] * decodeMatrix[0] + decodeMatrix[6];
                dest[i + 1] = uvs[i + 1] * decodeMatrix[4] + decodeMatrix[7];
            }
            return dest;
        },

        octDecodeVec2: function (oct, result) {
            var x = oct[0];
            var y = oct[1];
            x = (2 * x + 1) / 255;
            y = (2 * y + 1) / 255;
            var z = 1 - Math.abs(x) - Math.abs(y);
            if (z < 0) {
                x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
                y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
            }
            var length = Math.sqrt(x * x + y * y + z * z);
            result[0] = x / length;
            result[1] = y / length;
            result[2] = z / length;
            return result;
        },

        octDecodeVec2s: function (octs, result) {
            for (var i = 0, j = 0, len = octs.length; i < len; i += 2) {
                var x = octs[i + 0];
                var y = octs[i + 1];
                x = (2 * x + 1) / 255;
                y = (2 * y + 1) / 255;
                var z = 1 - Math.abs(x) - Math.abs(y);
                if (z < 0) {
                    x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
                    y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
                }
                var length = Math.sqrt(x * x + y * y + z * z);
                result[j + 0] = x / length;
                result[j + 1] = y / length;
                result[j + 2] = z / length;
                j += 3;
            }
            return result;
        }
    };

})();;/**
 * Boundary math functions.
 */
(function () {

    "use strict";

    var math = xeogl.math;

    /**
     * Returns a new, uninitialized 3D axis-aligned bounding box.
     *
     * @private
     */
    math.AABB3 = function (values) {
        return new Float32Array(values || 6);
    };

    /**
     * Returns a new, uninitialized 2D axis-aligned bounding box.
     *
     * @private
     */
    math.AABB2 = function (values) {
        return new Float32Array(values || 4);
    };

    /**
     * Returns a new, uninitialized 3D oriented bounding box (OBB).
     *
     * @private
     */
    math.OBB3 = function (values) {
        return new Float32Array(values || 32);
    };

    /**
     * Returns a new, uninitialized 2D oriented bounding box (OBB).
     *
     * @private
     */
    math.OBB2 = function (values) {
        return new Float32Array(values || 16);
    };


    /**
     * Transforms an OBB3 by a 4x4 matrix.
     *
     * @private
     */
    math.transformOBB3 = function (m, p, p2) {

        p2 = p2 || p;

        var i;
        var len = p.length;

        var x;
        var y;
        var z;

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];

        for (i = 0; i < len; i += 4) {

            x = p[i + 0];
            y = p[i + 1];
            z = p[i + 2];

            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;
            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;
            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;
            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;
        }

        return p2;
    };

    /**
     * Gets the diagonal size of an AABB3 given as minima and maxima.
     *
     * @private
     */
    math.getAABB3Diag = (function () {

        var min = new Float32Array(3);
        var max = new Float32Array(3);
        var tempVec3 = new Float32Array(3);

        return function (aabb) {

            min[0] = aabb[0];
            min[1] = aabb[1];
            min[2] = aabb[2];

            max[0] = aabb[3];
            max[1] = aabb[4];
            max[2] = aabb[5];

            math.subVec3(max, min, tempVec3);

            return Math.abs(math.lenVec3(tempVec3));
        };
    })();

    /**
     * Get a diagonal boundary size that is symmetrical about the given point.
     *
     * @private
     */
    math.getAABB3DiagPoint = (function () {

        var min = new Float32Array(3);
        var max = new Float32Array(3);
        var tempVec3 = new Float32Array(3);

        return function (aabb, p) {

            min[0] = aabb[0];
            min[1] = aabb[1];
            min[2] = aabb[2];

            max[0] = aabb[3];
            max[1] = aabb[4];
            max[2] = aabb[5];

            var diagVec = math.subVec3(max, min, tempVec3);

            var xneg = p[0] - aabb[0];
            var xpos = aabb[3] - p[0];
            var yneg = p[1] - aabb[1];
            var ypos = aabb[4] - p[1];
            var zneg = p[2] - aabb[2];
            var zpos = aabb[5] - p[2];

            diagVec[0] += (xneg > xpos) ? xneg : xpos;
            diagVec[1] += (yneg > ypos) ? yneg : ypos;
            diagVec[2] += (zneg > zpos) ? zneg : zpos;

            return Math.abs(math.lenVec3(diagVec));
        };
    })();

    /**
     * Gets the center of an AABB.
     *
     * @private
     */
    math.getAABB3Center = function (aabb, dest) {
        var r = dest || math.vec3();

        r[0] = (aabb[0] + aabb[3] ) / 2;
        r[1] = (aabb[1] + aabb[4] ) / 2;
        r[2] = (aabb[2] + aabb[5] ) / 2;

        return r;
    };

    /**
     * Gets the center of a 2D AABB.
     *
     * @private
     */
    math.getAABB2Center = function (aabb, dest) {
        var r = dest || math.vec2();

        r[0] = (aabb[2] + aabb[0] ) / 2;
        r[1] = (aabb[3] + aabb[1] ) / 2;

        return r;
    };

    /**
     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.
     * Creates new AABB if none supplied.
     *
     * @private
     */
    math.collapseAABB3 = function (aabb) {

        aabb = aabb || math.AABB3();

        aabb[0] = xeogl.math.MAX_DOUBLE;
        aabb[1] = xeogl.math.MAX_DOUBLE;
        aabb[2] = xeogl.math.MAX_DOUBLE;
        aabb[3] = -xeogl.math.MAX_DOUBLE;
        aabb[4] = -xeogl.math.MAX_DOUBLE;
        aabb[5] = -xeogl.math.MAX_DOUBLE;

        return aabb;
    };

    /**
     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of
     * an array of eight 3D positions, one for each corner of the boundary.
     *
     * @private
     */
    math.AABB3ToOBB3 = function (aabb, obb) {

        obb = obb || math.OBB3();

        obb[0] = aabb[0];
        obb[1] = aabb[1];
        obb[2] = aabb[2];
        obb[3] = 1;

        obb[4] = aabb[3];
        obb[5] = aabb[1];
        obb[6] = aabb[2];
        obb[7] = 1;

        obb[8] = aabb[3];
        obb[9] = aabb[4];
        obb[10] = aabb[2];
        obb[11] = 1;

        obb[12] = aabb[0];
        obb[13] = aabb[4];
        obb[14] = aabb[2];
        obb[15] = 1;

        obb[16] = aabb[0];
        obb[17] = aabb[1];
        obb[18] = aabb[5];
        obb[19] = 1;

        obb[20] = aabb[3];
        obb[21] = aabb[1];
        obb[22] = aabb[5];
        obb[23] = 1;

        obb[24] = aabb[3];
        obb[25] = aabb[4];
        obb[26] = aabb[5];
        obb[27] = 1;

        obb[28] = aabb[0];
        obb[29] = aabb[4];
        obb[30] = aabb[5];
        obb[31] = 1;

        return obb;
    };

    /**
     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.
     *
     * @private
     */
    math.positions3ToAABB3 = (function() {

        var p = new Float32Array(3);

        return function (positions, aabb, positionsDecodeMatrix) {

            aabb = aabb || math.AABB3();

            var xmin = xeogl.math.MAX_DOUBLE;
            var ymin = xeogl.math.MAX_DOUBLE;
            var zmin = xeogl.math.MAX_DOUBLE;
            var xmax = -xeogl.math.MAX_DOUBLE;
            var ymax = -xeogl.math.MAX_DOUBLE;
            var zmax = -xeogl.math.MAX_DOUBLE;

            var x, y, z;

            for (var i = 0, len = positions.length; i < len; i += 3) {

                if (positionsDecodeMatrix) {

                    p[0] = positions[i + 0];
                    p[1] = positions[i + 1];
                    p[2] = positions[i + 2];

                    math.decompressPosition(p, positionsDecodeMatrix, p);

                    x = p[0];
                    y = p[1];
                    z = p[2];

                } else {
                    x = positions[i + 0];
                    y = positions[i + 1];
                    z = positions[i + 2];
                }

                if (x < xmin) {
                    xmin = x;
                }

                if (y < ymin) {
                    ymin = y;
                }

                if (z < zmin) {
                    zmin = z;
                }

                if (x > xmax) {
                    xmax = x;
                }

                if (y > ymax) {
                    ymax = y;
                }

                if (z > zmax) {
                    zmax = z;
                }
            }

            aabb[0] = xmin;
            aabb[1] = ymin;
            aabb[2] = zmin;
            aabb[3] = xmax;
            aabb[4] = ymax;
            aabb[5] = zmax;

            return aabb;
        };
    })();

    /**
     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.
     *
     * @private
     */
    math.OBB3ToAABB3 = function (obb, aabb) {

        aabb = aabb || math.AABB3();

        var xmin = xeogl.math.MAX_DOUBLE;
        var ymin = xeogl.math.MAX_DOUBLE;
        var zmin = xeogl.math.MAX_DOUBLE;
        var xmax = -xeogl.math.MAX_DOUBLE;
        var ymax = -xeogl.math.MAX_DOUBLE;
        var zmax = -xeogl.math.MAX_DOUBLE;

        var x, y, z;

        for (var i = 0, len = obb.length; i < len; i += 4) {

            x = obb[i + 0];
            y = obb[i + 1];
            z = obb[i + 2];

            if (x < xmin) {
                xmin = x;
            }

            if (y < ymin) {
                ymin = y;
            }

            if (z < zmin) {
                zmin = z;
            }

            if (x > xmax) {
                xmax = x;
            }

            if (y > ymax) {
                ymax = y;
            }

            if (z > zmax) {
                zmax = z;
            }
        }

        aabb[0] = xmin;
        aabb[1] = ymin;
        aabb[2] = zmin;
        aabb[3] = xmax;
        aabb[4] = ymax;
        aabb[5] = zmax;

        return aabb;
    };

    /**
     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.
     *
     * @private
     */
    math.points3ToAABB3 = function (points, aabb) {

        aabb = aabb || math.AABB3();

        var xmin = xeogl.math.MAX_DOUBLE;
        var ymin = xeogl.math.MAX_DOUBLE;
        var zmin = xeogl.math.MAX_DOUBLE;
        var xmax = -xeogl.math.MAX_DOUBLE;
        var ymax = -xeogl.math.MAX_DOUBLE;
        var zmax = -xeogl.math.MAX_DOUBLE;

        var x, y, z;

        for (var i = 0, len = points.length; i < len; i++) {

            x = points[i][0];
            y = points[i][1];
            z = points[i][2];

            if (x < xmin) {
                xmin = x;
            }

            if (y < ymin) {
                ymin = y;
            }

            if (z < zmin) {
                zmin = z;
            }

            if (x > xmax) {
                xmax = x;
            }

            if (y > ymax) {
                ymax = y;
            }

            if (z > zmax) {
                zmax = z;
            }
        }

        aabb[0] = xmin;
        aabb[1] = ymin;
        aabb[2] = zmin;
        aabb[3] = xmax;
        aabb[4] = ymax;
        aabb[5] = zmax;

        return aabb;
    };

    /**
     * Finds the minimum boundary sphere enclosing the given 3D points.
     *
     * @private
     */
    math.points3ToSphere3 = (function () {

        var tempVec3 = new Float32Array(3);

        return function (points, sphere) {

            sphere = sphere || math.vec4();

            var x = 0;
            var y = 0;
            var z = 0;

            var i;
            var numPoints = points.length;

            for (i = 0; i < numPoints; i++) {
                x += points[i][0];
                y += points[i][1];
                z += points[i][2];
            }

            sphere[0] = x / numPoints;
            sphere[1] = y / numPoints;
            sphere[2] = z / numPoints;

            var radius = 0;
            var dist;

            for (i = 0; i < numPoints; i++) {

                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));

                if (dist > radius) {
                    radius = dist;
                }
            }

            sphere[3] = radius;

            return sphere;
        };
    })();

    /**
     * Finds the minimum boundary sphere enclosing the given 3D points.
     *
     * @private
     */
    math.OBB3ToSphere3 = (function () {

        var point = new Float32Array(3);
        var tempVec3 = new Float32Array(3);

        return function (points, sphere) {

            sphere = sphere || math.vec4();

            var x = 0;
            var y = 0;
            var z = 0;

            var i;
            var lenPoints = points.length;
            var numPoints = lenPoints / 4;

            for (i = 0; i < lenPoints; i += 4) {
                x += points[i + 0];
                y += points[i + 1];
                z += points[i + 2];
            }

            sphere[0] = x / numPoints;
            sphere[1] = y / numPoints;
            sphere[2] = z / numPoints;

            var radius = 0;
            var dist;

            for (i = 0; i < lenPoints; i += 4) {

                point[0] = points[i + 0];
                point[1] = points[i + 1];
                point[2] = points[i + 2];

                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));

                if (dist > radius) {
                    radius = dist;
                }
            }

            sphere[3] = radius;

            return sphere;
        };
    })();

    /**
     * Gets the center of a bounding sphere.
     *
     * @private
     */
    math.getSphere3Center = function (sphere, dest) {
        dest = dest || math.vec3();

        dest[0] = sphere[0];
        dest[1] = sphere[1];
        dest[2] = sphere[2];

        return dest;
    };

    /**
     * Expands the first axis-aligned 3D boundary to enclose the second, if required.
     *
     * @private
     */
    math.expandAABB3 = function (aabb1, aabb2) {

        if (aabb1[0] > aabb2[0]) {
            aabb1[0] = aabb2[0];
        }

        if (aabb1[1] > aabb2[1]) {
            aabb1[1] = aabb2[1];
        }

        if (aabb1[2] > aabb2[2]) {
            aabb1[2] = aabb2[2];
        }

        if (aabb1[3] < aabb2[3]) {
            aabb1[3] = aabb2[3];
        }

        if (aabb1[4] < aabb2[4]) {
            aabb1[4] = aabb2[4];
        }

        if (aabb1[5] < aabb2[5]) {
            aabb1[5] = aabb2[5];
        }

        return aabb1;
    };

    /**
     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.
     *
     * @private
     */
    math.expandAABB3Point3 = function (aabb, p) {

        if (aabb[0] < p[0]) {
            aabb[0] = p[0];
        }

        if (aabb[1] < p[1]) {
            aabb[1] = p[1];
        }

        if (aabb[2] < p[2]) {
            aabb[2] = p[2];
        }

        if (aabb[3] > p[0]) {
            aabb[3] = p[0];
        }

        if (aabb[4] > p[1]) {
            aabb[4] = p[1];
        }

        if (aabb[5] > p[2]) {
            aabb[5] = p[2];
        }

        return aabb;
    };

    /**
     * Collapses a 2D axis-aligned boundary, ready to expand to fit 2D points.
     * Creates new AABB if none supplied.
     *
     * @private
     */
    math.collapseAABB2 = function (aabb) {

        aabb = aabb || math.AABB2();

        aabb[0] = xeogl.math.MAX_DOUBLE;
        aabb[1] = xeogl.math.MAX_DOUBLE;
        aabb[2] = -xeogl.math.MAX_DOUBLE;
        aabb[3] = -xeogl.math.MAX_DOUBLE;

        return aabb;
    };

    /**
     * Finds the minimum 2D projected axis-aligned boundary enclosing the given 3D points.
     *
     * @private
     */
    math.OBB3ToAABB2 = function (points, aabb) {

        aabb = aabb || math.AABB2();

        var xmin = xeogl.math.MAX_DOUBLE;
        var ymin = xeogl.math.MAX_DOUBLE;
        var xmax = -xeogl.math.MAX_DOUBLE;
        var ymax = -xeogl.math.MAX_DOUBLE;

        var x;
        var y;
        var w;
        var f;

        for (var i = 0, len = points.length; i < len; i += 4) {

            x = points[i + 0];
            y = points[i + 1];
            w = points[i + 3] || 1.0;

            f = 1.0 / w;

            x *= f;
            y *= f;

            if (x < xmin) {
                xmin = x;
            }

            if (y < ymin) {
                ymin = y;
            }

            if (x > xmax) {
                xmax = x;
            }

            if (y > ymax) {
                ymax = y;
            }
        }

        aabb[0] = xmin;
        aabb[1] = ymin;
        aabb[2] = xmax;
        aabb[3] = ymax;

        return aabb;
    };

    /**
     * Expands the first axis-aligned 2D boundary to enclose the second, if required.
     *
     * @private
     */
    math.expandAABB2 = function (aabb1, aabb2) {

        if (aabb1[0] > aabb2[0]) {
            aabb1[0] = aabb2[0];
        }

        if (aabb1[1] > aabb2[1]) {
            aabb1[1] = aabb2[1];
        }

        if (aabb1[2] < aabb2[2]) {
            aabb1[2] = aabb2[2];
        }

        if (aabb1[3] < aabb2[3]) {
            aabb1[3] = aabb2[3];
        }

        return aabb1;
    };

    /**
     * Expands an axis-aligned 2D boundary to enclose the given point, if required.
     *
     * @private
     */
    math.expandAABB2Point2 = function (aabb, p) {

        if (aabb[0] > p[0]) {
            aabb[0] = p[0];
        }

        if (aabb[1] > p[1]) {
            aabb[1] = p[1];
        }

        if (aabb[2] < p[0]) {
            aabb[2] = p[0];
        }

        if (aabb[3] < p[1]) {
            aabb[3] = p[1];
        }

        return aabb;
    };

    math.AABB2ToCanvas = function (aabb, canvasWidth, canvasHeight, aabb2) {

        aabb2 = aabb2 || aabb;

        var xmin = (aabb[0] + 1.0) * 0.5;
        var ymin = (aabb[1] + 1.0) * 0.5;
        var xmax = (aabb[2] + 1.0) * 0.5;
        var ymax = (aabb[3] + 1.0) * 0.5;

        aabb2[0] = Math.floor(xmin * canvasWidth);
        aabb2[1] = canvasHeight - Math.floor(ymax * canvasHeight);
        aabb2[2] = Math.floor(xmax * canvasWidth);
        aabb2[3] = canvasHeight - Math.floor(ymin * canvasHeight);

        return aabb2;
    };

})();;/**
 * Geometry math functions.
 */
(function () {

    "use strict";

    var math = xeogl.math;

    /**
     * Calculates the normal vector of a triangle.
     *
     * @private
     */
    math.triangleNormal = function (a, b, c, normal) {

        normal = normal || math.vec3();

        var p1x = b[0] - a[0];
        var p1y = b[1] - a[1];
        var p1z = b[2] - a[2];

        var p2x = c[0] - a[0];
        var p2y = c[1] - a[1];
        var p2z = c[2] - a[2];

        var p3x = p1y * p2z - p1z * p2y;
        var p3y = p1z * p2x - p1x * p2z;
        var p3z = p1x * p2y - p1y * p2x;

        var mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);
        if (mag === 0) {
            normal[0] = 0;
            normal[1] = 0;
            normal[2] = 0;
        } else {
            normal[0] = p3x / mag;
            normal[1] = p3y / mag;
            normal[2] = p3z / mag;
        }

        return normal
    };

    /**
     * Finds the intersection of a 3D ray with a 3D triangle.
     *
     * @private
     */
    math.rayTriangleIntersect = (function() {

        var tempVec3 = new Float32Array(3);
        var tempVec3b = new Float32Array(3);
        var tempVec3c = new Float32Array(3);
        var tempVec3d = new Float32Array(3);
        var tempVec3e = new Float32Array(3);

        return function (origin, dir, a, b, c, isect) {

            isect = isect || math.vec3();

            var EPSILON = 0.000001;

            var edge1 = math.subVec3(b, a, tempVec3);
            var edge2 = math.subVec3(c, a, tempVec3b);

            var pvec = math.cross3Vec3(dir, edge2, tempVec3c);
            var det = math.dotVec3(edge1, pvec);
            if (det < EPSILON) {
                return null;
            }

            var tvec = math.subVec3(origin, a, tempVec3d);
            var u = math.dotVec3(tvec, pvec);
            if (u < 0 || u > det) {
                return null;
            }

            var qvec = math.cross3Vec3(tvec, edge1, tempVec3e);
            var v = math.dotVec3(dir, qvec);
            if (v < 0 || u + v > det) {
                return null;
            }

            var t = math.dotVec3(edge2, qvec) / det;
            isect[0] = origin[0] + t * dir[0];
            isect[1] = origin[1] + t * dir[1];
            isect[2] = origin[2] + t * dir[2];

            return isect;
        };
    })();

    /**
     * Finds the intersection of a 3D ray with a plane defined by 3 points.
     *
     * @private
     */
    math.rayPlaneIntersect = (function() {

        var tempVec3 = new Float32Array(3);
        var tempVec3b = new Float32Array(3);
        var tempVec3c = new Float32Array(3);
        var tempVec3d = new Float32Array(3);

        return function (origin, dir, a, b, c, isect) {

            isect = isect || math.vec3();

            dir = math.normalizeVec3(dir, tempVec3);

            var edge1 = math.subVec3(b, a, tempVec3b);
            var edge2 = math.subVec3(c, a, tempVec3c);

            var n = math.cross3Vec3(edge1, edge2, tempVec3d);
            math.normalizeVec3(n, n);

            var d = -math.dotVec3(a, n);

            var t = -(math.dotVec3(origin, n) + d) / math.dotVec3(dir, n);

            isect[0] = origin[0] + t * dir[0];
            isect[1] = origin[1] + t * dir[1];
            isect[2] = origin[2] + t * dir[2];

            return isect;
        };
    })();

    /**
     * Gets barycentric coordinates from cartesian coordinates within a triangle.
     * Gets barycentric coordinates from cartesian coordinates within a triangle.
     *
     * @private
     */
    math.cartesianToBarycentric = (function() {

        var tempVec3 = new Float32Array(3);
        var tempVec3b = new Float32Array(3);
        var tempVec3c = new Float32Array(3);

        return function (cartesian, a, b, c, dest) {

            var v0 = math.subVec3(c, a, tempVec3);
            var v1 = math.subVec3(b, a, tempVec3b);
            var v2 = math.subVec3(cartesian, a, tempVec3c);

            var dot00 = math.dotVec3(v0, v0);
            var dot01 = math.dotVec3(v0, v1);
            var dot02 = math.dotVec3(v0, v2);
            var dot11 = math.dotVec3(v1, v1);
            var dot12 = math.dotVec3(v1, v2);

            var denom = ( dot00 * dot11 - dot01 * dot01 );

            // Colinear or singular triangle

            if (denom === 0) {

                // Arbitrary location outside of triangle

                return null;
            }

            var invDenom = 1 / denom;

            var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
            var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

            dest[0] = 1 - u - v;
            dest[1] = v;
            dest[2] = u;

            return dest;
        };
    })();

    /**
     * Returns true if the given barycentric coordinates are within their triangle.
     *
     * @private
     */
    math.barycentricInsideTriangle = function (bary) {

        var v = bary[1];
        var u = bary[2];

        return (u >= 0) && (v >= 0) && (u + v < 1);
    };

    /**
     * Gets cartesian coordinates from barycentric coordinates within a triangle.
     *
     * @private
     */
    math.barycentricToCartesian = function (bary, a, b, c, cartesian) {

        cartesian = cartesian || math.vec3();

        var u = bary[0];
        var v = bary[1];
        var w = bary[2];

        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;
        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;
        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;

        return cartesian;
    };

})();;/**
 * Boundary math functions.
 */
(function () {

    "use strict";

    var math = xeogl.math;

    /**
     * Builds normal vectors from positions and indices.
     *
     * @private
     */
    math.buildNormals = (function () {

        var a = math.vec3();
        var b = math.vec3();
        var c = math.vec3();
        var ab = math.vec3();
        var ac = math.vec3();
        var crossVec = math.vec3();

        return function (positions, indices, normals) {

            var i;
            var len;
            var nvecs = new Array(positions.length / 3);
            var j0;
            var j1;
            var j2;

            for (i = 0, len = indices.length; i < len; i += 3) {

                j0 = indices[i];
                j1 = indices[i + 1];
                j2 = indices[i + 2];

                a[0] = positions[j0 * 3];
                a[1] = positions[j0 * 3 + 1];
                a[2] = positions[j0 * 3 + 2];

                b[0] = positions[j1 * 3];
                b[1] = positions[j1 * 3 + 1];
                b[2] = positions[j1 * 3 + 2];

                c[0] = positions[j2 * 3];
                c[1] = positions[j2 * 3 + 1];
                c[2] = positions[j2 * 3 + 2];

                math.subVec3(b, a, ab);
                math.subVec3(c, a, ac);

                var normVec = math.vec3();

                math.normalizeVec3(math.cross3Vec3(ab, ac, crossVec), normVec);

                if (!nvecs[j0]) {
                    nvecs[j0] = [];
                }
                if (!nvecs[j1]) {
                    nvecs[j1] = [];
                }
                if (!nvecs[j2]) {
                    nvecs[j2] = [];
                }

                nvecs[j0].push(normVec);
                nvecs[j1].push(normVec);
                nvecs[j2].push(normVec);
            }

            normals = (normals && normals.length === positions.length) ? normals : new Float32Array(positions.length);

            var count;
            var x;
            var y;
            var z;

            for (i = 0, len = nvecs.length; i < len; i++) {  // Now go through and average out everything

                count = nvecs[i].length;

                x = 0;
                y = 0;
                z = 0;

                for (var j = 0; j < count; j++) {
                    x += nvecs[i][j][0];
                    y += nvecs[i][j][1];
                    z += nvecs[i][j][2];
                }

                normals[i * 3] = (x / count);
                normals[i * 3 + 1] = (y / count);
                normals[i * 3 + 2] = (z / count);
            }

            return normals;
        };
    })();

    /**
     * Builds vertex tangent vectors from positions, UVs and indices.
     *
     * @private
     */
    math.buildTangents = (function () {

        var tempVec3 = new Float32Array(3);
        var tempVec3b = new Float32Array(3);
        var tempVec3c = new Float32Array(3);
        var tempVec3d = new Float32Array(3);
        var tempVec3e = new Float32Array(3);
        var tempVec3f = new Float32Array(3);
        var tempVec3g = new Float32Array(3);

        return function (positions, indices, uv) {

            var tangents = new Float32Array(positions.length);

            // The vertex arrays needs to be calculated
            // before the calculation of the tangents

            for (var location = 0; location < indices.length; location += 3) {

                // Recontructing each vertex and UV coordinate into the respective vectors

                var index = indices[location];

                var v0 = positions.subarray(index * 3, index * 3 + 3);
                var uv0 = uv.subarray(index * 2, index * 2 + 2);

                index = indices[location + 1];

                var v1 = positions.subarray(index * 3, index * 3 + 3);
                var uv1 = uv.subarray(index * 2, index * 2 + 2);

                index = indices[location + 2];

                var v2 = positions.subarray(index * 3, index * 3 + 3);
                var uv2 = uv.subarray(index * 2, index * 2 + 2);

                var deltaPos1 = math.subVec3(v1, v0, tempVec3);
                var deltaPos2 = math.subVec3(v2, v0, tempVec3b);

                var deltaUV1 = math.subVec2(uv1, uv0, tempVec3c);
                var deltaUV2 = math.subVec2(uv2, uv0, tempVec3d);

                var r = 1 / ((deltaUV1[0] * deltaUV2[1]) - (deltaUV1[1] * deltaUV2[0]));

                var tangent = math.mulVec3Scalar(
                    math.subVec3(
                        math.mulVec3Scalar(deltaPos1, deltaUV2[1], tempVec3e),
                        math.mulVec3Scalar(deltaPos2, deltaUV1[1], tempVec3f),
                        tempVec3g
                    ),
                    r,
                    tempVec3f
                );

                // Average the value of the vectors

                var addTo;

                for (var v = 0; v < 3; v++) {
                    addTo = indices[location + v] * 3;
                    tangents[addTo] += tangent[0];
                    tangents[addTo + 1] += tangent[1];
                    tangents[addTo + 2] += tangent[2];
                }
            }

            return tangents;
        };
    })();

    /**
     * Builds vertex and index arrays needed by color-indexed triangle picking.
     *
     * @private
     */
    math.buildPickTriangles = function (positions, indices, quantized) {

        var numIndices = indices.length;
        var pickPositions = quantized ? new Uint16Array(numIndices * 30) : new Float32Array(numIndices * 30); // FIXME: Why do we need to extend size like this to make large meshes pickable?
        var pickColors = new Uint8Array(numIndices * 40);
        var primIndex = 0;
        var vi;// Positions array index
        var pvi;// Picking positions array index
        var pci; // Picking color array index

        // Triangle indices
        var i;
        var r;
        var g;
        var b;
        var a;

        for (var location = 0; location < numIndices; location += 3) {

            pvi = location * 3;
            pci = location * 4;

            // Primitive-indexed triangle pick color

            a = (primIndex >> 24 & 0xFF);
            b = (primIndex >> 16 & 0xFF);
            g = (primIndex >> 8 & 0xFF);
            r = (primIndex & 0xFF);

            // A

            i = indices[location];
            vi = i * 3;

            pickPositions[pvi] = positions[vi];
            pickPositions[pvi + 1] = positions[vi + 1];
            pickPositions[pvi + 2] = positions[vi + 2];

            pickColors[pci + 0] = r;
            pickColors[pci + 1] = g;
            pickColors[pci + 2] = b;
            pickColors[pci + 3] = a;

            // B

            i = indices[location + 1];
            vi = i * 3;

            pickPositions[pvi + 3] = positions[vi];
            pickPositions[pvi + 4] = positions[vi + 1];
            pickPositions[pvi + 5] = positions[vi + 2];

            pickColors[pci + 4] = r;
            pickColors[pci + 5] = g;
            pickColors[pci + 6] = b;
            pickColors[pci + 7] = a;

            // C

            i = indices[location + 2];
            vi = i * 3;

            pickPositions[pvi + 6] = positions[vi];
            pickPositions[pvi + 7] = positions[vi + 1];
            pickPositions[pvi + 8] = positions[vi + 2];

            pickColors[pci + 8] = r;
            pickColors[pci + 9] = g;
            pickColors[pci + 10] = b;
            pickColors[pci + 11] = a;

            primIndex++;
        }

        return {
            positions: pickPositions,
            colors: pickColors
        };
    };

    /**
     * Removes duplicate vertices from a triangle mesh.
     * @returns {{positions: Array, uv: *, normals: *,indices: *}}
     */
    math.mergeVertices = function (positions, uv, normals, colors, indices) {

        var positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var uniquePositions = [];
        var uniqueUV = uv ? [] : null;
        var uniqueNormals = normals ? [] : null;
        var changes = [];
        var vx;
        var vy;
        var vz;
        var key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow(10, precisionPoints);
        var i;
        var il;

        for (i = 0, il = positions.length; i < il; i += 3) {

            vx = positions[i];
            vy = positions[i + 1];
            vz = positions[i + 2];

            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);

            if (positionsMap[key] === undefined) {

                positionsMap[key] = i / 3;

                uniquePositions.push(vx);
                uniquePositions.push(vy);
                uniquePositions.push(vz);

                if (uv) {
                    // uniqueUV.push(uv[i]);
                    // uniqueUV.push(uv[i + 1]);
                    // uniqueUV.push(uv[i + 2]);
                }

                if (normals) {
                    uniqueNormals.push(normals[i]);
                    uniqueNormals.push(normals[i + 1]);
                    uniqueNormals.push(normals[i + 2]);
                }

                changes[i / 3] = (uniquePositions.length - 3) / 3;

            } else {

                changes[i / 3] = changes[positionsMap[key]];
            }
        }

        var faceIndicesToRemove = [];

        for (i = 0, il = indices.length; i < il; i += 3) {

            indices[i + 0] = changes[indices[i + 0]];
            indices[i + 1] = changes[indices[i + 1]];
            indices[i + 2] = changes[indices[i + 2]];

            var indicesDup = [indices[i + 0], indices[i + 1], indices[i + 2]];

            for (var n = 0; n < 3; n++) {
                if (indicesDup[n] === indicesDup[( n + 1 ) % 3]) {
                    faceIndicesToRemove.push(i);
                    break;
                }
            }
        }

        if (faceIndicesToRemove.length > 0) {
            indices = Array.prototype.slice.call(indices); // splice is not available on typed arrays
            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                indices.splice(idx, 3);
            }
        }

        var result = {
            positions: uniquePositions,
            indices: indices
        };

        if (uv) {
            result.uv = uniqueUV;
        }

        if (normals) {
            result.normals = uniqueNormals;
        }

        return result;
    };

    /**
     * Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles
     * that don't share vertex array elements. Works by finding groups of vertices that have the same location and
     * averaging their normal vectors.
     *
     * @returns {{positions: Array, normals: *}}
     */
    math.faceToVertexNormals = function (positions, normals, options) {
        options = options || {};
        var smoothNormalsAngleThreshold = options.smoothNormalsAngleThreshold || 20;
        var vertexMap = {};
        var vertexNormals = [];
        var vertexNormalAccum = {};
        var acc;
        var vx;
        var vy;
        var vz;
        var key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow(10, precisionPoints);
        var posi;
        var i;
        var j;
        var len;
        var a;
        var b;
        var c;

        for (i = 0, len = positions.length; i < len; i += 3) {

            posi = i / 3;

            vx = positions[i];
            vy = positions[i + 1];
            vz = positions[i + 2];

            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);

            if (vertexMap[key] === undefined) {
                vertexMap[key] = [posi];
            } else {
                vertexMap[key].push(posi);
            }

            var normal = math.normalizeVec3([normals[i], normals[i + 1], normals[i + 2]]);

            vertexNormals[posi] = normal;

            acc = math.vec4([normal[0], normal[1], normal[2], 1]);

            vertexNormalAccum[posi] = acc;
        }

        for (key in vertexMap) {

            if (vertexMap.hasOwnProperty(key)) {

                var vertices = vertexMap[key];
                var numVerts = vertices.length;

                for (i = 0; i < numVerts; i++) {

                    var ii = vertices[i];

                    acc = vertexNormalAccum[ii];

                    for (j = 0; j < numVerts; j++) {

                        if (i === j) {
                            continue;
                        }

                        var jj = vertices[j];

                        a = vertexNormals[ii];
                        b = vertexNormals[jj];

                        var angle = Math.abs(math.angleVec3(a, b) / math.DEGTORAD);

                        if (angle < smoothNormalsAngleThreshold) {

                            acc[0] += b[0];
                            acc[1] += b[1];
                            acc[2] += b[2];
                            acc[3] += 1.0;
                        }
                    }
                }
            }
        }

        for (i = 0, len = normals.length; i < len; i += 3) {

            acc = vertexNormalAccum[i / 3];

            normals[i + 0] = acc[0] / acc[3];
            normals[i + 1] = acc[1] / acc[3];
            normals[i + 2] = acc[2] / acc[3];

        }
    };
}());;/**
 * Curve math functions.
 */
(function () {

    "use strict";

    var math = xeogl.math;

    math.tangentQuadraticBezier = function (t, p0, p1, p2) {
        return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );
    };

    math.tangentQuadraticBezier = function (t, p0, p1, p2, p3) {
        return -3 * p0 * (1 - t) * (1 - t) +
            3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
            6 * t * p2 * (1 - t) - 3 * t * t * p2 +
            3 * t * t * p3;
    };

    math.tangentSpline = function (t) {
        var h00 = 6 * t * t - 6 * t;
        var h10 = 3 * t * t - 4 * t + 1;
        var h01 = -6 * t * t + 6 * t;
        var h11 = 3 * t * t - 2 * t;
        return h00 + h10 + h01 + h11;
    };

    math.catmullRomInterpolate = function (p0, p1, p2, p3, t) {
        var v0 = ( p2 - p0 ) * 0.5;
        var v1 = ( p3 - p1 ) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
    };

    // Bezier Curve formulii from http://en.wikipedia.org/wiki/B%C3%A9zier_curve

    // Quad Bezier Functions

    math.b2p0 = function (t, p) {
        var k = 1 - t;
        return k * k * p;

    };

    math.b2p1 = function (t, p) {
        return 2 * ( 1 - t ) * t * p;
    };

    math.b2p2 = function (t, p) {
        return t * t * p;
    };

    math.b2 = function (t, p0, p1, p2) {
        return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);
    };

    // Cubic Bezier Functions

    math.b3p0 = function (t, p) {
        var k = 1 - t;
        return k * k * k * p;
    };

    math.b3p1 = function (t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    };

    math.b3p2 = function (t, p) {
        var k = 1 - t;
        return 3 * k * t * t * p;
    };

    math.b3p3 = function (t, p) {
        return t * t * t * p;
    };

    math.b3 = function (t, p0, p1, p2, p3) {
        return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);
    };
})();;/**
 * Ray casting support functions.
 */
(function () {

    "use strict";

    var math = xeogl.math;

    /**
     Transforms a Canvas-space position into a World-space ray, in the context of a Camera.
     @method canvasPosToWorldRay
     @static
     @param {Camera} camera The Camera.
     @param {Float32Array} canvasPos The Canvas-space position.
     @param {Float32Array} worldRayOrigin The World-space ray origin.
     @param {Float32Array} worldRayDir The World-space ray direction.
     */
    math.canvasPosToWorldRay = (function () {

        var tempMat4b = math.mat4();
        var tempMat4c = math.mat4();
        var tempVec4a = math.vec4();
        var tempVec4b = math.vec4();
        var tempVec4c = math.vec4();
        var tempVec4d = math.vec4();

        return function (camera, canvasPos, worldRayOrigin, worldRayDir) {

            var canvas = camera.scene.canvas.canvas;

            var viewMat = camera.viewMatrix;
            var projMat = camera.projection === "ortho" ? camera.ortho.matrix : camera.perspective.matrix;

            var pvMat = math.mulMat4(projMat, viewMat, tempMat4b);
            var pvMatInverse = math.inverseMat4(pvMat, tempMat4c);

            // Calculate clip space coordinates, which will be in range
            // of x=[-1..1] and y=[-1..1], with y=(+1) at top

            var canvasWidth = canvas.width;
            var canvasHeight = canvas.height;

            var clipX = (canvasPos[0] - canvasWidth / 2) / (canvasWidth / 2);  // Calculate clip space coordinates
            var clipY = -(canvasPos[1] - canvasHeight / 2) / (canvasHeight / 2);

            tempVec4a[0] = clipX;
            tempVec4a[1] = clipY;
            tempVec4a[2] = -1;
            tempVec4a[3] = 1;

            math.transformVec4(pvMatInverse, tempVec4a, tempVec4b);
            math.mulVec4Scalar(tempVec4b, 1 / tempVec4b[3]);

            tempVec4c[0] = clipX;
            tempVec4c[1] = clipY;
            tempVec4c[2] = 1;
            tempVec4c[3] = 1;

            math.transformVec4(pvMatInverse, tempVec4c, tempVec4d);
            math.mulVec4Scalar(tempVec4d, 1 / tempVec4d[3]);

            worldRayOrigin[0] = tempVec4d[0];
            worldRayOrigin[1] = tempVec4d[1];
            worldRayOrigin[2] = tempVec4d[2];

            math.subVec3(tempVec4d, tempVec4b, worldRayDir);

            math.normalizeVec3(worldRayDir);
        };
    })();

    /**
     Transforms a Canvas-space position to an Entity's Local-space coordinate system, in the context of a Camera.
     @method canvasPosToLocalRay
     @static
     @param {Camera} camera The Camera.
     @param {Entity} entity The Entity.
     @param {Float32Array} canvasPos The Canvas-space position.
     @param {Float32Array} localRayOrigin The Local-space ray origin.
     @param {Float32Array} localRayDir The Local-space ray direction.
     */
    math.canvasPosToLocalRay = (function () {

        var worldRayOrigin = math.vec3();
        var worldRayDir = math.vec3();

        return function (camera, entity, canvasPos, localRayOrigin, localRayDir) {
            math.canvasPosToWorldRay(camera, canvasPos, worldRayOrigin, worldRayDir);
            math.worldRayToLocalRay(entity, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir);
        };
    })();

    /**
     Transforms a ray from World-space to an Entity's Local-space coordinate system.
     @method worldRayToLocalRay
     @static
     @param {Entity} entity The Entity.
     @param {Float32Array} worldRayOrigin The World-space ray origin.
     @param {Float32Array} worldRayDir The World-space ray direction.
     @param {Float32Array} localRayOrigin The Local-space ray origin.
     @param {Float32Array} localRayDir The Local-space ray direction.
     */
    math.worldRayToLocalRay = (function () {

        var tempMat4 = math.mat4();
        var tempVec4a = math.vec4();
        var tempVec4b = math.vec4();

        return function (entity, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir) {

            var modelMat = entity.transform.leafMatrix;
            var modelMatInverse = math.inverseMat4(modelMat, tempMat4);

            tempVec4a[0] = worldRayOrigin[0];
            tempVec4a[1] = worldRayOrigin[1];
            tempVec4a[2] = worldRayOrigin[2];
            tempVec4a[3] = 1;

            math.transformVec4(modelMatInverse, tempVec4a, tempVec4b);

            localRayOrigin[0] = tempVec4b[0];
            localRayOrigin[1] = tempVec4b[1];
            localRayOrigin[2] = tempVec4b[2];

            math.transformVec3(modelMatInverse, worldRayDir, localRayDir);
        };
    })();
})();;/**
 * KD-tree functions
 */
(function () {

    "use strict";

    var KD_TREE_MAX_DEPTH = 10;
    var KD_TREE_MIN_TRIANGLES = 20;

    var math = xeogl.math;

    /**
     * Returns a KD-tree that contains the triangles of the given mesh
     *
     * @private
     */
    math.buildKDTree = function (indices, positions) {
        var numTris = indices.length / 3;
        var triangles = new Array(numTris);
        for (var i = 0; i < numTris; ++i) {
            triangles[i] = i;
        }
        return buildNode(triangles, indices, positions, 0);
    };

    var dimLength = new Float32Array();

    function buildNode(triangles, indices, positions, depth) {

        var aabb = new Float32Array(6);

        var node = {
            triangles: null,
            left: null,
            right: null,
            leaf: false,
            splitDim: 0,
            aabb: aabb
        };

        aabb[0] = aabb[1] = aabb[2] = Number.POSITIVE_INFINITY;
        aabb[3] = aabb[4] = aabb[5] = Number.NEGATIVE_INFINITY;

        var t, i, len;

        for (t = 0, len = triangles.length; t < len; ++t) {
            var ii = triangles[t] * 3;
            for (var j = 0; j < 3; ++j) {
                var pi = indices[ii + j] * 3;
                if (positions[pi] < aabb[0]) {
                    aabb[0] = positions[pi]
                }
                if (positions[pi] > aabb[3]) {
                    aabb[3] = positions[pi]
                }
                if (positions[pi + 1] < aabb[1]) {
                    aabb[1] = positions[pi + 1]
                }
                if (positions[pi + 1] > aabb[4]) {
                    aabb[4] = positions[pi + 1]
                }
                if (positions[pi + 2] < aabb[2]) {
                    aabb[2] = positions[pi + 2]
                }
                if (positions[pi + 2] > aabb[5]) {
                    aabb[5] = positions[pi + 2]
                }
            }
        }

        if (triangles.length < KD_TREE_MIN_TRIANGLES || depth > KD_TREE_MAX_DEPTH) {
            node.triangles = triangles;
            node.leaf = true;
            return node;
        }

        dimLength[0] = aabb[3] - aabb[0];
        dimLength[1] = aabb[4] - aabb[1];
        dimLength[2] = aabb[5] - aabb[2];

        var dim = 0;

        if (dimLength[1] > dimLength[dim]) {
            dim = 1;
        }

        if (dimLength[2] > dimLength[dim]) {
            dim = 2;
        }

        node.splitDim = dim;

        var mid = (aabb[dim] + aabb[dim + 3]) / 2;
        var left = new Array(triangles.length);
        var numLeft = 0;
        var right = new Array(triangles.length);
        var numRight = 0;

        for (t = 0, len = triangles.length; t < len; ++t) {

            var ii = triangles[t] * 3;
            var i0 = indices[ii];
            var i1 = indices[ii + 1];
            var i2 = indices[ii + 2];

            var pi0 = i0 * 3;
            var pi1 = i1 * 3;
            var pi2 = i2 * 3;

            if (positions[pi0 + dim] <= mid || positions[pi1 + dim] <= mid || positions[pi2 + dim] <= mid) {
                left[numLeft++] = triangles[t];
            } else {
                right[numRight++] = triangles[t];
            }
        }

        left.length = numLeft;
        right.length = numRight;

        node.left = buildNode(left, indices, positions, depth + 1);
        node.right = buildNode(right, indices, positions, depth + 1);

        return node;
    }

})();;/**
 * @author xeolabs / https://github.com/xeolabs
 */

xeogl.renderer = xeogl.renderer || {};

xeogl.renderer.Renderer = function (stats, canvas, gl, options) {

    "use strict";

    var self = this;

    options = options || {};
    stats = stats || {};

    var ids = new xeogl.utils.Map({});
    var frame = new xeogl.renderer.Frame();

    this.gammaOutput = true; // Set true to format output as premultiplied gamma

    this.viewport = null;
    this.lights = null;
    this.viewTransform = null;
    this.projTransform = null;
    this.clips = null;

    this.indicesBufs = [];

    var objects = {};
    var shadowLightObjects = {};
    var canvasTransparent = options.transparent === true;
    var ambient = null; // The current ambient light, if available
    var ambientColor = xeogl.math.vec4([0, 0, 0, 1]);
    var objectList = [];
    var objectListLen = 0;
    var objectPickList = [];
    var objectPickListLen = 0;
    var shadowObjectLists = {};

    var objectListDirty = true;
    var stateSortDirty = true;
    var imageDirty = true;
    var shadowsDirty = true;
    this.imageForceDirty = true;

    var blendOneMinusSrcAlpha = true;

    var pickBuf = null;
    var readPixelBuf = null;

    var bindOutputFrameBuffer = null;
    var unbindOutputFrameBuffer = null;

    this.needStateSort = function () {
        stateSortDirty = true;
    };

    this.shadowsDirty = function () {
        shadowsDirty = true;
    };

    this.imageDirty = function () {
        imageDirty = true;
    };

    this.setImageForceDirty = function () {
        this.imageForceDirty = true;
    };

    this.getAmbientColor = function () {
        return ambientColor;
    };

    this.setBlendOneMinusSrcAlpha = function (value) {
        blendOneMinusSrcAlpha = value;
    };

    this.webglRestored = function (gl) {
        // gl = gl;
        // this._programFactory.webglRestored(gl);
        // this._chunkFactory.webglRestored();
        // if (pickBuf) {
        //     pickBuf.webglRestored(gl);
        // }
        // imageDirty = true;
    };

    this.createObject = function (entityId, material, ghostMaterial, outlineMaterial, highlightMaterial, selectedMaterial, vertexBufs, geometry, modelTransform, modes) {
        var objectId = ids.addItem({});
        var object = new xeogl.renderer.Object(objectId, entityId, gl, self, material, ghostMaterial, outlineMaterial, highlightMaterial, selectedMaterial, vertexBufs, geometry, modelTransform, modes);
        if (object.errors) {
            object.destroy();
            ids.removeItem(objectId);
            return {
                errors: object.errors
            };
        }
        objects[objectId] = object;
        objectListDirty = true;
        stateSortDirty = true;
        setAmbientLights(this.lights); // TODO: Is self the best place for self?
        return {
            objectId: objectId
        };
    };

    function setAmbientLights(state) {
        var lights = state.lights;
        var light;
        for (var i = 0, len = lights.length; i < len; i++) {
            light = lights[i];
            if (light.type === "ambient") {
                ambient = light;
            }
        }
    }

    this.destroyObject = function (objectId) {
        var object = objects[objectId];
        if (!object) {
            return;
        }
        object.destroy();
        delete objects[objectId];
        ids.removeItem(objectId);
        objectListDirty = true;
    };

    this.clear = function (params) {

        params = params || {};

        if (self.viewport) {
            var boundary = self.viewport.boundary;
            gl.viewport(boundary[0], boundary[1], boundary[2], boundary[3]);
        } else {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        }

        if (canvasTransparent) { // Canvas is transparent
            gl.clearColor(0, 0, 0, 0);
        } else {
            var color = params.ambientColor || ambientColor;
            gl.clearColor(color[0], color[1], color[2], 1.0);
        }

        if (bindOutputFrameBuffer) {
            bindOutputFrameBuffer(params.pass);
        }

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

        if (unbindOutputFrameBuffer) {
            unbindOutputFrameBuffer(params.pass);
        }
    };

    //this._renderer.render({pass: pass, clear: clear, force: forceRender});
    this.render = function (params) {
        params = params || {};

        update();

        if (imageDirty || this.imageForceDirty || params.force) {

            // In case context lost/recovered

            if (xeogl.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"]) {
                gl.getExtension("OES_element_index_uint");
            }

            if (xeogl.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_standard_derivatives"]) { // For normal mapping w/o precomputed tangents
                gl.getExtension("OES_standard_derivatives");
            }

            drawObjects(params);

            stats.frame.frameCount++;
            imageDirty = false;
            this.imageForceDirty = false;
        }
    };

    function update() {
        if (objectListDirty) {
            buildObjectList();
            objectListDirty = false;
            stateSortDirty = true;
        }
        if (stateSortDirty) {
            stateSort();
            stateSortDirty = false;
            imageDirty = true;
        }
        //  if (shadowsDirty) {
        drawShadowMaps();
        // shadowsDirty = false;
        // }
    }

    function buildObjectList() {
        objectListLen = 0;
        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                objectList[objectListLen++] = objects[objectId];
            }
        }
        for (var i = objectListLen, len = objectList.length; i < len; i++) {
            objectList[i] = null; // Release memory
        }
        objectList.length = objectListLen;
    }

    function stateSort() {
        objectList.length = objectListLen;
        objectList.sort(xeogl.renderer.Object.compareState);
    }

    function drawShadowMaps() {
        var lights = self.lights.lights;
        var light;
        var i;
        var len;
        for (i = 0, len = lights.length; i < len; i++) {
            light = lights[i];
            if (!light.shadow) {
                continue;
            }
            drawShadowMap(light);
        }
    }

    function drawShadowMap(light) {

        var shadow = light.shadow;

        if (!shadow) {
            return;
        }

        var renderBuf = light.getShadowRenderBuf();

        if (!renderBuf) {
            return;
        }

        renderBuf.bind();

        frame.reset();
        frame.backfaces = true;
        frame.frontface = true;
        frame.drawElements = 0;
        frame.useProgram = -1;
        frame.shadowViewMatrix = light.getShadowViewMatrix();
        frame.shadowProjMatrix = light.getShadowProjMatrix();

        if (self.viewport) {
            var boundary = self.viewport.boundary;
            gl.viewport(boundary[0], boundary[1], boundary[2], boundary[3]);
        } else {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        }

        gl.clearColor(0, 0, 0, 1);
        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        var i;
        var object;

        for (i = 0; i < objectListLen; i++) {
            object = objectList[i];
            if (!object.modes.visible || !object.modes.castShadow) {
                continue; // For now, culled objects still cast shadows because they are just out of view
            }
            if (object.material.alpha === 0) {
                continue;
            }
            object.drawShadow(frame, light);
        }

        renderBuf.unbind();
    }

    var drawObjects = (function () {

        var opaqueGhostFillObjects = [];
        var opaqueGhostVerticesObjects = [];
        var opaqueGhostEdgesObjects = [];
        var transparentGhostFillObjects = [];
        var transparentGhostVerticesObjects = [];
        var transparentGhostEdgesObjects = [];

        var opaqueHighlightFillObjects = [];
        var opaqueHighlightVerticesObjects = [];
        var opaqueHighlightEdgesObjects = [];
        var transparentHighlightFillObjects = [];
        var transparentHighlightVerticesObjects = [];
        var transparentHighlightEdgesObjects = [];

        var opaqueSelectedFillObjects = [];
        var opaqueSelectedVerticesObjects = [];
        var opaqueSelectedEdgesObjects = [];
        var transparentSelectedFillObjects = [];
        var transparentSelectedVerticesObjects = [];
        var transparentSelectedEdgesObjects = [];

        var outlinedObjects = [];
        var highlightObjects = [];
        var selectedObjects = [];
        var transparentObjects = [];
        var numTransparentObjects = 0;

        return function (params) {

            if (ambient) {
                var color = ambient.color;
                var intensity = ambient.intensity;
                ambientColor[0] = color[0] * intensity;
                ambientColor[1] = color[1] * intensity;
                ambientColor[2] = color[2] * intensity;
            } else {
                ambientColor[0] = 0;
                ambientColor[1] = 0;
                ambientColor[2] = 0;
            }

            frame.reset();
            frame.pass = params.pass;

            if (self.viewport) {
                var boundary = self.viewport.boundary;
                gl.viewport(boundary[0], boundary[1], boundary[2], boundary[3]);
            } else {
                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            }

            if (canvasTransparent) { // Canvas is transparent
                gl.clearColor(0, 0, 0, 0);
            } else {
                gl.clearColor(ambientColor[0], ambientColor[1], ambientColor[2], 1.0);
            }

            gl.enable(gl.DEPTH_TEST);
            gl.frontFace(gl.CCW);
            gl.enable(gl.CULL_FACE);
            gl.depthMask(true);

            var i;
            var len;
            var object;
            var modes;
            var material;
            var transparent;

            var startTime = Date.now();

            if (bindOutputFrameBuffer) {
                bindOutputFrameBuffer(params.pass);
            }

            if (params.clear !== false) {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            }

            var numOpaqueGhostFillObjects = 0;
            var numOpaqueGhostVerticesObjects = 0;
            var numOpaqueGhostEdgesObjects = 0;
            var numTransparentGhostFillObjects = 0;
            var numTransparentGhostVerticesObjects = 0;
            var numTransparentGhostEdgesObjects = 0;
            var numOutlinedObjects = 0;
            var numHighlightObjects = 0;
            var numSelectedObjects = 0;

            var numOpaqueHighlightFillObjects = 0;
            var numOpaqueHighlightVerticesObjects = 0;
            var numOpaqueHighlightEdgesObjects = 0;
            var numTransparentHighlightFillObjects = 0;
            var numTransparentHighlightVerticesObjects = 0;
            var numTransparentHighlightEdgesObjects = 0;

            var numOpaqueSelectedFillObjects = 0;
            var numOpaqueSelectedVerticesObjects = 0;
            var numOpaqueSelectedEdgesObjects = 0;
            var numTransparentSelectedFillObjects = 0;
            var numTransparentSelectedVerticesObjects = 0;
            var numTransparentSelectedEdgesObjects = 0;

            numTransparentObjects = 0;

            // Build draw lists

            for (i = 0, len = objectListLen; i < len; i++) {

                object = objectList[i];
                modes = object.modes;
                material = object.material;

                if (modes.culled === true || modes.visible === false) {
                    continue;
                }

                if (material.alpha === 0) {
                    continue;
                }

                if (modes.ghosted) {
                    var ghostMaterial = object.ghostMaterial;
                    if (ghostMaterial.edges) {
                        if (ghostMaterial.edgeAlpha < 1.0) {
                            transparentGhostEdgesObjects[numTransparentGhostEdgesObjects++] = object;
                        } else {
                            opaqueGhostEdgesObjects[numOpaqueGhostEdgesObjects++] = object;
                        }
                    }
                    if (ghostMaterial.vertices) {
                        if (ghostMaterial.vertexAlpha < 1.0) {
                            transparentGhostVerticesObjects[numTransparentGhostVerticesObjects++] = object;
                        } else {
                            opaqueGhostVerticesObjects[numOpaqueGhostVerticesObjects++] = object;
                        }
                    }
                    if (ghostMaterial.fill) {
                        if (ghostMaterial.fillAlpha < 1.0) {
                            transparentGhostFillObjects[numTransparentGhostFillObjects++] = object;
                        } else {
                            opaqueGhostFillObjects[numOpaqueGhostFillObjects++] = object;
                        }
                    }
                } else {

                    // Normal render

                    transparent = object.material.alphaMode === 2 /* blend */ || modes.xray || modes.colorize[3] < 1;
                    if (transparent) {
                        transparentObjects[numTransparentObjects++] = object;
                    } else {
                        if (modes.outlined) {
                            outlinedObjects[numOutlinedObjects++] = object;
                        } else {
                            object.draw(frame);
                        }
                    }
                }

                if (modes.selected) {
                    var selectedMaterial = object.selectedMaterial;
                    if (selectedMaterial.edges) {
                        if (selectedMaterial.edgeAlpha < 1.0) {
                            transparentSelectedEdgesObjects[numTransparentSelectedEdgesObjects++] = object;
                        } else {
                            opaqueSelectedEdgesObjects[numOpaqueSelectedEdgesObjects++] = object;
                        }
                    }
                    if (selectedMaterial.vertices) {
                        if (selectedMaterial.vertexAlpha < 1.0) {
                            transparentSelectedVerticesObjects[numTransparentSelectedVerticesObjects++] = object;
                        } else {
                            opaqueSelectedVerticesObjects[numOpaqueSelectedVerticesObjects++] = object;
                        }
                    }
                    if (selectedMaterial.fill) {
                        if (selectedMaterial.fillAlpha < 1.0) {
                            transparentSelectedFillObjects[numTransparentSelectedFillObjects++] = object;
                        } else {
                            opaqueSelectedFillObjects[numOpaqueSelectedFillObjects++] = object;
                        }
                    }
                    if (modes.selected) {
                        selectedObjects[numSelectedObjects++] = object;
                    }
                }

                if (modes.highlighted) {
                    var highlightMaterial = object.highlightMaterial;
                    if (highlightMaterial.edges) {
                        if (highlightMaterial.edgeAlpha < 1.0) {
                            transparentHighlightEdgesObjects[numTransparentHighlightEdgesObjects++] = object;
                        } else {
                            opaqueHighlightEdgesObjects[numOpaqueHighlightEdgesObjects++] = object;
                        }
                    }
                    if (highlightMaterial.vertices) {
                        if (highlightMaterial.vertexAlpha < 1.0) {
                            transparentHighlightVerticesObjects[numTransparentHighlightVerticesObjects++] = object;
                        } else {
                            opaqueHighlightVerticesObjects[numOpaqueHighlightVerticesObjects++] = object;
                        }
                    }
                    if (highlightMaterial.fill) {
                        if (highlightMaterial.fillAlpha < 1.0) {
                            transparentHighlightFillObjects[numTransparentHighlightFillObjects++] = object;
                        } else {
                            opaqueHighlightFillObjects[numOpaqueHighlightFillObjects++] = object;
                        }
                    }
                    if (modes.highlighted) {
                        highlightObjects[numHighlightObjects++] = object;
                    }
                }
            }

            // Render opaque outlined objects

            if (numOutlinedObjects > 0) {

                // Render objects

                gl.enable(gl.STENCIL_TEST);
                gl.stencilFunc(gl.ALWAYS, 1, 1);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
                gl.stencilMask(1);
                gl.clearStencil(0);
                gl.clear(gl.STENCIL_BUFFER_BIT);

                for (i = 0; i < numOutlinedObjects; i++) {
                    outlinedObjects[i].draw(frame);
                }

                // Render outlines

                gl.stencilFunc(gl.EQUAL, 0, 1);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                gl.stencilMask(0x00);
                gl.disable(gl.CULL_FACE); // Need both faces for better corners with face-aligned normals

                for (i = 0; i < numOutlinedObjects; i++) {
                    outlinedObjects[i].drawOutline(frame);
                }

                gl.disable(gl.STENCIL_TEST);
            }

            // Render opaque ghosted objects

            if (numOpaqueGhostFillObjects > 0) {
                for (i = 0; i < numOpaqueGhostFillObjects; i++) {
                    opaqueGhostFillObjects[i].drawGhostFill(frame);
                }
            }

            if (numOpaqueGhostEdgesObjects > 0) {
                for (i = 0; i < numOpaqueGhostEdgesObjects; i++) {
                    opaqueGhostEdgesObjects[i].drawGhostEdges(frame);
                }
            }

            if (numOpaqueGhostVerticesObjects > 0) {
                for (i = 0; i < numOpaqueGhostVerticesObjects; i++) {
                    opaqueGhostVerticesObjects[i].drawGhostVertices(frame);
                }
            }

            var transparentDepthMask = true;

            if (numTransparentGhostFillObjects > 0 || numTransparentGhostEdgesObjects > 0 || numTransparentGhostVerticesObjects > 0 || numTransparentObjects > 0) {

                // Draw transparent objects

                gl.enable(gl.CULL_FACE);
                gl.enable(gl.BLEND);

                if (blendOneMinusSrcAlpha) {

                    // Makes glTF windows appear correct

                    // Without premultiplied alpha:
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                    // Premultiplied alpha:
                    //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                } else {

                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                }

                frame.backfaces = false;

                if (!transparentDepthMask) {
                    gl.depthMask(false);
                }

                // Render transparent ghosted objects

                if (numTransparentGhostVerticesObjects > 0) {
                    for (i = 0; i < numTransparentGhostVerticesObjects; i++) {
                        transparentGhostVerticesObjects[i].drawGhostVertices(frame);
                    }
                }

                if (numTransparentGhostEdgesObjects > 0) {
                    for (i = 0; i < numTransparentGhostEdgesObjects; i++) {
                        transparentGhostEdgesObjects[i].drawGhostEdges(frame);
                    }
                }

                if (numTransparentGhostFillObjects > 0) {
                    for (i = 0; i < numTransparentGhostFillObjects; i++) {
                        transparentGhostFillObjects[i].drawGhostFill(frame);
                    }
                }

                numOutlinedObjects = 0;

                for (i = 0; i < numTransparentObjects; i++) {
                    object = transparentObjects[i];
                    if (object.modes.outlined) {
                        outlinedObjects[numOutlinedObjects++] = object; // Build outlined list
                        continue;
                    }

                    object.draw(frame);
                }

                // Transparent outlined objects are not supported yet

                gl.disable(gl.BLEND);
            }

            // Highlighting

            if (numOpaqueHighlightFillObjects > 0 || numOpaqueHighlightEdgesObjects > 0 || numOpaqueHighlightVerticesObjects > 0) {

                // Render opaque highlighted objects

                frame.lastProgramId = null;
                gl.clear(gl.DEPTH_BUFFER_BIT);

                if (numOpaqueHighlightVerticesObjects > 0) {
                    for (i = 0; i < numOpaqueHighlightVerticesObjects; i++) {
                        opaqueHighlightVerticesObjects[i].drawHighlightVertices(frame);
                    }
                }

                if (numOpaqueHighlightEdgesObjects > 0) {
                    for (i = 0; i < numOpaqueHighlightEdgesObjects; i++) {
                        opaqueHighlightEdgesObjects[i].drawHighlightEdges(frame);
                    }
                }

                if (numOpaqueHighlightFillObjects > 0) {
                    for (i = 0; i < numOpaqueHighlightFillObjects; i++) {
                        opaqueHighlightFillObjects[i].drawHighlightFill(frame);
                    }
                }
            }

            if (numTransparentHighlightFillObjects > 0 || numTransparentHighlightEdgesObjects > 0 || numTransparentHighlightVerticesObjects > 0) {

                // Render transparent highlighted objects

                frame.lastProgramId = null;

                gl.clear(gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                //          gl.disable(gl.DEPTH_TEST);

                if (numTransparentHighlightVerticesObjects > 0) {
                    for (i = 0; i < numTransparentHighlightVerticesObjects; i++) {
                        transparentHighlightVerticesObjects[i].drawHighlightVertices(frame);
                    }
                }

                if (numTransparentHighlightEdgesObjects > 0) {
                    for (i = 0; i < numTransparentHighlightEdgesObjects; i++) {
                        transparentHighlightEdgesObjects[i].drawHighlightEdges(frame);
                    }
                }

                if (numTransparentHighlightFillObjects > 0) {
                    for (i = 0; i < numTransparentHighlightFillObjects; i++) {
                        transparentHighlightFillObjects[i].drawHighlightFill(frame);
                    }
                }

                gl.disable(gl.BLEND);
                //        gl.enable(gl.DEPTH_TEST);
            }

            // Selection

            if (numOpaqueSelectedFillObjects > 0 || numOpaqueSelectedEdgesObjects > 0 || numOpaqueSelectedVerticesObjects > 0) {

                // Render opaque selected objects

                frame.lastProgramId = null;
                gl.clear(gl.DEPTH_BUFFER_BIT);

                if (numOpaqueSelectedVerticesObjects > 0) {
                    for (i = 0; i < numOpaqueSelectedVerticesObjects; i++) {
                        opaqueSelectedVerticesObjects[i].drawSelectedVertices(frame);
                    }
                }

                if (numOpaqueSelectedEdgesObjects > 0) {
                    for (i = 0; i < numOpaqueSelectedEdgesObjects; i++) {
                        opaqueSelectedEdgesObjects[i].drawSelectedEdges(frame);
                    }
                }

                if (numOpaqueSelectedFillObjects > 0) {
                    for (i = 0; i < numOpaqueSelectedFillObjects; i++) {
                        opaqueSelectedFillObjects[i].drawSelectedFill(frame);
                    }
                }
            }

            if (numTransparentSelectedFillObjects > 0 || numTransparentSelectedEdgesObjects > 0 || numTransparentSelectedVerticesObjects > 0) {

                // Render transparent selected objects

                frame.lastProgramId = null;

                gl.clear(gl.DEPTH_BUFFER_BIT);
                gl.enable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                //          gl.disable(gl.DEPTH_TEST);

                if (numTransparentSelectedVerticesObjects > 0) {
                    for (i = 0; i < numTransparentSelectedVerticesObjects; i++) {
                        transparentSelectedVerticesObjects[i].drawSelectedVertices(frame);
                    }
                }

                if (numTransparentSelectedEdgesObjects > 0) {
                    for (i = 0; i < numTransparentSelectedEdgesObjects; i++) {
                        transparentSelectedEdgesObjects[i].drawSelectedEdges(frame);
                    }
                }

                if (numTransparentSelectedFillObjects > 0) {
                    for (i = 0; i < numTransparentSelectedFillObjects; i++) {
                        transparentSelectedFillObjects[i].drawSelectedFill(frame);
                    }
                }

                gl.disable(gl.BLEND);
                //        gl.enable(gl.DEPTH_TEST);
            }

            var endTime = Date.now();
            var frameStats = stats.frame;

            frameStats.renderTime = (endTime - startTime) / 1000.0;
            frameStats.drawElements = frame.drawElements;
            frameStats.drawElements = frame.drawElements;
            frameStats.useProgram = frame.useProgram;
            frameStats.bindTexture = frame.bindTexture;
            frameStats.bindArray = frame.bindArray;

            var numTextureUnits = xeogl.WEBGL_INFO.MAX_TEXTURE_UNITS;
            for (var ii = 0; ii < numTextureUnits; ii++) {
                gl.activeTexture(gl.TEXTURE0 + ii);
            }
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            gl.bindTexture(gl.TEXTURE_2D, null);

            // Set the backbuffer's alpha to 1.0
            // gl.clearColor(1, 1, 1, 1);
            // gl.colorMask(false, false, false, true);
            // gl.clear(gl.COLOR_BUFFER_BIT);
            // gl.colorMask(true, true, true, true);

            if (unbindOutputFrameBuffer) {
                unbindOutputFrameBuffer(params.pass);
            }
        };
    })();

    this.pick = (function () {

        var math = xeogl.math;
        var tempVec3a = math.vec3();
        var tempMat4a = math.mat4();
        var up = math.vec3([0, 1, 0]);
        var pickFrustumMatrix = math.frustumMat4(-1, 1, -1, 1, 0.1, 10000);

        return function (params) {

            update();

            if (xeogl.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"]) { // In case context lost/recovered
                gl.getExtension("OES_element_index_uint");
            }

            var canvasX;
            var canvasY;
            var origin;
            var direction;
            var look;
            var pickViewMatrix = null;
            var pickProjMatrix = null;

            if (params.canvasPos) {

                canvasX = params.canvasPos[0];
                canvasY = params.canvasPos[1];

            } else {

                // Picking with arbitrary World-space ray
                // Align camera along ray and fire ray through center of canvas

                origin = params.origin || math.vec3([0, 0, 0]);
                direction = params.direction || math.vec3([0, 0, 1]);
                look = math.addVec3(origin, direction, tempVec3a);

                pickViewMatrix = math.lookAtMat4v(origin, look, up, tempMat4a);
                pickProjMatrix = pickFrustumMatrix;

                canvasX = canvas.clientWidth * 0.5;
                canvasY = canvas.clientHeight * 0.5;
            }

            pickBuf = pickBuf || new xeogl.renderer.RenderBuffer(canvas, gl);
            pickBuf.bind();

            var object = pickObject(canvasX, canvasY, pickViewMatrix, pickProjMatrix, params);

            if (!object) {
                pickBuf.unbind();
                return null;
            }

            var hit = {
                entity: object.entityId
            };

            if (params.pickSurface) {
                hit.primIndex = pickTriangle(object, canvasX, canvasY, pickViewMatrix, pickProjMatrix);
            }

            if (pickViewMatrix) {
                hit.origin = origin;
                hit.direction = direction;
            }

            pickBuf.unbind();

            return hit;
        };
    })();

    function pickObject(canvasX, canvasY, pickViewMatrix, pickProjMatrix, params) {

        frame.reset();
        frame.backfaces = true;
        frame.pickViewMatrix = pickViewMatrix;
        frame.pickProjMatrix = pickProjMatrix;
        frame.pickObjectIndex = 1;

        if (self.viewport) {
            var boundary = self.viewport.boundary;
            gl.viewport(boundary[0], boundary[1], boundary[2], boundary[3]);
        } else {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        }

        gl.clearColor(0, 0, 0, 0);
        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.BLEND);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        objectPickListLen = 0;

        var i;
        var len;
        var object;
        var includeObjects = params.includeObjects;
        var excludeObjects = params.excludeObjects;

        for (i = 0, len = objectListLen; i < len; i++) {
            object = objectList[i];
            if (object.modes.culled === true || object.modes.visible === false || object.modes.pickable === false) {
                continue;
            }
            if (includeObjects && !includeObjects[object.id]) {
                continue;
            }
            if (excludeObjects && excludeObjects[object.id]) {
                continue;
            }
            objectPickList[objectPickListLen++] = object;
            object.pickObject(frame);
        }

        var pix = pickBuf.read(canvasX, canvasY);
        var pickedObjectIndex = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);

        pickedObjectIndex--;

        //pickedObjectIndex = (pickedObjectIndex >= 1) ? pickedObjectIndex - 1 : -1;

        return pickedObjectIndex >= 0 ? objectPickList[pickedObjectIndex] : null;
    }

    function pickTriangle(object, canvasX, canvasY, pickViewMatrix, pickProjMatrix) {

        frame.reset();
        frame.backfaces = true;
        frame.frontface = true; // "ccw" 
        frame.pickViewMatrix = pickViewMatrix; // Can be null
        frame.pickProjMatrix = pickProjMatrix; // Can be null

        if (self.viewport) {
            var boundary = self.viewport.boundary;
            gl.viewport(boundary[0], boundary[1], boundary[2], boundary[3]);
        } else {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        }

        gl.clearColor(0, 0, 0, 0);
        gl.enable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.disable(gl.BLEND);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        object.pickTriangle(frame);

        var pix = pickBuf.read(canvasX, canvasY);

        var primIndex = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);

        primIndex *= 3; // Convert from triangle number to first vertex in indices

        return primIndex;
    }

    this.readPixels = function (pixels, colors, len, opaqueOnly) {

        readPixelBuf = readPixelBuf || (readPixelBuf = new xeogl.renderer.RenderBuffer(canvas, gl));
        readPixelBuf.bind();
        readPixelBuf.clear();

        this.render({force: true, opaqueOnly: opaqueOnly});

        var color;
        var i;
        var j;
        var k;
        for (i = 0; i < len; i++) {
            j = i * 2;
            k = i * 4;
            color = readPixelBuf.read(pixels[j], pixels[j + 1]);
            colors[k] = color[0];
            colors[k + 1] = color[1];
            colors[k + 2] = color[2];
            colors[k + 3] = color[3];
        }

        readPixelBuf.unbind();

        imageDirty = true;
    };

    this.destroy = function () {
        if (pickBuf) {
            pickBuf.destroy();
        }
        if (readPixelBuf) {
            readPixelBuf.destroy();
        }
    };
};
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

xeogl.renderer.webgl = {
    enums: {
        funcAdd: "FUNC_ADD",
        funcSubtract: "FUNC_SUBTRACT",
        funcReverseSubtract: "FUNC_REVERSE_SUBTRACT",
        zero: "ZERO",
        one: "ONE",
        srcColor: "SRC_COLOR",
        oneMinusSrcColor: "ONE_MINUS_SRC_COLOR",
        dstColor: "DST_COLOR",
        oneMinusDstColor: "ONE_MINUS_DST_COLOR",
        srcAlpha: "SRC_ALPHA",
        oneMinusSrcAlpha: "ONE_MINUS_SRC_ALPHA",
        dstAlpha: "DST_ALPHA",
        oneMinusDstAlpha: "ONE_MINUS_DST_ALPHA",
        contantColor: "CONSTANT_COLOR",
        oneMinusConstantColor: "ONE_MINUS_CONSTANT_COLOR",
        constantAlpha: "CONSTANT_ALPHA",
        oneMinusConstantAlpha: "ONE_MINUS_CONSTANT_ALPHA",
        srcAlphaSaturate: "SRC_ALPHA_SATURATE",
        front: "FRONT",
        back: "BACK",
        frontAndBack: "FRONT_AND_BACK",
        never: "NEVER",
        less: "LESS",
        equal: "EQUAL",
        lequal: "LEQUAL",
        greater: "GREATER",
        notequal: "NOTEQUAL",
        gequal: "GEQUAL",
        always: "ALWAYS",
        cw: "CW",
        ccw: "CCW",
        linear: "LINEAR",
        nearest: "NEAREST",
        linearMipmapNearest: "LINEAR_MIPMAP_NEAREST",
        nearestMipmapNearest: "NEAREST_MIPMAP_NEAREST",
        nearestMipmapLinear: "NEAREST_MIPMAP_LINEAR",
        linearMipmapLinear: "LINEAR_MIPMAP_LINEAR",
        repeat: "REPEAT",
        clampToEdge: "CLAMP_TO_EDGE",
        mirroredRepeat: "MIRRORED_REPEAT",
        alpha: "ALPHA",
        rgb: "RGB",
        rgba: "RGBA",
        luminance: "LUMINANCE",
        luminanceAlpha: "LUMINANCE_ALPHA",
        textureBinding2D: "TEXTURE_BINDING_2D",
        textureBindingCubeMap: "TEXTURE_BINDING_CUBE_MAP",
        compareRToTexture: "COMPARE_R_TO_TEXTURE", // Hardware Shadowing Z-depth,
        unsignedByte: "UNSIGNED_BYTE"
    }
};
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

xeogl.renderer.Object = function (id, entityId, gl, scene, material, ghostMaterial, outlineMaterial, highlightMaterial, selectedMaterial, vertexBufs, geometry, modelTransform, modes) {

    this.id = id;
    this.entityId = entityId;
    this.gl = gl;
    this.scene = scene;

    this.material = material;
    this.ghostMaterial = ghostMaterial;
    this.outlineMaterial = outlineMaterial;
    this.highlightMaterial = highlightMaterial;
    this.selectedMaterial = selectedMaterial;
    this.vertexBufs = vertexBufs;
    this.geometry = geometry;
    this.modelTransform = modelTransform;
    this.modes = modes;

    this.scene = scene;
    this.gl = gl;

    this._draw = null;
    this._ghostFill = null;
    this._ghostEdges = null;
    this._ghostVertices = null;
    this._shadow = null;
    this._outline = null;
    this._pickObject = null;
    this._pickTriangle = null;
    this._pickVertex = null;

    this._draw = xeogl.renderer.DrawRenderer.create(this.gl, [this.gl.canvas.id, (this.scene.gammaOutput ? "gam" : ""), this.scene.lights.hash,
        this.scene.clips.hash, this.geometry.hash, this.material.hash, this.modes.hash].join(";"), this.scene, this);
    if (this._draw.errors) {
        this.errors = (this.errors || []).concat(this._draw.errors);
        console.error(this._draw.errors.join("\n"));
    }
};

xeogl.renderer.Object.compareState = function (a, b) {
    return (a.modes.layer - b.modes.layer)
        || (a._draw.id - b._draw.id)
        || (a.material.id - b.material.id)  // TODO: verify which of material and vertexBufs should be highest order
        || (a.vertexBufs.id - b.vertexBufs.id)
        || (a.geometry.id - b.geometry.id);
};

xeogl.renderer.Object.prototype._getSceneHash = function () {
    return (this.scene.gammaInput ? "gi;" : ";") + (this.scene.gammaOutput ? "go" : "");
};

xeogl.renderer.Object.prototype.draw = function (frame) {
    if (!this._draw) {
        this._draw = xeogl.renderer.DrawRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.lights.hash, this.scene.clips.hash, this.geometry.hash, this.material.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._draw.errors) {
            this.errors = (this.errors || []).concat(this._draw.errors);
            console.error(this._draw.errors.join("\n"));
            return;
        }
    }
    this._draw.drawObject(frame, this);
};

xeogl.renderer.Object.prototype.drawGhostFill = function (frame) {
    if (!this._ghostFill) {
        this._ghostFill = xeogl.renderer.GhostFillRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._ghostFill.errors) {
            this.errors = (this.errors || []).concat(this._ghostFill.errors);
            console.error(this._ghostFill.errors.join("\n"));
            return;
        }
    }
    this._ghostFill.drawObject(frame, this, 0); // 0 == ghost
};

xeogl.renderer.Object.prototype.drawGhostEdges = function (frame) {
    if (!this._ghostEdges) {
        this._ghostEdges = xeogl.renderer.GhostEdgesRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._ghostEdges.errors) {
            this.errors = (this.errors || []).concat(this._ghostEdges.errors);
            console.error(this._ghostEdges.errors.join("\n"));
            return;
        }
    }
    this._ghostEdges.drawObject(frame, this, 0); // 0 == ghost
};

xeogl.renderer.Object.prototype.drawGhostVertices = function (frame) {
    if (!this._ghostVertices) {
        this._ghostVertices = xeogl.renderer.GhostVerticesRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._ghostVertices.errors) {
            this.errors = (this.errors || []).concat(this._ghostVertices.errors);
            console.error(this._ghostVertices.errors.join("\n"));
            return;
        }
    }
    this._ghostVertices.drawObject(frame, this, 0); // 0 == ghost
};

xeogl.renderer.Object.prototype.drawHighlightFill = function (frame) {
    if (!this._ghostFill) {
        this._ghostFill = xeogl.renderer.GhostFillRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._ghostFill.errors) {
            this.errors = (this.errors || []).concat(this._ghostFill.errors);
            console.error(this._ghostFill.errors.join("\n"));
            return;
        }
    }
    this._ghostFill.drawObject(frame, this, 1); // 1 == highlight
};

xeogl.renderer.Object.prototype.drawHighlightEdges = function (frame) {
    if (!this._ghostEdges) {
        this._ghostEdges = xeogl.renderer.GhostEdgesRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._ghostEdges.errors) {
            this.errors = (this.errors || []).concat(this._ghostEdges.errors);
            console.error(this._ghostEdges.errors.join("\n"));
            return;
        }
    }
    this._ghostEdges.drawObject(frame, this, 1); // 1 == highlight
};

xeogl.renderer.Object.prototype.drawHighlightVertices = function (frame) {
    if (!this._ghostVertices) {
        this._ghostVertices = xeogl.renderer.GhostVerticesRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._ghostVertices.errors) {
            this.errors = (this.errors || []).concat(this._ghostVertices.errors);
            console.error(this._ghostVertices.errors.join("\n"));
            return;
        }
    }
    this._ghostVertices.drawObject(frame, this, 1); // 1 == highlight
};

xeogl.renderer.Object.prototype.drawSelectedFill = function (frame) {
    if (!this._ghostFill) {
        this._ghostFill = xeogl.renderer.GhostFillRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._ghostFill.errors) {
            this.errors = (this.errors || []).concat(this._ghostFill.errors);
            console.error(this._ghostFill.errors.join("\n"));
            return;
        }
    }
    this._ghostFill.drawObject(frame, this, 2); // 2 == selected
};

xeogl.renderer.Object.prototype.drawSelectedEdges = function (frame) {
    if (!this._ghostEdges) {
        this._ghostEdges = xeogl.renderer.GhostEdgesRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._ghostEdges.errors) {
            this.errors = (this.errors || []).concat(this._ghostEdges.errors);
            console.error(this._ghostEdges.errors.join("\n"));
            return;
        }
    }
    this._ghostEdges.drawObject(frame, this, 2); // 2 == selected
};

xeogl.renderer.Object.prototype.drawSelectedVertices = function (frame) {
    if (!this._ghostVertices) {
        this._ghostVertices = xeogl.renderer.GhostVerticesRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._ghostVertices.errors) {
            this.errors = (this.errors || []).concat(this._ghostVertices.errors);
            console.error(this._ghostVertices.errors.join("\n"));
            return;
        }
    }
    this._ghostVertices.drawObject(frame, this, 2); // 2 == selected
};

xeogl.renderer.Object.prototype.drawShadow = function (frame, light) {
    if (!this._shadow) {
        this._shadow = xeogl.renderer.ShadowRenderer.create(this.gl, [this.gl.canvas.id, this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._shadow.errors) {
            this.errors = (this.errors || []).concat(this._shadow.errors);
            console.error(this._shadow.errors.join("\n"));
            return;
        }
    }
    this._shadow.drawObject(frame, this, light);
};

xeogl.renderer.Object.prototype.drawOutline = function (frame) {
    if (!this._outline) {
        this._outline = xeogl.renderer.OutlineRenderer.create(this.gl, [this.gl.canvas.id, this._getSceneHash(), this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._outline.errors) {
            this.errors = (this.errors || []).concat(this._outline.errors);
            console.error(this._outline.errors.join("\n"));
            return;
        }
    }
    this._outline.drawObject(frame, this);
};

xeogl.renderer.Object.prototype.pickObject = function (frame) {
    if (!this._pickObject) {
        this._pickObject = xeogl.renderer.PickObjectRenderer.create(this.gl, [this.gl.canvas.id, this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._pickObject.errors) {
            this.errors = (this.errors || []).concat(this._pickObject.errors);
            return;
        }
    }
    this._pickObject.drawObject(frame, this);
};

xeogl.renderer.Object.prototype.pickTriangle = function (frame) {
    if (!this._pickTriangle) {
        this._pickTriangle = xeogl.renderer.PickTriangleRenderer.create(this.gl, [this.gl.canvas.id, this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._pickTriangle.errors) {
            this.errors = (this.errors || []).concat(this._pickTriangle.errors);
            console.error(this._pickTriangle.errors.join("\n"));
            return;
        }
    }
    this._pickTriangle.drawObject(frame, this);
};

xeogl.renderer.Object.prototype.pickVertex = function (frame) {
    if (!this._pickVertex) {
        this._pickVertex = xeogl.renderer.PickVertexRenderer.create(this.gl, [this.gl.canvas.id, this.scene.clips.hash, this.geometry.hash, this.modes.hash].join(";"), this.scene, this);
        if (this._pickVertex.errors) {
            this.errors = (this.errors || []).concat(this._pickVertex.errors);
            console.error(this._pickVertex.errors.join("\n"));
            return;
        }
    }
    this._pickVertex.drawObject(frame, this);
};

xeogl.renderer.Object.prototype.destroy = function () {
    if (this._draw) {
        this._draw.destroy();
        this._draw = null;
    }
    if (this._ghostFill) {
        this._ghostFill.destroy();
        this._ghostFill = null;
    }
    if (this._ghostEdges) {
        this._ghostEdges.destroy();
        this._ghostEdges = null;
    }
    if (this._ghostVertices) {
        this._ghostVertices.destroy();
        this._ghostVertices = null;
    }
    if (this._outline) {
        this._outline.destroy();
        this._outline = null;
    }
    if (this._shadow) {
        this._shadow.destroy();
        this._shadow = null;
    }
    if (this._pickObject) {
        this._pickObject.destroy();
        this._pickObject = null;
    }
    if (this._pickTriangle) {
        this._pickTriangle.destroy();
        this._pickTriangle = null;
    }
    if (this._pickVertex) {
        this._pickVertex.destroy();
        this._pickVertex = null;
    }
};;/**
 * @author xeolabs / https://github.com/xeolabs
 */

xeogl.renderer = xeogl.renderer || {};

/**
 * Rendering context for a frame.
 */

xeogl.renderer.Frame = function () {
    this.reset();
};

xeogl.renderer.Frame.prototype.reset = function () {
    this.lastProgramId = null;
    this.backfaces = false;
    this.frontface = true; // true == "ccw" else "cw"
    this.textureUnit = 0;
    this.drawElements = 0;
    this.drawArrays = 0;
    this.useProgram = 0;
    this.bindTexture = 0;
    this.bindArray = 0;
    this.pass = 0;
    this.shadowViewMatrix = null;
    this.shadowProjMatrix = null;
    this.pickViewMatrix = null;
    this.pickProjMatrix = null;
    this.pickObjectIndex = 1;
};;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    var ids = new xeogl.utils.Map({});

    xeogl.renderer.Program = function (gl, shaderSource) {

        this.id = ids.addItem({});
        this.gl = gl;

        this.allocated = false;
        this.compiled = false;
        this.linked = false;
        this.validated = false;
        this.errors = null;

        this.uniforms = {};
        this.samplers = {};
        this.attributes = {};

        this._vertexShader = new xeogl.renderer.Shader(gl, gl.VERTEX_SHADER, joinSansComments(shaderSource.vertex));
        this._fragmentShader = new xeogl.renderer.Shader(gl, gl.FRAGMENT_SHADER, joinSansComments(shaderSource.fragment));

        if (!this._vertexShader.allocated) {
            this.errors = ["Vertex shader failed to allocate"].concat(this._vertexShader.errors);
            return;
        }

        if (!this._fragmentShader.allocated) {
            this.errors = ["Fragment shader failed to allocate"].concat(this._fragmentShader.errors);
            return;
        }

        this.allocated = true;

        if (!this._vertexShader.compiled) {
            this.errors = ["Vertex shader failed to compile"].concat(this._vertexShader.errors);
            return;
        }

        if (!this._fragmentShader.compiled) {
            this.errors = ["Fragment shader failed to compile"].concat(this._fragmentShader.errors);
            return;
        }

        this.compiled = true;

        var a;
        var i;
        var u;
        var uName;
        var location;

        this.handle = gl.createProgram();

        if (!this.handle) {
            this.errors = ["Failed to allocate program"];
            return;
        }

        gl.attachShader(this.handle, this._vertexShader.handle);
        gl.attachShader(this.handle, this._fragmentShader.handle);
        gl.linkProgram(this.handle);

        this.linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);

        // HACK: Disable validation temporarily: https://github.com/xeolabs/xeogl/issues/5
        // Perhaps we should defer validation until render-time, when the program has values set for all inputs?
        this.validated = true;

        if (!this.linked || !this.validated) {
            this.errors = [];
            this.errors.push("");
            this.errors.push(gl.getProgramInfoLog(this.handle));
            this.errors.push("\nVertex shader:\n");
            this.errors = this.errors.concat(shaderSource.vertex);
            this.errors.push("\nFragment shader:\n");
            this.errors = this.errors.concat(shaderSource.fragment);
            return;
        }

        var numUniforms = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);
        for (i = 0; i < numUniforms; ++i) {
            u = gl.getActiveUniform(this.handle, i);
            if (u) {
                uName = u.name;
                if (uName[uName.length - 1] === "\u0000") {
                    uName = uName.substr(0, uName.length - 1);
                }
                location = gl.getUniformLocation(this.handle, uName);
                if ((u.type === gl.SAMPLER_2D) || (u.type === gl.SAMPLER_CUBE) || (u.type === 35682)) {
                    this.samplers[uName] = new xeogl.renderer.Sampler(gl, location);
                } else {
                    this.uniforms[uName] = location;
                }
            }
        }

        var numAttribs = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);
        for (i = 0; i < numAttribs; i++) {
            a = gl.getActiveAttrib(this.handle, i);
            if (a) {
                location = gl.getAttribLocation(this.handle, a.name);
                this.attributes[a.name] = new xeogl.renderer.Attribute(gl, location);
            }
        }

        this.allocated = true;
    };

    function joinSansComments(srcLines) {
        var src = [];
        var line;
        var n;
        for (var i = 0, len = srcLines.length; i < len; i++) {
            line = srcLines[i];
            n = line.indexOf("/");
            if (n > 0) {
                if (line.charAt(n + 1) === "/") {
                    line = line.substring(0, n);
                }
            }
            src.push(line);
        }
        return src.join("\n");
    }

    xeogl.renderer.Program.prototype.bind = function () {
        if (!this.allocated) {
            return;
        }
        this.gl.useProgram(this.handle);
    };

    xeogl.renderer.Program.prototype.getLocation = function (name) {
        if (!this.allocated) {
            return;
        }
        return this.uniforms[name];
    };

    xeogl.renderer.Program.prototype.getAttribute = function (name) {
        if (!this.allocated) {
            return;
        }
        return this.attributes[name];
    };

    xeogl.renderer.Program.prototype.bindTexture = function (name, texture, unit) {
        if (!this.allocated) {
            return false;
        }
        var sampler = this.samplers[name];
        if (sampler) {
            return sampler.bindTexture(texture, unit);
        } else {
            return false;
        }
    };

    xeogl.renderer.Program.prototype.destroy = function () {
        if (!this.allocated) {
            return;
        }
        ids.removeItem(this.id);
        this.gl.deleteProgram(this.handle);
        this.gl.deleteShader(this._vertexShader.handle);
        this.gl.deleteShader(this._fragmentShader.handle);
        this.handle = null;
        this.attributes = null;
        this.uniforms = null;
        this.samplers = null;
        this.allocated = false;
    };
})();
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

xeogl.renderer.Sampler = function (gl, location) {
    this.bindTexture = function (texture, unit) {
        if (texture.bind(unit)) {
            gl.uniform1i(location, unit);
            return true;
        }
        return false;
    };
};;/**
 * @author xeolabs / https://github.com/xeolabs
 */

xeogl.renderer.Shader = function (gl, type, source) {

    this.allocated = false;
    this.compiled = false;
    this.handle = gl.createShader(type);

    if (!this.handle) {
        this.errors = [
            "Failed to allocate"
        ];
        return;
    }

    this.allocated = true;

    gl.shaderSource(this.handle, source);
    gl.compileShader(this.handle);

    this.compiled = gl.getShaderParameter(this.handle, gl.COMPILE_STATUS);

    if (!this.compiled) {

        if (!gl.isContextLost()) { // Handled explicitly elsewhere, so won't re-handle here

            var lines = source.split("\n");
            var numberedLines = [];
            for (var i = 0; i < lines.length; i++) {
                numberedLines.push((i + 1) + ": " + lines[i] + "\n");
            }
            this.errors = [];
            this.errors.push("");
            this.errors.push(gl.getShaderInfoLog(this.handle));
            this.errors = this.errors.concat(numberedLines.join(""));
        }
    }
};

xeogl.renderer.Shader.prototype.destroy = function () {

};;/**
 * @author xeolabs / https://github.com/xeolabs
 */

xeogl.renderer.State = Class.extend({
    __init: function (cfg) {
        this.id = this._ids.addItem({});
        this.hash = cfg.hash || "" + this.id; // Not used by all sub-classes
        for (var key in cfg) {
            if (cfg.hasOwnProperty(key)) {
                this[key] = cfg[key];
            }
        }
    },
    destroy: function () {
        this._ids.removeItem(this.id);
    }
});

xeogl.renderer.Visibility = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.Cull = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.Modes = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.Lights = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.Light = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.LambertMaterial = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.PhongMaterial = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.SpecularMaterial = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.MetallicMaterial = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.VerticesMaterial = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.EmphasisMaterial = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.OutlineMaterial = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.HighlightMaterial = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.ViewTransform = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.ProjTransform = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.Transform = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.Clips = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.Texture = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.CubeTexture = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.Fresnel = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.VertexBufs = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.Geometry = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
xeogl.renderer.Viewport = xeogl.renderer.State.extend({_ids: new xeogl.utils.Map({})});
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

xeogl.renderer.Texture2D = function (gl, target) {
    this.gl = gl;
    this.target = target || gl.TEXTURE_2D;
    this.texture = gl.createTexture();
    this.setPreloadColor([0,0,0,0]); // Prevents "there is no texture bound to the unit 0" error
    this.allocated = true;
};

xeogl.renderer.Texture2D.prototype.setPreloadColor = (function () {

    var color = new Uint8Array([0, 0, 0, 1]);

    return function (value) {

        if (!value) {
            color[0] = 0;
            color[1] = 0;
            color[2] = 0;
            color[3] = 255;
        } else {
            color[0] = Math.floor(value[0] * 255);
            color[1] = Math.floor(value[1] * 255);
            color[2] = Math.floor(value[2] * 255);
            color[3] = Math.floor((value[3] !== undefined ? value[3] : 1) * 255);
        }

        var gl = this.gl;

        gl.bindTexture(this.target, this.texture);
        gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

        if (this.target === gl.TEXTURE_CUBE_MAP) {

            var faces = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
            ];

            for (var i = 0, len = faces.length; i < len; i++) {
                gl.texImage2D(faces[i], 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);
            }

        } else {
            gl.texImage2D(this.target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);
        }

        gl.bindTexture(this.target, null);
    };
})();

xeogl.renderer.Texture2D.prototype.setTarget = function (target) {
    this.target = target || this.gl.TEXTURE_2D;
};

xeogl.renderer.Texture2D.prototype.setImage = function (image, props) {
    var gl = this.gl;
    gl.bindTexture(this.target, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, props.flipY);
    if (this.target === gl.TEXTURE_CUBE_MAP) {
        if (xeogl._isArray(image)) {
            var images = image;
            var faces = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
            ];
            for (var i = 0, len = faces.length; i < len; i++) {
                gl.texImage2D(faces[i], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[i]);
            }
        }
    } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    }
    gl.bindTexture(this.target, null);
};

xeogl.renderer.Texture2D.prototype.setProps = function (props) {
    var gl = this.gl;
    gl.bindTexture(this.target, this.texture);
    if (props.minFilter) {
        var minFilter = this._getGLEnum(props.minFilter);
        if (minFilter) {
            gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, minFilter);
            if (minFilter === gl.NEAREST_MIPMAP_NEAREST ||
                minFilter === gl.LINEAR_MIPMAP_NEAREST ||
                minFilter === gl.NEAREST_MIPMAP_LINEAR ||
                minFilter === gl.LINEAR_MIPMAP_LINEAR) {

                gl.generateMipmap(this.target);
            }
        }
    }
    if (props.magFilter) {
        var magFilter = this._getGLEnum(props.magFilter);
        if (magFilter) {
            gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, magFilter);
        }
    }
    if (props.wrapS) {
        var wrapS = this._getGLEnum(props.wrapS);
        if (wrapS) {
            gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, wrapS);
        }
    }
    if (props.wrapT) {
        var wrapT = this._getGLEnum(props.wrapT);
        if (wrapT) {
            gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, wrapT);
        }
    }
    gl.bindTexture(this.target, null);
};

xeogl.renderer.Texture2D.prototype._getGLEnum = function (name, defaultVal) {
    if (name === undefined) {
        return defaultVal;
    }
    var glName = xeogl.renderer.webgl.enums[name];
    if (glName === undefined) {
        return defaultVal;
    }
    return this.gl[glName];
};


xeogl.renderer.Texture2D.prototype.bind = function (unit) {
    if (!this.allocated) {
        return;
    }
    if (this.texture) {
        var gl = this.gl;
        gl.activeTexture(gl["TEXTURE" + unit]);
        gl.bindTexture(this.target, this.texture);
        return true;
    }
    return false;
};

xeogl.renderer.Texture2D.prototype.unbind = function (unit) {
    if (!this.allocated) {
        return;
    }
    if (this.texture) {
        var gl = this.gl;
        gl.activeTexture(gl["TEXTURE" + unit]);
        gl.bindTexture(this.target, null);
    }
};

xeogl.renderer.Texture2D.prototype.destroy = function () {
    if (!this.allocated) {
        return;
    }
    if (this.texture) {
        this.gl.deleteTexture(this.texture);
        this.texture = null;
    }
};

xeogl.renderer.clampImageSize = function (image, numPixels) {
    var n = image.width * image.height;
    if (n > numPixels) {
        var ratio = numPixels / n;
        var width = image.width * ratio;
        var height = image.height * ratio;
        var canvas = document.createElement("canvas");
        canvas.width = xeogl.renderer.nextHighestPowerOfTwo(width);
        canvas.height = xeogl.renderer.nextHighestPowerOfTwo(height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
        image = canvas;
    }
    return image;
};

xeogl.renderer.ensureImageSizePowerOfTwo = function (image) {
    if (!xeogl.renderer.isPowerOfTwo(image.width) || !xeogl.renderer.isPowerOfTwo(image.height)) {
        var canvas = document.createElement("canvas");
        canvas.width = xeogl.renderer.nextHighestPowerOfTwo(image.width);
        canvas.height = xeogl.renderer.nextHighestPowerOfTwo(image.height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image,
            0, 0, image.width, image.height,
            0, 0, canvas.width, canvas.height);
        image = canvas;
    }
    return image;
};

xeogl.renderer.isPowerOfTwo = function (x) {
    return (x & (x - 1)) === 0;
};

xeogl.renderer.nextHighestPowerOfTwo = function (x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
};
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

/**
 * Wraps a WebGL ArrayBuffer in convenience methods/properties.
 */

xeogl.renderer.ArrayBuffer = function (gl, type, data, numItems, itemSize, usage) {

    this._gl = gl;
    this.type = type;
    this.allocated = false;

    switch (data.constructor) {

        case Uint8Array:
            this.itemType = gl.UNSIGNED_BYTE;
            this.itemByteSize = 1;
            break;

        case Int8Array:
            this.itemType = gl.BYTE;
            this.itemByteSize = 1;
            break;

        case  Uint16Array:
            this.itemType = gl.UNSIGNED_SHORT;
            this.itemByteSize = 2;
            break;

        case  Int16Array:
            this.itemType = gl.SHORT;
            this.itemByteSize = 2;
            break;

        case Uint32Array:
            this.itemType = gl.UNSIGNED_INT;
            this.itemByteSize = 4;
            break;

        case Int32Array:
            this.itemType = gl.INT;
            this.itemByteSize = 4;
            break;

        default:
            this.itemType = gl.FLOAT;
            this.itemByteSize = 4;
    }

    this.usage = usage;
    this.length = 0;
    this.numItems = 0;
    this.itemSize = itemSize;

    this._allocate(data);
};

xeogl.renderer.ArrayBuffer.prototype._allocate = function (data) {
    this.allocated = false;
    this._handle = this._gl.createBuffer();
    if (!this._handle) {
        throw "Failed to allocate WebGL ArrayBuffer";
    }
    if (this._handle) {
        this._gl.bindBuffer(this.type, this._handle);
        this._gl.bufferData(this.type, data, this.usage);
        this._gl.bindBuffer(this.type, null);
        this.length = data.length;
        this.numItems = this.length / this.itemSize;
        this.allocated = true;
    }
};

xeogl.renderer.ArrayBuffer.prototype.setData = function (data, offset) {
    if (!this.allocated) {
        return;
    }
    if (data.length > this.length) {            // Needs reallocation
        this.destroy();
        this._allocate(data, data.length);
    } else {            // No reallocation needed
        this._gl.bindBuffer(this.type, this._handle);
        if (offset || offset === 0) {
            this._gl.bufferSubData(this.type, offset * this.itemByteSize, data);
        } else {
            this._gl.bufferData(this.type, data, this.usage);
        }
        this._gl.bindBuffer(this.type, null);
    }
};

xeogl.renderer.ArrayBuffer.prototype.bind = function () {
    if (!this.allocated) {
        return;
    }
    this._gl.bindBuffer(this.type, this._handle);
};

xeogl.renderer.ArrayBuffer.prototype.unbind = function () {
    if (!this.allocated) {
        return;
    }
    this._gl.bindBuffer(this.type, null);
};

xeogl.renderer.ArrayBuffer.prototype.destroy = function () {
    if (!this.allocated) {
        return;
    }
    this._gl.deleteBuffer(this._handle);
    this._handle = null;
    this.allocated = false;
};
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

/**
 * Wraps a WebGL Attribute in convenience methods/properties.
 */

xeogl.renderer.Attribute = function (gl, location) {
    this._gl = gl;
    this.location = location;
};

xeogl.renderer.Attribute.prototype.bindArrayBuffer = function (buffer, type) {
    if (!buffer) {
        return;
    }
    buffer.bind();
    this._gl.enableVertexAttribArray(this.location);
    this._gl.vertexAttribPointer(
        this.location,
        type === this._gl.BYTE ? 2 : buffer.itemSize,
        type || this._gl.FLOAT,
        type === this._gl.BYTE,
        0, 0);
};
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

xeogl.renderer.RenderBuffer = function (canvas, gl, options) {

    options = options || {};

    this.gl = gl;
    this.allocated = false;
    this.canvas = canvas;
    this.buffer = null;
    this.bound = false;
    this.size = options.size;
};

xeogl.renderer.RenderBuffer.prototype.setSize = function (size) {
    this.size = size;
};

xeogl.renderer.RenderBuffer.prototype.webglRestored = function (gl) {
    this.gl = gl;
    this.buffer = null;
    this.allocated = false;
    this.bound = false;
};

xeogl.renderer.RenderBuffer.prototype.bind = function () {
    this._touch();
    if (this.bound) {
        return;
    }
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.buffer.framebuf);
    this.bound = true;
};

xeogl.renderer.RenderBuffer.prototype._touch = function () {

    var width;
    var height;
    var gl = this.gl;

    if (this.size) {
        width = this.size[0];
        height = this.size[1];

    } else {
        width = this.canvas.clientWidth;
        height = this.canvas.clientHeight;
    }

    if (this.buffer) {

        if (this.buffer.width === width && this.buffer.height === height) {
            return;

        } else {
            gl.deleteTexture(this.buffer.texture);
            gl.deleteFramebuffer(this.buffer.framebuf);
            gl.deleteRenderbuffer(this.buffer.renderbuf);
        }
    }

    // width = 1024;
    // height = 1024;

    // width = 1024;
    // height = 1024;

    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    var renderbuf = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuf);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

    var framebuf = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuf);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuf);

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    // Verify framebuffer is OK

    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuf);
    if (!gl.isFramebuffer(framebuf)) {
        throw "Invalid framebuffer";
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    switch (status) {

        case gl.FRAMEBUFFER_COMPLETE:
            break;

        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

        case gl.FRAMEBUFFER_UNSUPPORTED:
            throw "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED";

        default:
            throw "Incomplete framebuffer: " + status;
    }

    this.buffer = {
        framebuf: framebuf,
        renderbuf: renderbuf,
        texture: texture,
        width: width,
        height: height
    };

    this.bound = false;
};

xeogl.renderer.RenderBuffer.prototype.clear = function () {
    if (!this.bound) {
        throw "Render buffer not bound";
    }
    var gl = this.gl;
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
};

xeogl.renderer.RenderBuffer.prototype.read = function (pickX, pickY) {
    var x = pickX;
    var y = this.canvas.height - pickY;
    var pix = new Uint8Array(4);
    var gl = this.gl;
    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pix);
    return pix;
};

xeogl.renderer.RenderBuffer.prototype.unbind = function () {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    this.bound = false;
};

xeogl.renderer.RenderBuffer.prototype.getTexture = function () {
    var self = this;
    return {
        renderBuffer: this,
        bind: function (unit) {
            if (self.buffer && self.buffer.texture) {
                self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                self.gl.bindTexture(self.gl.TEXTURE_2D, self.buffer.texture);
                return true;
            }
            return false;
        },
        unbind: function (unit) {
            if (self.buffer && self.buffer.texture) {
                self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                self.gl.bindTexture(self.gl.TEXTURE_2D, null);
            }
        }
    };
};

xeogl.renderer.RenderBuffer.prototype.destroy = function () {
    if (this.allocated) {
        var gl = this.gl;
        gl.deleteTexture(this.buffer.texture);
        gl.deleteFramebuffer(this.buffer.framebuf);
        gl.deleteRenderbuffer(this.buffer.renderbuf);
        this.allocated = false;
        this.buffer = null;
        this.bound = false;
    }
};
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    var ids = new xeogl.utils.Map({});

    xeogl.renderer.DrawRenderer = function (gl, hash, scene, object) {
        this._init(gl, hash, scene, object);
    };

    var drawRenderers = {};

    xeogl.renderer.DrawRenderer.create = function (gl, hash, scene, object) {
        var renderer = drawRenderers[hash];
        if (!renderer) {
            renderer = new xeogl.renderer.DrawRenderer(gl, hash, scene, object);
            drawRenderers[hash] = renderer;
            xeogl.stats.memory.programs++;
        }
        renderer._useCount++;
        return renderer;
    };

    xeogl.renderer.DrawRenderer.prototype.destroy = function () {
        if (--this._useCount === 0) {
            ids.removeItem(this.id);
            this._program.destroy();
            delete drawRenderers[this._hash];
            xeogl.stats.memory.programs--;
        }
    };

    xeogl.renderer.DrawRenderer.prototype._init = function (gl, hash, scene, object) {

        this.id = ids.addItem({});
        this._gl = gl;
        this._hash = hash;
        this._shaderSource = new xeogl.renderer.DrawShaderSource(gl, scene, object);
        this._program = new xeogl.renderer.Program(gl, this._shaderSource);
        this._scene = scene;
        this._useCount = 0;

        if (this._program.errors) {
            this.errors = this._program.errors;
            return;
        }

        var program = this._program;

        this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");
        this._uUVDecodeMatrix = program.getLocation("uvDecodeMatrix");

        this._uModelMatrix = program.getLocation("modelMatrix");
        this._uModelNormalMatrix = program.getLocation("modelNormalMatrix");
        this._uViewMatrix = program.getLocation("viewMatrix");
        this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
        this._uProjMatrix = program.getLocation("projMatrix");
        this._uGammaFactor = program.getLocation("gammaFactor");

        this._uLightAmbient = [];
        this._uLightColor = [];
        this._uLightDir = [];
        this._uLightPos = [];
        this._uLightAttenuation = [];
        this._uShadowViewMatrix = [];
        this._uShadowProjMatrix = [];

        var lights = scene.lights.lights;
        var light;

        for (var i = 0, len = lights.length; i < len; i++) {
            light = lights[i];
            switch (light.type) {

                case "ambient":
                    this._uLightAmbient[i] = program.getLocation("lightAmbient");
                    break;

                case "dir":
                    this._uLightColor[i] = program.getLocation("lightColor" + i);
                    this._uLightPos[i] = null;
                    this._uLightDir[i] = program.getLocation("lightDir" + i);
                    break;

                case "point":
                    this._uLightColor[i] = program.getLocation("lightColor" + i);
                    this._uLightPos[i] = program.getLocation("lightPos" + i);
                    this._uLightDir[i] = null;
                    this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                    break;

                case "spot":
                    this._uLightColor[i] = program.getLocation("lightColor" + i);
                    this._uLightPos[i] = program.getLocation("lightPos" + i);
                    this._uLightDir[i] = program.getLocation("lightDir" + i);
                    this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                    break;
            }

            if (light.shadow) {
                this._uShadowViewMatrix[i] = program.getLocation("shadowViewMatrix" + i);
                this._uShadowProjMatrix[i] = program.getLocation("shadowProjMatrix" + i);
            }
        }

        if (scene.lights.lightMap) {
            this._uLightMap = "lightMap";
        }

        if (scene.lights.reflectionMap) {
            this._uReflectionMap = "reflectionMap";
        }

        this._uClips = [];
        var clips = scene.clips.clips;
        for (var i = 0, len = clips.length; i < len; i++) {
            this._uClips.push({
                active: program.getLocation("clipActive" + i),
                pos: program.getLocation("clipPos" + i),
                dir: program.getLocation("clipDir" + i)
            });
        }

        var material = object.material;

        this._uPointSize = program.getLocation("pointSize");

        switch (material.type) {

            case "LambertMaterial":

                this._uMaterialColor = program.getLocation("materialColor");
                this._uMaterialEmissive = program.getLocation("materialEmissive");
                this._uAlphaModeCutoff = program.getLocation("materialAlphaModeCutoff");

                break;

            case "PhongMaterial":

                this._uMaterialAmbient = program.getLocation("materialAmbient");
                this._uMaterialDiffuse = program.getLocation("materialDiffuse");
                this._uMaterialSpecular = program.getLocation("materialSpecular");
                this._uMaterialEmissive = program.getLocation("materialEmissive");
                this._uAlphaModeCutoff = program.getLocation("materialAlphaModeCutoff");
                this._uMaterialShininess = program.getLocation("materialShininess");

                if (material.ambientMap) {
                    this._uMaterialAmbientMap = "ambientMap";
                    this._uMaterialAmbientMapMatrix = program.getLocation("ambientMapMatrix");
                }
                if (material.diffuseMap) {
                    this._uDiffuseMap = "diffuseMap";
                    this._uDiffuseMapMatrix = program.getLocation("diffuseMapMatrix");
                }
                if (material.specularMap) {
                    this._uSpecularMap = "specularMap";
                    this._uSpecularMapMatrix = program.getLocation("specularMapMatrix");
                }
                if (material.emissiveMap) {
                    this._uEmissiveMap = "emissiveMap";
                    this._uEmissiveMapMatrix = program.getLocation("emissiveMapMatrix");
                }
                if (material.alphaMap) {
                    this._uAlphaMap = "alphaMap";
                    this._uAlphaMapMatrix = program.getLocation("alphaMapMatrix");
                }
                if (material.reflectivityMap) {
                    this._uReflectivityMap = "reflectivityMap";
                    this._uReflectivityMapMatrix = program.getLocation("reflectivityMapMatrix");
                }
                if (material.normalMap) {
                    this._uNormalMap = "normalMap";
                    this._uNormalMapMatrix = program.getLocation("normalMapMatrix");
                }
                if (material.occlusionMap) {
                    this._uOcclusionMap = "occlusionMap";
                    this._uOcclusionMapMatrix = program.getLocation("occlusionMapMatrix");
                }
                if (material.diffuseFresnel) {
                    this._uDiffuseFresnelEdgeBias = program.getLocation("diffuseFresnelEdgeBias");
                    this._uDiffuseFresnelCenterBias = program.getLocation("diffuseFresnelCenterBias");
                    this._uDiffuseFresnelEdgeColor = program.getLocation("diffuseFresnelEdgeColor");
                    this._uDiffuseFresnelCenterColor = program.getLocation("diffuseFresnelCenterColor");
                    this._uDiffuseFresnelPower = program.getLocation("diffuseFresnelPower");
                }
                if (material.specularFresnel) {
                    this._uSpecularFresnelEdgeBias = program.getLocation("specularFresnelEdgeBias");
                    this._uSpecularFresnelCenterBias = program.getLocation("specularFresnelCenterBias");
                    this._uSpecularFresnelEdgeColor = program.getLocation("specularFresnelEdgeColor");
                    this._uSpecularFresnelCenterColor = program.getLocation("specularFresnelCenterColor");
                    this._uSpecularFresnelPower = program.getLocation("specularFresnelPower");
                }
                if (material.alphaFresnel) {
                    this._uAlphaFresnelEdgeBias = program.getLocation("alphaFresnelEdgeBias");
                    this._uAlphaFresnelCenterBias = program.getLocation("alphaFresnelCenterBias");
                    this._uAlphaFresnelEdgeColor = program.getLocation("alphaFresnelEdgeColor");
                    this._uAlphaFresnelCenterColor = program.getLocation("alphaFresnelCenterColor");
                    this._uAlphaFresnelPower = program.getLocation("alphaFresnelPower");
                }
                if (material.reflectivityFresnel) {
                    this._uReflectivityFresnelEdgeBias = program.getLocation("reflectivityFresnelEdgeBias");
                    this._uReflectivityFresnelCenterBias = program.getLocation("reflectivityFresnelCenterBias");
                    this._uReflectivityFresnelEdgeColor = program.getLocation("reflectivityFresnelEdgeColor");
                    this._uReflectivityFresnelCenterColor = program.getLocation("reflectivityFresnelCenterColor");
                    this._uReflectivityFresnelPower = program.getLocation("reflectivityFresnelPower");
                }
                if (material.emissiveFresnel) {
                    this._uEmissiveFresnelEdgeBias = program.getLocation("emissiveFresnelEdgeBias");
                    this._uEmissiveFresnelCenterBias = program.getLocation("emissiveFresnelCenterBias");
                    this._uEmissiveFresnelEdgeColor = program.getLocation("emissiveFresnelEdgeColor");
                    this._uEmissiveFresnelCenterColor = program.getLocation("emissiveFresnelCenterColor");
                    this._uEmissiveFresnelPower = program.getLocation("emissiveFresnelPower");
                }
                break;

            case "MetallicMaterial":

                this._uBaseColor = program.getLocation("materialBaseColor");
                this._uMaterialMetallic = program.getLocation("materialMetallic");
                this._uMaterialRoughness = program.getLocation("materialRoughness");
                this._uMaterialSpecularF0 = program.getLocation("materialSpecularF0");
                this._uMaterialEmissive = program.getLocation("materialEmissive");
                this._uAlphaModeCutoff = program.getLocation("materialAlphaModeCutoff");
                if (material.baseColorMap) {
                    this._uBaseColorMap = "baseColorMap";
                    this._uBaseColorMapMatrix = program.getLocation("baseColorMapMatrix");
                }
                if (material.metallicMap) {
                    this._uMetallicMap = "metallicMap";
                    this._uMetallicMapMatrix = program.getLocation("metallicMapMatrix");
                }
                if (material.roughnessMap) {
                    this._uRoughnessMap = "roughnessMap";
                    this._uRoughnessMapMatrix = program.getLocation("roughnessMapMatrix");
                }
                if (material.metallicRoughnessMap) {
                    this._uMetallicRoughnessMap = "metallicRoughnessMap";
                    this._uMetallicRoughnessMapMatrix = program.getLocation("metallicRoughnessMapMatrix");
                }
                if (material.emissiveMap) {
                    this._uEmissiveMap = "emissiveMap";
                    this._uEmissiveMapMatrix = program.getLocation("emissiveMapMatrix");
                }
                if (material.occlusionMap) {
                    this._uOcclusionMap = "occlusionMap";
                    this._uOcclusionMapMatrix = program.getLocation("occlusionMapMatrix");
                }
                if (material.alphaMap) {
                    this._uAlphaMap = "alphaMap";
                    this._uAlphaMapMatrix = program.getLocation("alphaMapMatrix");
                }
                if (material.normalMap) {
                    this._uNormalMap = "normalMap";
                    this._uNormalMapMatrix = program.getLocation("normalMapMatrix");
                }
                break;

            case "SpecularMaterial":

                this._uMaterialDiffuse = program.getLocation("materialDiffuse");
                this._uMaterialSpecular = program.getLocation("materialSpecular");
                this._uMaterialGlossiness = program.getLocation("materialGlossiness");
                this._uMaterialReflectivity = program.getLocation("reflectivityFresnel");
                this._uMaterialEmissive = program.getLocation("materialEmissive");
                this._uAlphaModeCutoff = program.getLocation("materialAlphaModeCutoff");
                if (material.diffuseMap) {
                    this._uDiffuseMap = "diffuseMap";
                    this._uDiffuseMapMatrix = program.getLocation("diffuseMapMatrix");
                }
                if (material.specularMap) {
                    this._uSpecularMap = "specularMap";
                    this._uSpecularMapMatrix = program.getLocation("specularMapMatrix");
                }
                if (material.glossinessMap) {
                    this._uGlossinessMap = "glossinessMap";
                    this._uGlossinessMapMatrix = program.getLocation("glossinessMapMatrix");
                }
                if (material.specularGlossinessMap) {
                    this._uSpecularGlossinessMap = "materialSpecularGlossinessMap";
                    this._uSpecularGlossinessMapMatrix = program.getLocation("materialSpecularGlossinessMapMatrix");
                }
                if (material.emissiveMap) {
                    this._uEmissiveMap = "emissiveMap";
                    this._uEmissiveMapMatrix = program.getLocation("emissiveMapMatrix");
                }
                if (material.occlusionMap) {
                    this._uOcclusionMap = "occlusionMap";
                    this._uOcclusionMapMatrix = program.getLocation("occlusionMapMatrix");
                }
                if (material.alphaMap) {
                    this._uAlphaMap = "alphaMap";
                    this._uAlphaMapMatrix = program.getLocation("alphaMapMatrix");
                }
                if (material.normalMap) {
                    this._uNormalMap = "normalMap";
                    this._uNormalMapMatrix = program.getLocation("normalMapMatrix");
                }
                break;
        }

        this._aPosition = program.getAttribute("position");
        this._aNormal = program.getAttribute("normal");
        this._aUV = program.getAttribute("uv");
        this._aColor = program.getAttribute("color");
        this._aFlags = program.getAttribute("flags");

        this._uClippable = program.getLocation("clippable");
        this._uColorize = program.getLocation("colorize");

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;

        this._lastColorize = new Float32Array(4);

        this._baseTextureUnit = 0;

    };

    xeogl.renderer.DrawRenderer.prototype._bindProgram = function (frame) {

        var program = this._program;

        program.bind();

        frame.useProgram++;
        frame.textureUnit = 0;

        var gl = this._gl;
        var maxTextureUnits = xeogl.WEBGL_INFO.MAX_TEXTURE_UNITS;
        var scene = this._scene;
        var lights = scene.lights;
        var light;

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;

        this._lastColorize[0] = -1;
        this._lastColorize[1] = -1;
        this._lastColorize[2] = -1;
        this._lastColorize[3] = -1;

        gl.uniformMatrix4fv(this._uViewMatrix, false, scene.viewTransform.matrix);
        gl.uniformMatrix4fv(this._uViewNormalMatrix, false, scene.viewTransform.normalMatrix);
        gl.uniformMatrix4fv(this._uProjMatrix, false, scene.projTransform.matrix);

        for (var i = 0, len = lights.lights.length; i < len; i++) {

            light = lights.lights[i];

            if (this._uLightAmbient[i]) {
                gl.uniform4f(this._uLightAmbient[i], light.color[0], light.color[1], light.color[2], light.intensity);

            } else {

                if (this._uLightColor[i]) {
                    gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
                }

                if (this._uLightPos[i]) {
                    gl.uniform3fv(this._uLightPos[i], light.pos);
                    if (this._uLightAttenuation[i]) {
                        gl.uniform1f(this._uLightAttenuation[i], light.attenuation);
                    }
                }

                if (this._uLightDir[i]) {
                    gl.uniform3fv(this._uLightDir[i], light.dir);
                }

                if (light.shadow) {
                    if (this._uShadowViewMatrix[i]) {
                        gl.uniformMatrix4fv(this._uShadowViewMatrix[i], false, light.getShadowViewMatrix());
                    }
                    if (this._uShadowProjMatrix[i]) {
                        gl.uniformMatrix4fv(this._uShadowProjMatrix[i], false, light.getShadowProjMatrix());
                    }
                    var shadowRenderBuf = light.getShadowRenderBuf();
                    if (shadowRenderBuf) {
                        program.bindTexture("shadowMap" + i, shadowRenderBuf.getTexture(), frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                    }
                }
            }
        }

        if (lights.lightMap && lights.lightMap.texture && this._uLightMap) {
            program.bindTexture(this._uLightMap, lights.lightMap.texture, frame.textureUnit);
            frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
            frame.bindTexture++;
        }

        if (lights.reflectionMap && lights.reflectionMap.texture && this._uReflectionMap) {
            program.bindTexture(this._uReflectionMap, lights.reflectionMap.texture, frame.textureUnit);
            frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
            frame.bindTexture++;
        }

        if (scene.clips.clips.length > 0) {
            var clips = scene.clips.clips;
            var clipUniforms;
            var uClipActive;
            var clip;
            var uClipPos;
            var uClipDir;
            for (var i = 0, len = this._uClips.length; i < len; i++) {
                clipUniforms = this._uClips[i];
                uClipActive = clipUniforms.active;
                clip = clips[i];
                if (uClipActive) {
                    gl.uniform1i(uClipActive, clip.active);
                }
                uClipPos = clipUniforms.pos;
                if (uClipPos) {
                    gl.uniform3fv(clipUniforms.pos, clip.pos);
                }
                uClipDir = clipUniforms.dir;
                if (uClipDir) {
                    gl.uniform3fv(clipUniforms.dir, clip.dir);
                }
            }
        }

        if (this._uGammaFactor) {
            gl.uniform1f(this._uGammaFactor, scene.gammaFactor);
        }

        this._baseTextureUnit = frame.textureUnit;
    };

    xeogl.renderer.DrawRenderer.prototype.drawObject = function (frame, object) {

        if (frame.lastProgramId !== this._program.id) {
            frame.lastProgramId = this._program.id;
            this._bindProgram(frame);
        }

        var maxTextureUnits = xeogl.WEBGL_INFO.MAX_TEXTURE_UNITS;
        var gl = this._gl;
        var program = this._program;
        var material = object.material;
        var modelTransform = object.modelTransform;
        var geometry = object.geometry;

        if (material.id !== this._lastMaterialId) {

            frame.textureUnit = this._baseTextureUnit;

            var backfaces = material.backfaces;
            if (frame.backfaces !== backfaces) {
                if (backfaces) {
                    gl.disable(gl.CULL_FACE);
                } else {
                    gl.enable(gl.CULL_FACE);
                }
                frame.backfaces = backfaces;
            }

            var frontface = material.frontface;
            if (frame.frontface !== frontface) {
                if (frontface) {
                    gl.frontFace(gl.CCW);
                } else {
                    gl.frontFace(gl.CW);
                }
                frame.frontface = frontface;
            }

            if (frame.lineWidth !== material.lineWidth) {
                gl.lineWidth(material.lineWidth);
                frame.lineWidth = material.lineWidth;
            }

            if (this._uPointSize) {
                gl.uniform1f(this._uPointSize, material.pointSize);
            }

            switch (material.type) {

                case "LambertMaterial":

                    if (this._uMaterialAmbient) {
                        gl.uniform3fv(this._uMaterialAmbient, material.ambient);
                    }
                    if (this._uMaterialColor) {
                        gl.uniform4f(this._uMaterialColor, material.color[0], material.color[1], material.color[2], material.alpha);
                    }
                    if (this._uMaterialEmissive) {
                        gl.uniform3fv(this._uMaterialEmissive, material.emissive);
                    }

                    break;

                case "PhongMaterial":

                    if (this._uMaterialShininess) {
                        gl.uniform1f(this._uMaterialShininess, material.shininess);
                    }
                    if (this._uMaterialAmbient) {
                        gl.uniform3fv(this._uMaterialAmbient, material.ambient);
                    }
                    if (this._uMaterialDiffuse) {
                        gl.uniform3fv(this._uMaterialDiffuse, material.diffuse);
                    }
                    if (this._uMaterialSpecular) {
                        gl.uniform3fv(this._uMaterialSpecular, material.specular);
                    }
                    if (this._uMaterialEmissive) {
                        gl.uniform3fv(this._uMaterialEmissive, material.emissive);
                    }
                    if (this._uAlphaModeCutoff) {
                        gl.uniform4f(
                            this._uAlphaModeCutoff,
                            1.0 * material.alpha,
                            material.alphaMode === 1 ? 1.0 : 0.0,
                            material.alphaCutoff,
                            0);
                    }
                    if (material.ambientMap && material.ambientMap.texture && this._uMaterialAmbientMap) {
                        program.bindTexture(this._uMaterialAmbientMap, material.ambientMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uMaterialAmbientMapMatrix) {
                            gl.uniformMatrix4fv(this._uMaterialAmbientMapMatrix, false, material.ambientMap.matrix);
                        }
                    }
                    if (material.diffuseMap && material.diffuseMap.texture && this._uDiffuseMap) {
                        program.bindTexture(this._uDiffuseMap, material.diffuseMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uDiffuseMapMatrix) {
                            gl.uniformMatrix4fv(this._uDiffuseMapMatrix, false, material.diffuseMap.matrix);
                        }
                    }
                    if (material.specularMap && material.specularMap.texture && this._uSpecularMap) {
                        program.bindTexture(this._uSpecularMap, material.specularMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uSpecularMapMatrix) {
                            gl.uniformMatrix4fv(this._uSpecularMapMatrix, false, material.specularMap.matrix);
                        }
                    }
                    if (material.emissiveMap && material.emissiveMap.texture && this._uEmissiveMap) {
                        program.bindTexture(this._uEmissiveMap, material.emissiveMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uEmissiveMapMatrix) {
                            gl.uniformMatrix4fv(this._uEmissiveMapMatrix, false, material.emissiveMap.matrix);
                        }
                    }
                    if (material.alphaMap && material.alphaMap.texture && this._uAlphaMap) {
                        program.bindTexture(this._uAlphaMap, material.alphaMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uAlphaMapMatrix) {
                            gl.uniformMatrix4fv(this._uAlphaMapMatrix, false, material.alphaMap.matrix);
                        }
                    }
                    if (material.reflectivityMap && material.reflectivityMap.texture && this._uReflectivityMap) {
                        program.bindTexture(this._uReflectivityMap, material.reflectivityMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        if (this._uReflectivityMapMatrix) {
                            gl.uniformMatrix4fv(this._uReflectivityMapMatrix, false, material.reflectivityMap.matrix);
                        }
                    }
                    if (material.normalMap && material.normalMap.texture && this._uNormalMap) {
                        program.bindTexture(this._uNormalMap, material.normalMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uNormalMapMatrix) {
                            gl.uniformMatrix4fv(this._uNormalMapMatrix, false, material.normalMap.matrix);
                        }
                    }
                    if (material.occlusionMap && material.occlusionMap.texture && this._uOcclusionMap) {
                        program.bindTexture(this._uOcclusionMap, material.occlusionMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uOcclusionMapMatrix) {
                            gl.uniformMatrix4fv(this._uOcclusionMapMatrix, false, material.occlusionMap.matrix);
                        }
                    }
                    if (material.diffuseFresnel) {
                        if (this._uDiffuseFresnelEdgeBias) {
                            gl.uniform1f(this._uDiffuseFresnelEdgeBias, material.diffuseFresnel.edgeBias);
                        }
                        if (this._uDiffuseFresnelCenterBias) {
                            gl.uniform1f(this._uDiffuseFresnelCenterBias, material.diffuseFresnel.centerBias);
                        }
                        if (this._uDiffuseFresnelEdgeColor) {
                            gl.uniform3fv(this._uDiffuseFresnelEdgeColor, material.diffuseFresnel.edgeColor);
                        }
                        if (this._uDiffuseFresnelCenterColor) {
                            gl.uniform3fv(this._uDiffuseFresnelCenterColor, material.diffuseFresnel.centerColor);
                        }
                        if (this._uDiffuseFresnelPower) {
                            gl.uniform1f(this._uDiffuseFresnelPower, material.diffuseFresnel.power);
                        }
                    }
                    if (material.specularFresnel) {
                        if (this._uSpecularFresnelEdgeBias) {
                            gl.uniform1f(this._uSpecularFresnelEdgeBias, material.specularFresnel.edgeBias);
                        }
                        if (this._uSpecularFresnelCenterBias) {
                            gl.uniform1f(this._uSpecularFresnelCenterBias, material.specularFresnel.centerBias);
                        }
                        if (this._uSpecularFresnelEdgeColor) {
                            gl.uniform3fv(this._uSpecularFresnelEdgeColor, material.specularFresnel.edgeColor);
                        }
                        if (this._uSpecularFresnelCenterColor) {
                            gl.uniform3fv(this._uSpecularFresnelCenterColor, material.specularFresnel.centerColor);
                        }
                        if (this._uSpecularFresnelPower) {
                            gl.uniform1f(this._uSpecularFresnelPower, material.specularFresnel.power);
                        }
                    }
                    if (material.alphaFresnel) {
                        if (this._uAlphaFresnelEdgeBias) {
                            gl.uniform1f(this._uAlphaFresnelEdgeBias, material.alphaFresnel.edgeBias);
                        }
                        if (this._uAlphaFresnelCenterBias) {
                            gl.uniform1f(this._uAlphaFresnelCenterBias, material.alphaFresnel.centerBias);
                        }
                        if (this._uAlphaFresnelEdgeColor) {
                            gl.uniform3fv(this._uAlphaFresnelEdgeColor, material.alphaFresnel.edgeColor);
                        }
                        if (this._uAlphaFresnelCenterColor) {
                            gl.uniform3fv(this._uAlphaFresnelCenterColor, material.alphaFresnel.centerColor);
                        }
                        if (this._uAlphaFresnelPower) {
                            gl.uniform1f(this._uAlphaFresnelPower, material.alphaFresnel.power);
                        }
                    }
                    if (material.reflectivityFresnel) {
                        if (this._uReflectivityFresnelEdgeBias) {
                            gl.uniform1f(this._uReflectivityFresnelEdgeBias, material.reflectivityFresnel.edgeBias);
                        }
                        if (this._uReflectivityFresnelCenterBias) {
                            gl.uniform1f(this._uReflectivityFresnelCenterBias, material.reflectivityFresnel.centerBias);
                        }
                        if (this._uReflectivityFresnelEdgeColor) {
                            gl.uniform3fv(this._uReflectivityFresnelEdgeColor, material.reflectivityFresnel.edgeColor);
                        }
                        if (this._uReflectivityFresnelCenterColor) {
                            gl.uniform3fv(this._uReflectivityFresnelCenterColor, material.reflectivityFresnel.centerColor);
                        }
                        if (this._uReflectivityFresnelPower) {
                            gl.uniform1f(this._uReflectivityFresnelPower, material.reflectivityFresnel.power);
                        }
                    }
                    if (material.emissiveFresnel) {
                        if (this._uEmissiveFresnelEdgeBias) {
                            gl.uniform1f(this._uEmissiveFresnelEdgeBias, material.emissiveFresnel.edgeBias);
                        }
                        if (this._uEmissiveFresnelCenterBias) {
                            gl.uniform1f(this._uEmissiveFresnelCenterBias, material.emissiveFresnel.centerBias);
                        }
                        if (this._uEmissiveFresnelEdgeColor) {
                            gl.uniform3fv(this._uEmissiveFresnelEdgeColor, material.emissiveFresnel.edgeColor);
                        }
                        if (this._uEmissiveFresnelCenterColor) {
                            gl.uniform3fv(this._uEmissiveFresnelCenterColor, material.emissiveFresnel.centerColor);
                        }
                        if (this._uEmissiveFresnelPower) {
                            gl.uniform1f(this._uEmissiveFresnelPower, material.emissiveFresnel.power);
                        }
                    }
                    break;


                case "MetallicMaterial":

                    if (this._uBaseColor) {
                        gl.uniform3fv(this._uBaseColor, material.baseColor);
                    }
                    if (this._uMaterialMetallic) {
                        gl.uniform1f(this._uMaterialMetallic, material.metallic);
                    }
                    if (this._uMaterialRoughness) {
                        gl.uniform1f(this._uMaterialRoughness, material.roughness);
                    }
                    if (this._uMaterialSpecularF0) {
                        gl.uniform1f(this._uMaterialSpecularF0, material.specularF0);
                    }
                    if (this._uMaterialEmissive) {
                        gl.uniform3fv(this._uMaterialEmissive, material.emissive);
                    }
                    if (this._uAlphaModeCutoff) {
                        gl.uniform4f(
                            this._uAlphaModeCutoff,
                            1.0 * material.alpha,
                            material.alphaMode === 1 ? 1.0 : 0.0,
                            material.alphaCutoff,
                            0.0);
                    }
                    if (material.baseColorMap && material.baseColorMap.texture && this._uBaseColorMap) {
                        program.bindTexture(this._uBaseColorMap, material.baseColorMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uBaseColorMapMatrix) {
                            gl.uniformMatrix4fv(this._uBaseColorMapMatrix, false, material.baseColorMap.matrix);
                        }
                    }
                    if (material.metallicMap && material.metallicMap.texture && this._uMetallicMap) {
                        program.bindTexture(this._uMetallicMap, material.metallicMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uMetallicMapMatrix) {
                            gl.uniformMatrix4fv(this._uMetallicMapMatrix, false, material.metallicMap.matrix);
                        }
                    }
                    if (material.roughnessMap && material.roughnessMap.texture && this._uRoughnessMap) {
                        program.bindTexture(this._uRoughnessMap, material.roughnessMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uRoughnessMapMatrix) {
                            gl.uniformMatrix4fv(this._uRoughnessMapMatrix, false, material.roughnessMap.matrix);
                        }
                    }
                    if (material.metallicRoughnessMap && material.metallicRoughnessMap.texture && this._uMetallicRoughnessMap) {
                        program.bindTexture(this._uMetallicRoughnessMap, material.metallicRoughnessMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uMetallicRoughnessMapMatrix) {
                            gl.uniformMatrix4fv(this._uMetallicRoughnessMapMatrix, false, material.metallicRoughnessMap.matrix);
                        }
                    }
                    if (material.emissiveMap && material.emissiveMap.texture && this._uEmissiveMap) {
                        program.bindTexture(this._uEmissiveMap, material.emissiveMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uEmissiveMapMatrix) {
                            gl.uniformMatrix4fv(this._uEmissiveMapMatrix, false, material.emissiveMap.matrix);
                        }
                    }
                    if (material.occlusionMap && material.occlusionMap.texture && this._uOcclusionMap) {
                        program.bindTexture(this._uOcclusionMap, material.occlusionMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uOcclusionMapMatrix) {
                            gl.uniformMatrix4fv(this._uOcclusionMapMatrix, false, material.occlusionMap.matrix);
                        }
                    }
                    if (material.alphaMap && material.alphaMap.texture && this._uAlphaMap) {
                        program.bindTexture(this._uAlphaMap, material.alphaMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uAlphaMapMatrix) {
                            gl.uniformMatrix4fv(this._uAlphaMapMatrix, false, material.alphaMap.matrix);
                        }
                    }
                    if (material.normalMap && material.normalMap.texture && this._uNormalMap) {
                        program.bindTexture(this._uNormalMap, material.normalMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uNormalMapMatrix) {
                            gl.uniformMatrix4fv(this._uNormalMapMatrix, false, material.normalMap.matrix);
                        }
                    }
                    break;

                case "SpecularMaterial":

                    if (this._uMaterialDiffuse) {
                        gl.uniform3fv(this._uMaterialDiffuse, material.diffuse);
                    }
                    if (this._uMaterialSpecular) {
                        gl.uniform3fv(this._uMaterialSpecular, material.specular);
                    }
                    if (this._uMaterialGlossiness) {
                        gl.uniform1f(this._uMaterialGlossiness, material.glossiness);
                    }
                    if (this._uMaterialReflectivity) {
                        gl.uniform1f(this._uMaterialReflectivity, material.reflectivity);
                    }
                    if (this._uMaterialEmissive) {
                        gl.uniform3fv(this._uMaterialEmissive, material.emissive);
                    }
                    if (this._uAlphaModeCutoff) {
                        gl.uniform4f(
                            this._uAlphaModeCutoff,
                            1.0 * material.alpha,
                            material.alphaMode === 1 ? 1.0 : 0.0,
                            material.alphaCutoff,
                            0.0);
                    }
                    if (material.diffuseMap && material.diffuseMap.texture && this._uDiffuseMap) {
                        program.bindTexture(this._uDiffuseMap, material.diffuseMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uDiffuseMapMatrix) {
                            gl.uniformMatrix4fv(this._uDiffuseMapMatrix, false, material.diffuseMap.matrix);
                        }
                    }
                    if (material.specularMap && material.specularMap.texture && this._uSpecularMap) {
                        program.bindTexture(this._uSpecularMap, material.specularMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uSpecularMapMatrix) {
                            gl.uniformMatrix4fv(this._uSpecularMapMatrix, false, material.specularMap.matrix);
                        }
                    }
                    if (material.glossinessMap && material.glossinessMap.texture && this._uGlossinessMap) {
                        program.bindTexture(this._uGlossinessMap, material.glossinessMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uGlossinessMapMatrix) {
                            gl.uniformMatrix4fv(this._uGlossinessMapMatrix, false, material.glossinessMap.matrix);
                        }
                    }
                    if (material.specularGlossinessMap && material.specularGlossinessMap.texture && this._uSpecularGlossinessMap) {
                        program.bindTexture(this._uSpecularGlossinessMap, material.specularGlossinessMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uSpecularGlossinessMapMatrix) {
                            gl.uniformMatrix4fv(this._uSpecularGlossinessMapMatrix, false, material.specularGlossinessMap.matrix);
                        }
                    }
                    if (material.emissiveMap && material.emissiveMap.texture && this._uEmissiveMap) {
                        program.bindTexture(this._uEmissiveMap, material.emissiveMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uEmissiveMapMatrix) {
                            gl.uniformMatrix4fv(this._uEmissiveMapMatrix, false, material.emissiveMap.matrix);
                        }
                    }
                    if (material.occlusionMap && material.occlusionMap.texture && this._uOcclusionMap) {
                        program.bindTexture(this._uOcclusionMap, material.occlusionMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uOcclusionMapMatrix) {
                            gl.uniformMatrix4fv(this._uOcclusionMapMatrix, false, material.occlusionMap.matrix);
                        }
                    }
                    if (material.alphaMap && material.alphaMap.texture && this._uAlphaMap) {
                        program.bindTexture(this._uAlphaMap, material.alphaMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uAlphaMapMatrix) {
                            gl.uniformMatrix4fv(this._uAlphaMapMatrix, false, material.alphaMap.matrix);
                        }
                    }
                    if (material.normalMap && material.normalMap.texture && this._uNormalMap) {
                        program.bindTexture(this._uNormalMap, material.normalMap.texture, frame.textureUnit);
                        frame.textureUnit = (frame.textureUnit + 1) % maxTextureUnits;
                        frame.bindTexture++;
                        if (this._uNormalMapMatrix) {
                            gl.uniformMatrix4fv(this._uNormalMapMatrix, false, material.normalMap.matrix);
                        }
                    }
                    break;
            }

            this._lastMaterialId = material.id;
        }

        if (modelTransform.id !== this._lastModelTransformId) {
            gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, modelTransform.getMatrix());
            if (this._uModelNormalMatrix) {
                gl.uniformMatrix4fv(this._uModelNormalMatrix, gl.FALSE, modelTransform.getNormalMatrix());
            }
            this._lastModelTransformId = modelTransform.id;
        }

        var modes = object.modes;

        if (this._uClippable) {
            gl.uniform1i(this._uClippable, modes.clippable);
        }

        if (this._uColorize) {
            var colorize = modes.colorize;
            var lastColorize = this._lastColorize;
            if (lastColorize[0] !== colorize[0] ||
                lastColorize[1] !== colorize[0] ||
                lastColorize[2] !== colorize[0] ||
                lastColorize[3] !== colorize[0]) {
                gl.uniform4fv(this._uColorize, colorize);
                lastColorize[0] = colorize[0];
                lastColorize[1] = colorize[1];
                lastColorize[2] = colorize[2];
                lastColorize[3] = colorize[3];
            }
        }

        if (geometry.combined) {
            var vertexBufs = object.vertexBufs;
            if (vertexBufs.id !== this._lastVertexBufsId) {
                if (vertexBufs.positionsBuf && this._aPosition) {
                    this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf, vertexBufs.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (vertexBufs.normalsBuf && this._aNormal) {
                    this._aNormal.bindArrayBuffer(vertexBufs.normalsBuf, vertexBufs.quantized ? gl.BYTE : gl.FLOAT);
                    frame.bindArray++;
                }
                if (vertexBufs.uvBuf && this._aUV) {
                    this._aUV.bindArrayBuffer(vertexBufs.uvBuf, geometry.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (vertexBufs.colorsBuf && this._aColor) {
                    this._aColor.bindArrayBuffer(vertexBufs.colorsBuf);
                    frame.bindArray++;
                }
                if (vertexBufs.flagsBuf && this._aFlags) {
                    this._aFlags.bindArrayBuffer(vertexBufs.flagsBuf, gl.UNSIGNED_SHORT);
                    frame.bindArray++;
                }
                this._lastVertexBufsId = vertexBufs.id;
            }
        }

        // Bind VBOs

        if (geometry.id !== this._lastGeometryId) {

            if (this._uPositionsDecodeMatrix) {
                gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometry.positionsDecodeMatrix);
            }

            if (this._uUVDecodeMatrix) {
                gl.uniformMatrix3fv(this._uUVDecodeMatrix, false, geometry.uvDecodeMatrix);
            }

            if (geometry.combined) { // VBOs were bound by the VertexBufs logic above
                if (geometry.indicesBufCombined) {
                    geometry.indicesBufCombined.bind();
                    frame.bindArray++;
                }
            } else {
                if (this._aPosition) {
                    this._aPosition.bindArrayBuffer(geometry.positionsBuf, geometry.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (this._aNormal) {
                    this._aNormal.bindArrayBuffer(geometry.normalsBuf, geometry.quantized ? gl.BYTE : gl.FLOAT);
                    frame.bindArray++;
                }
                if (this._aUV) {
                    this._aUV.bindArrayBuffer(geometry.uvBuf, geometry.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (this._aColor) {
                    this._aColor.bindArrayBuffer(geometry.colorsBuf);
                    frame.bindArray++;
                }
                if (this._aFlags) {
                    this._aFlags.bindArrayBuffer(geometry.flagsBuf);
                    frame.bindArray++;
                }
                if (geometry.indicesBuf) {
                    geometry.indicesBuf.bind();
                    frame.bindArray++;
                    // gl.drawElements(geometry.primitive, geometry.indicesBuf.numItems, geometry.indicesBuf.itemType, 0);
                    // frame.drawElements++;
                } else if (geometry.positions) {
                    // gl.drawArrays(gl.TRIANGLES, 0, geometry.positions.numItems);
                    //  frame.drawArrays++;
                }
            }
            this._lastGeometryId = geometry.id;
        }

        // Draw (indices bound in prev step)

        if (geometry.combined) {
            if (geometry.indicesBufCombined) { // Geometry indices into portion of uber-array
                gl.drawElements(geometry.primitive, geometry.indicesBufCombined.numItems, geometry.indicesBufCombined.itemType, 0);
                frame.drawElements++;
            } else {
                // TODO: drawArrays() with VertexBufs positions
            }
        } else {
            if (geometry.indicesBuf) {
                gl.drawElements(geometry.primitive, geometry.indicesBuf.numItems, geometry.indicesBuf.itemType, 0);
                frame.drawElements++;
            } else if (geometry.positions) {
                gl.drawArrays(gl.TRIANGLES, 0, geometry.positions.numItems);
                frame.drawArrays++;
            }
        }
    };
})();
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.DrawShaderSource = function (gl, scene, object) {
        var cfg = {
            texturing: hasTextures(object),
            normals: hasNormals(object),
            normalMapping: hasNormalMap(object),
            clipping: scene.clips.clips.length > 0,
            solid: false && object.material.backfaces,
            lambertMaterial: (object.material.type === "LambertMaterial"),
            phongMaterial: (object.material.type === "PhongMaterial"),
            metallicMaterial: (object.material.type === "MetallicMaterial"),
            specularMaterial: (object.material.type === "SpecularMaterial"),
            reflection: hasReflection(scene),
            receiveShadow: receivesShadow(scene, object),
            quantizedGeometry: !!object.geometry.quantized,
            gammaInput: scene.gammaInput, // If set, then it expects that all textures and colors are premultiplied gamma. Default is false.
            gammaOutput: scene.gammaOutput // If set, then it expects that all textures and colors need to be outputted in premultiplied gamma. Default is false.
        };
        this.vertex = cfg.lambertMaterial ? buildVertexLambert(gl, cfg, scene, object) : buildVertexDraw(gl, cfg, scene, object);
        this.fragment = cfg.lambertMaterial ? buildFragmentLambert(gl, cfg, scene, object) : buildFragmentDraw(gl, cfg, scene, object);
    };

    function receivesShadow(scene, object) {
        if (!object.modes.receiveShadow) {
            return false;
        }
        var lights = scene.lights.lights;
        if (!lights) {
            return false;
        }
        for (var i = 0, len = lights.length; i < len; i++) {
            if (lights[i].shadow) {
                return true;
            }
        }
        return false;
    }

    function hasTextures(object) {
        if (!object.geometry.uv) {
            return false;
        }
        var material = object.material;
        return !!(material.ambientMap ||
        material.occlusionMap ||
        material.baseColorMap ||
        material.diffuseMap ||
        material.alphaMap ||
        material.specularMap ||
        material.glossinessMap ||
        material.specularGlossinessMap ||
        material.emissiveMap ||
        material.metallicMap ||
        material.roughnessMap ||
        material.metallicRoughnessMap ||
        material.reflectivityMap ||
        object.material.normalMap);
    }

    function hasReflection(scene) {
        return false;
        //return (object.cubemap.layers && object.cubemap.layers.length > 0 && object.geometry.normalBuf);
    }

    function hasNormals(object) {
        var primitive = object.geometry.primitiveName;
        if ((object.geometry.autoVertexNormals || object.geometry.normals) && (primitive === "triangles" || primitive === "triangle-strip" || primitive === "triangle-fan")) {
            return true;
        }
        return false;
    }

    function hasNormalMap(object) {
        var geometry = object.geometry;
        var result = (!!geometry.positions && !!geometry.indices && !!geometry.normals && !!geometry.uv && !!object.material.normalMap);
        return result;
    }

    function getFragmentFloatPrecision(gl) {
        if (!gl.getShaderPrecisionFormat) {
            return "mediump";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
            return "highp";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
            return "mediump";
        }
        return "lowp";
    }

    const TEXTURE_DECODE_FUNCS = {
        "linear":   "linearToLinear",
        "sRGB":     "sRGBToLinear",
        "gamma":    "gammaToLinear"
    };

    function buildVertexLambert(gl, cfg, scene, object) {

        var i;
        var len;
        var lights = scene.lights.lights;
        var light;
        var billboard = object.modes.billboard;

        var src = [];

        src.push("// Lambertian drawing vertex shader");

        src.push("attribute vec3 position;");

        src.push("uniform mat4 modelMatrix;");
        src.push("uniform mat4 viewMatrix;");
        src.push("uniform mat4 projMatrix;");
        src.push("uniform vec4 colorize;");

        if (cfg.quantizedGeometry) {
            src.push("uniform mat4 positionsDecodeMatrix;");
        }

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
        }

        src.push("uniform vec4   lightAmbient;");
        src.push("uniform vec4   materialColor;");

        if (cfg.normals) {

            src.push("attribute vec3 normal;");
            src.push("uniform mat4 modelNormalMatrix;");
            src.push("uniform mat4 viewNormalMatrix;");

            for (i = 0, len = lights.length; i < len; i++) {
                light = lights[i];

                if (light.type === "ambient") {
                    continue;
                }

                src.push("uniform vec4 lightColor" + i + ";");

                if (light.type === "dir") {
                    src.push("uniform vec3 lightDir" + i + ";");
                }
                if (light.type === "point") {
                    src.push("uniform vec3 lightPos" + i + ";");
                }
                if (light.type === "spot") {
                    src.push("uniform vec3 lightPos" + i + ";");
                    src.push("uniform vec3 lightDir" + i + ";");
                }
            }

            if (cfg.quantizedGeometry) {
                src.push("vec3 octDecode(vec2 oct) {");
                src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
                src.push("    if (v.z < 0.0) {");
                src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
                src.push("    }");
                src.push("    return normalize(v);");
                src.push("}");
            }
        }

        src.push("varying vec4 vColor;");

        if (object.geometry.primitiveName === "points") {
            src.push("uniform float pointSize;");
        }

        if (billboard === "spherical" || billboard === "cylindrical") {
            src.push("void billboard(inout mat4 mat) {");
            src.push("   mat[0][0] = 1.0;");
            src.push("   mat[0][1] = 0.0;");
            src.push("   mat[0][2] = 0.0;");
            if (billboard === "spherical") {
                src.push("   mat[1][0] = 0.0;");
                src.push("   mat[1][1] = 1.0;");
                src.push("   mat[1][2] = 0.0;");
            }
            src.push("   mat[2][0] = 0.0;");
            src.push("   mat[2][1] = 0.0;");
            src.push("   mat[2][2] =1.0;");
            src.push("}");
        }

        src.push("void main(void) {");

        src.push("vec4 localPosition = vec4(position, 1.0); ");
        src.push("vec4 worldPosition;");

        if (cfg.quantizedGeometry) {
            src.push("localPosition = positionsDecodeMatrix * localPosition;");
        }

        if (cfg.normals) {
            if (cfg.quantizedGeometry) {
                src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ");
            } else {
                src.push("vec4 localNormal = vec4(normal, 0.0); ");
            }
            src.push("mat4 modelNormalMatrix2 = modelNormalMatrix;");
            src.push("mat4 viewNormalMatrix2 = viewNormalMatrix;");
        }

        src.push("mat4 viewMatrix2 = viewMatrix;");
        src.push("mat4 modelMatrix2 = modelMatrix;");

        if (object.modes.stationary) {
            src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")
        }

        if (billboard === "spherical" || billboard === "cylindrical") {

            src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
            src.push("billboard(modelMatrix2);");
            src.push("billboard(viewMatrix2);");
            src.push("billboard(modelViewMatrix);");

            if (cfg.normals) {
                src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");
                src.push("billboard(modelNormalMatrix2);");
                src.push("billboard(viewNormalMatrix2);");
                src.push("billboard(modelViewNormalMatrix);");
            }

            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition = modelViewMatrix * localPosition;");

        } else {
            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
        }

        if (cfg.normals) {
            src.push("vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);");
        }

        src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");
        src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");
        src.push("float lambertian = 1.0;");

        if (cfg.normals) {
            for (i = 0, len = lights.length; i < len; i++) {

                light = lights[i];

                if (light.type === "ambient") {
                    continue;
                }

                if (light.type === "dir") {
                    if (light.space === "view") {
                        src.push("viewLightDir = normalize(lightDir" + i + ");");
                    } else {
                        src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir" + i + ", 0.0)).xyz);");
                    }

                } else if (light.type === "point") {
                    if (light.space === "view") {
                        src.push("viewLightDir = normalize(lightPos" + i + " - viewPosition.xyz);");
                    } else {
                        src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightPos" + i + ", 0.0)).xyz);");
                    }

                } else if (light.type === "spot") {
                    if (light.space === "view") {
                        src.push("viewLightDir = normalize(lightDir" + i + ");");
                    } else {
                        src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir" + i + ", 0.0)).xyz);");
                    }

                } else {
                    continue;
                }

                src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");
                src.push("reflectedColor += lambertian * (lightColor" + i + ".rgb * lightColor" + i + ".a);");
            }
        }

        //src.push("vColor = vec4((reflectedColor * materialColor) + (lightAmbient.rgb * lightAmbient.a), 1.0) * colorize;");
        src.push("vColor = vec4((reflectedColor * materialColor.rgb), materialColor.a) * colorize;"); // TODO: How to have ambient bright enough for canvas BG but not too bright for scene?

        if (cfg.clipping) {
            src.push("vWorldPosition = worldPosition;");
        }

        if (object.geometry.primitiveName === "points") {
            src.push("gl_PointSize = pointSize;");
        }

        src.push("   gl_Position = projMatrix * viewPosition;");

        src.push("}");

        return src;
    }

    function buildFragmentLambert(gl, cfg, scene, object) {

        var i;
        var len;
        var src = [];

        src.push("// Lambertian drawing fragment shader");

        //src.push("precision " + getFragmentFloatPrecision(gl) + " float;");
        src.push("precision lowp float;");

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
            src.push("uniform bool clippable;");
            for (i = 0; i < scene.clips.clips.length; i++) {
                src.push("uniform bool clipActive" + i + ";");
                src.push("uniform vec3 clipPos" + i + ";");
                src.push("uniform vec3 clipDir" + i + ";");
            }
        }
        src.push("varying vec4 vColor;");
        if (cfg.gammaOutput) {
            src.push("uniform float gammaFactor;");
            src.push("    vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
            src.push("    return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
            src.push("}");
        }
        src.push("void main(void) {");
        if (cfg.clipping) {
            src.push("if (clippable) {");
            src.push("  float dist = 0.0;");
            for (i = 0; i < scene.clips.clips.length; i++) {
                src.push("if (clipActive" + i + ") {");
                src.push("   dist += clamp(dot(-clipDir" + i + ".xyz, vWorldPosition.xyz - clipPos" + i + ".xyz), 0.0, 1000.0);");
                src.push("}");
            }
            src.push("  if (dist > 0.0) { discard; }");
            if (cfg.solid) {
                src.push("  if (gl_FrontFacing == false) {");
                src.push("     gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);");
                src.push("     return;");
                src.push("  }");
            }
            src.push("}");
        }
        if (object.geometry.primitiveName === "points") {
            src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
            src.push("float r = dot(cxy, cxy);");
            src.push("if (r > 1.0) {");
            src.push("   discard;");
            src.push("}");

        }
        if (cfg.gammaOutput) {
            src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);");
        } else {
            src.push("gl_FragColor = vColor;");
        }
        src.push("}");
        return src;
    }

    function buildVertexDraw(gl, cfg, scene, object) {

        var material = object.material;
        var geometry = object.geometry;
        var i;
        var len;
        var lights = scene.lights.lights;
        var light;

        var src = [];

        // src.push("#extension GL_OES_standard_derivatives : enable");

        src.push("// Drawing vertex shader");
        src.push("attribute  vec3 position;");

        if (cfg.quantizedGeometry) {
            src.push("uniform mat4 positionsDecodeMatrix;");
        }

        src.push("uniform    mat4 modelMatrix;");
        src.push("uniform    mat4 viewMatrix;");
        src.push("uniform    mat4 projMatrix;");

        src.push("varying    vec3 vViewPosition;");

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
        }

        if (scene.lights.lightMap) {
            src.push("varying    vec3 vWorldNormal;");
        }

        if (cfg.normals) {

            src.push("attribute  vec3 normal;");

            src.push("uniform    mat4 modelNormalMatrix;");
            src.push("uniform    mat4 viewNormalMatrix;");

            //src.push("varying    vec3 vLocalNormal;");

            src.push("varying    vec3 vViewNormal;");

            for (i = 0, len = scene.lights.lights.length; i < len; i++) {
                light = scene.lights.lights[i];
                if (light.type === "ambient") {
                    continue;
                }
                if (light.type === "dir") {
                    src.push("uniform vec3 lightDir" + i + ";");
                }
                if (light.type === "point") {
                    src.push("uniform vec3 lightPos" + i + ";");
                }
                if (light.type === "spot") {
                    src.push("uniform vec3 lightPos" + i + ";");
                    src.push("uniform vec3 lightDir" + i + ";");
                }
                if (!(light.type === "dir" && light.space === "view")) {
                    // World-space dir lights don't need these varyings
                    src.push("varying vec4 vViewLightReverseDirAndDist" + i + ";");
                }
            }

            if (cfg.quantizedGeometry) {
                src.push("vec3 octDecode(vec2 oct) {");
                src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
                src.push("    if (v.z < 0.0) {");
                src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
                src.push("    }");
                src.push("    return normalize(v);");
                src.push("}");
            }
        }

        if (cfg.texturing) {
            src.push("attribute vec2 uv;");
            src.push("varying vec2 vUV;");

            if (cfg.quantizedGeometry) {
                src.push("uniform mat3 uvDecodeMatrix;")
            }
        }

        if (object.geometry.colors) {
            src.push("attribute vec4 color;");
            src.push("varying vec4 vColor;");
        }

        if (object.geometry.primitiveName === "points") {
            src.push("uniform float pointSize;");
        }

        var billboard = object.modes.billboard;

        if (billboard === "spherical" || billboard === "cylindrical") {

            src.push("void billboard(inout mat4 mat) {");
            src.push("   mat[0][0] = 1.0;");
            src.push("   mat[0][1] = 0.0;");
            src.push("   mat[0][2] = 0.0;");

            if (billboard === "spherical") {
                src.push("   mat[1][0] = 0.0;");
                src.push("   mat[1][1] = 1.0;");
                src.push("   mat[1][2] = 0.0;");
            }

            src.push("   mat[2][0] = 0.0;");
            src.push("   mat[2][1] = 0.0;");
            src.push("   mat[2][2] =1.0;");
            src.push("}");
        }

        if (cfg.receiveShadow) {

            src.push("const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);");

            for (i = 0, len = lights.length; i < len; i++) { // Light sources
                if (lights[i].shadow) {
                    src.push("uniform mat4 shadowViewMatrix" + i + ";");
                    src.push("uniform mat4 shadowProjMatrix" + i + ";");
                    src.push("varying vec4 vShadowPosFromLight" + i + ";");
                }
            }
        }

        src.push("void main(void) {");

        src.push("vec4 localPosition = vec4(position, 1.0); ");
        src.push("vec4 worldPosition;");

        if (cfg.quantizedGeometry) {
            src.push("localPosition = positionsDecodeMatrix * localPosition;");
        }

        if (cfg.normals) {
            if (cfg.quantizedGeometry) {
                src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ");
            } else {
                src.push("vec4 localNormal = vec4(normal, 0.0); ");
            }
            src.push("mat4 modelNormalMatrix2    = modelNormalMatrix;");
            src.push("mat4 viewNormalMatrix2     = viewNormalMatrix;");
        }

        src.push("mat4 viewMatrix2           = viewMatrix;");
        src.push("mat4 modelMatrix2          = modelMatrix;");

        if (object.modes.stationary) {
            src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")
        }

        if (billboard === "spherical" || billboard === "cylindrical") {

            src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");

            src.push("billboard(modelMatrix2);");
            src.push("billboard(viewMatrix2);");
            src.push("billboard(modelViewMatrix);");

            if (cfg.normals) {

                src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");

                src.push("billboard(modelNormalMatrix2);");
                src.push("billboard(viewNormalMatrix2);");
                src.push("billboard(modelViewNormalMatrix);");
            }

            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition = modelViewMatrix * localPosition;");

        } else {

            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
        }

        if (cfg.normals) {

            src.push("vec3 worldNormal = (modelNormalMatrix2 * localNormal).xyz; ");
            if (scene.lights.lightMap) {
                src.push("vWorldNormal = worldNormal;");
            }
            src.push("vViewNormal = normalize((viewNormalMatrix2 * vec4(worldNormal, 1.0)).xyz);");

            src.push("vec3 tmpVec3;");
            src.push("float lightDist;");

            for (i = 0, len = scene.lights.lights.length; i < len; i++) { // Lights

                light = scene.lights.lights[i];

                if (light.type === "ambient") {
                    continue;
                }

                if (light.type === "dir") {

                    if (light.space === "world") {
                        src.push("tmpVec3 = vec3(viewMatrix2 * vec4(lightDir" + i + ", 0.0) ).xyz;");
                        src.push("vViewLightReverseDirAndDist" + i + " = vec4(-tmpVec3, 0.0);");
                    }
                }

                if (light.type === "point") {

                    if (light.space === "world") {
                        src.push("tmpVec3 = (viewMatrix2 * vec4(lightPos" + i + ", 1.0)).xyz - viewPosition.xyz;");
                        src.push("lightDist = abs(length(tmpVec3));");

                    } else {
                        src.push("tmpVec3 = lightPos" + i + ".xyz - viewPosition.xyz;");
                        src.push("lightDist = abs(length(tmpVec3));");
                    }

                    src.push("vViewLightReverseDirAndDist" + i + " = vec4(tmpVec3, lightDist);");
                }
            }
        }

        if (cfg.texturing) {
            if (cfg.quantizedGeometry) {
                src.push("vUV = (uvDecodeMatrix * vec3(uv, 1.0)).xy;");
            } else {
                src.push("vUV = uv;");
            }
        }

        if (object.geometry.colors) {
            src.push("vColor = color;");
        }

        if (object.geometry.primitiveName === "points") {
            src.push("gl_PointSize = pointSize;");
        }

        if (cfg.clipping) {
            src.push("vWorldPosition = worldPosition;");
        }

        src.push("   vViewPosition = viewPosition.xyz;");

        src.push("   gl_Position = projMatrix * viewPosition;");

        src.push("const mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);");

        if (cfg.receiveShadow) {
            src.push("vec4 tempx; ");
            for (i = 0, len = lights.length; i < len; i++) { // Light sources
                if (lights[i].shadow) {
                    src.push("vShadowPosFromLight" + i + " = texUnitConverter * shadowProjMatrix" + i + " * (shadowViewMatrix" + i + " * worldPosition); ");
                }
            }
        }

        src.push("}");

        return src;
    }

    function buildFragmentDraw(gl, cfg, scene, object) {

        var material = object.material;
        var geometry = object.geometry;

        var i;
        var len;
        var lights = scene.lights.lights;
        var light;

        var src = [];

        src.push("// Fragment vertex shader");

        if (geometry.normals && material.normalMap) {
            src.push("#extension GL_OES_standard_derivatives : enable");
        }

        src.push("precision " + getFragmentFloatPrecision(gl) + " float;");

        if (cfg.receiveShadow) {
            src.push("float unpackDepth (vec4 color) {");
            src.push("  const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0 * 256.0), 1.0/(256.0*256.0*256.0));");
            src.push("  return dot(color, bitShift);");
            src.push("}");
        }

        //--------------------------------------------------------------------------------
        // GAMMA CORRECTION
        //--------------------------------------------------------------------------------

        src.push("uniform float gammaFactor;");

        src.push("vec4 linearToLinear( in vec4 value ) {");
        src.push("  return value;");
        src.push("}");

        src.push("vec4 sRGBToLinear( in vec4 value ) {");
        src.push("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");
        src.push("}");

        src.push("vec4 gammaToLinear( in vec4 value) {");
        src.push("  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );");
        src.push("}");

        if (cfg.gammaOutput) {
            src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
            src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
            src.push("}");
        }

        //--------------------------------------------------------------------------------
        // USER CLIP PLANES
        //--------------------------------------------------------------------------------

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
            src.push("uniform bool clippable;");
            for (var i = 0; i < scene.clips.clips.length; i++) {
                src.push("uniform bool clipActive" + i + ";");
                src.push("uniform vec3 clipPos" + i + ";");
                src.push("uniform vec3 clipDir" + i + ";");
            }
        }

        if (geometry.normals) {

            //--------------------------------------------------------------------------------
            // LIGHT AND REFLECTION MAP INPUTS
            // Define here so available globally to shader functions
            //--------------------------------------------------------------------------------

            if (scene.lights.lightMap) {
                src.push("uniform samplerCube lightMap;");
                src.push("uniform mat4 viewNormalMatrix;");
            }

            if (scene.lights.reflectionMap) {
                src.push("uniform samplerCube reflectionMap;");
            }

            if (scene.lights.lightMap || scene.lights.reflectionMap) {
                src.push("uniform mat4 viewMatrix;");
            }

            //--------------------------------------------------------------------------------
            // SHADING FUNCTIONS
            //--------------------------------------------------------------------------------

            // CONSTANT DEFINITIONS

            src.push("#define PI 3.14159265359");
            src.push("#define RECIPROCAL_PI 0.31830988618");
            src.push("#define RECIPROCAL_PI2 0.15915494");
            src.push("#define EPSILON 1e-6");

            src.push("#define saturate(a) clamp( a, 0.0, 1.0 )");

            // UTILITY DEFINITIONS

            src.push("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {");
            src.push("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );");
            src.push("}");

            // STRUCTURES

            src.push("struct IncidentLight {");
            src.push("   vec3 color;");
            src.push("   vec3 direction;");
            src.push("};");

            src.push("struct ReflectedLight {");
            src.push("   vec3 diffuse;");
            src.push("   vec3 specular;");
            src.push("};");

            src.push("struct Geometry {");
            src.push("   vec3 position;");
            src.push("   vec3 viewNormal;");
            src.push("   vec3 worldNormal;");
            src.push("   vec3 viewEyeDir;");
            src.push("};");

            src.push("struct Material {");
            src.push("   vec3    diffuseColor;");
            src.push("   float   specularRoughness;");
            src.push("   vec3    specularColor;");
            src.push("   float   shine;"); // Only used for Phong
            src.push("};");

            // COMMON UTILS

            if (cfg.phongMaterial) {

                if (scene.lights.lightMap || scene.lights.reflectionMap) {

                    src.push("void computePhongLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");

                    if (scene.lights.lightMap) {
                        src.push("   vec3 irradiance = " + TEXTURE_DECODE_FUNCS[scene.lights.lightMap.encoding] + "(textureCube(lightMap, geometry.worldNormal)).rgb;");
                        src.push("   irradiance *= PI;");
                        src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");
                        src.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;");
                    }

                    if (scene.lights.reflectionMap) {
                        //     src.push("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.worldNormal);");
                        //   //  src.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);");
                        //     src.push("   vec3 radiance               = textureCube(reflectionMap, geometry.worldNormal).rgb;");
                        ////     src.push("   radiance *= PI;");
                        //     src.push("   reflectedLight.specular     += radiance;");
                    }

                    src.push("}");
                }

                src.push("void computePhongLighting(const in IncidentLight directLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");
                src.push("   float dotNL     = saturate(dot(geometry.viewNormal, directLight.direction));");
                src.push("   vec3 irradiance = dotNL * directLight.color * PI;");
                src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");
                src.push("   reflectedLight.specular += directLight.color * material.specularColor * pow(max(dot(reflect(-directLight.direction, -geometry.viewNormal), geometry.viewEyeDir), 0.0), material.shine);");
                src.push("}");
            }

            if (cfg.metallicMaterial || cfg.specularMaterial) {

                // IRRADIANCE EVALUATION

                src.push("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {");
                src.push("   float r = ggxRoughness + 0.0001;");
                src.push("   return (2.0 / (r * r) - 2.0);");
                src.push("}");

                src.push("float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {");
                src.push("   float maxMIPLevelScalar = float( maxMIPLevel );");
                src.push("   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( ( blinnShininessExponent * blinnShininessExponent ) + 1.0 );");
                src.push("   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );");
                src.push("}");

                if (scene.lights.reflectionMap) {
                    src.push("vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {");
                    src.push("   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);"); //TODO: a random factor - fix this
                    src.push("   vec3 envMapColor = " + TEXTURE_DECODE_FUNCS[scene.lights.reflectionMap.encoding] + "(textureCube(reflectionMap, reflectVec, mipLevel)).rgb;");
                    src.push("  return envMapColor;");
                    src.push("}");
                }

                // SPECULAR BRDF EVALUATION

                src.push("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {");
                src.push("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );");
                src.push("   return ( 1.0 - specularColor ) * fresnel + specularColor;");
                src.push("}");

                src.push("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {");
                src.push("   float a2 = ( alpha * alpha );");
                src.push("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");
                src.push("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");
                src.push("   return 1.0 / ( gl * gv );");
                src.push("}");

                src.push("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {");
                src.push("   float a2 = ( alpha * alpha );");
                src.push("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");
                src.push("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");
                src.push("   return 0.5 / max( gv + gl, EPSILON );");
                src.push("}");

                src.push("float D_GGX(const in float alpha, const in float dotNH) {");
                src.push("   float a2 = ( alpha * alpha );");
                src.push("   float denom = ( dotNH * dotNH) * ( a2 - 1.0 ) + 1.0;");
                src.push("   return RECIPROCAL_PI * a2 / ( denom * denom);");
                src.push("}");

                src.push("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");
                src.push("   float alpha = ( roughness * roughness );");
                src.push("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );");
                src.push("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );");
                src.push("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );");
                src.push("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );");
                src.push("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );");
                src.push("   vec3  F = F_Schlick( specularColor, dotLH );");
                src.push("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );");
                src.push("   float D = D_GGX( alpha, dotNH );");
                src.push("   return F * (G * D);");
                src.push("}");

                src.push("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");
                src.push("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));");
                src.push("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);");
                src.push("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);");
                src.push("   vec4 r = roughness * c0 + c1;");
                src.push("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;");
                src.push("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;");
                src.push("   return specularColor * AB.x + AB.y;");
                src.push("}");


                if (scene.lights.lightMap || scene.lights.reflectionMap) {

                    src.push("void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");

                    if (scene.lights.lightMap) {
                        src.push("   vec3 irradiance = sRGBToLinear(textureCube(lightMap, geometry.worldNormal)).rgb;");
                        src.push("   irradiance *= PI;");
                        src.push("   vec3 diffuseBRDFContrib = (RECIPROCAL_PI * material.diffuseColor);");
                        src.push("   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;");
                        //   src.push("   reflectedLight.diffuse = vec3(1.0, 0.0, 0.0);");
                    }

                    if (scene.lights.reflectionMap) {
                        src.push("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);");
                        src.push("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);");
                        src.push("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);");
                        src.push("   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);");
                        src.push("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);");
                        src.push("   reflectedLight.specular     += radiance * specularBRDFContrib;");
                    }

                    src.push("}");
                }

                // MAIN LIGHTING COMPUTATION FUNCTION

                src.push("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");
                src.push("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));");
                src.push("   vec3 irradiance = dotNL * incidentLight.color * PI;");
                src.push("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");
                src.push("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);");
                src.push("}");

            } // (cfg.metallicMaterial || cfg.specularMaterial)

        } // geometry.normals

        //--------------------------------------------------------------------------------
        // GEOMETRY INPUTS
        //--------------------------------------------------------------------------------

        src.push("varying vec3 vViewPosition;");

        if (geometry.colors) {
            src.push("varying vec4 vColor;");
        }

        if (geometry.uv && ((geometry.normals && material.normalMap)
            || material.ambientMap
            || material.baseColorMap
            || material.diffuseMap
            || material.emissiveMap
            || material.metallicMap
            || material.roughnessMap
            || material.metallicRoughnessMap
            || material.specularMap
            || material.glossinessMap
            || material.specularGlossinessMap
            || material.occlusionMap
            || material.alphaMap)) {
            src.push("varying vec2 vUV;");
        }

        if (geometry.normals) {
            if (scene.lights.lightMap) {
                src.push("varying vec3 vWorldNormal;");
            }
            src.push("varying vec3 vViewNormal;");
        }

        //--------------------------------------------------------------------------------
        // MATERIAL CHANNEL INPUTS
        //--------------------------------------------------------------------------------

        if (material.ambient) {
            src.push("uniform vec3 materialAmbient;");
        }

        if (material.baseColor) {
            src.push("uniform vec3 materialBaseColor;");
        }

        if (material.alpha !== undefined && material.alpha !== null) {
            src.push("uniform vec4 materialAlphaModeCutoff;"); // [alpha, alphaMode, alphaCutoff]
        }

        if (material.emissive) {
            src.push("uniform vec3 materialEmissive;");
        }

        if (material.diffuse) {
            src.push("uniform vec3 materialDiffuse;");
        }

        if (material.glossiness !== undefined && material.glossiness !== null) {
            src.push("uniform float materialGlossiness;");
        }

        if (material.shininess !== undefined && material.shininess !== null) {
            src.push("uniform float materialShininess;");  // Phong channel
        }

        if (material.specular) {
            src.push("uniform vec3 materialSpecular;");
        }

        if (material.metallic !== undefined && material.metallic !== null) {
            src.push("uniform float materialMetallic;");
        }

        if (material.roughness !== undefined && material.roughness !== null) {
            src.push("uniform float materialRoughness;");
        }

        if (material.specularF0 !== undefined && material.specularF0 !== null) {
            src.push("uniform float materialSpecularF0;");
        }

        //--------------------------------------------------------------------------------
        // MATERIAL TEXTURE INPUTS
        //--------------------------------------------------------------------------------

        if (geometry.uv && material.ambientMap) {
            src.push("uniform sampler2D ambientMap;");
            if (material.ambientMap.matrix) {
                src.push("uniform mat4 ambientMapMatrix;");
            }
        }

        if (geometry.uv && material.baseColorMap) {
            src.push("uniform sampler2D baseColorMap;");
            if (material.baseColorMap.matrix) {
                src.push("uniform mat4 baseColorMapMatrix;");
            }
        }

        if (geometry.uv && material.diffuseMap) {
            src.push("uniform sampler2D diffuseMap;");
            if (material.diffuseMap.matrix) {
                src.push("uniform mat4 diffuseMapMatrix;");
            }
        }

        if (geometry.uv && material.emissiveMap) {
            src.push("uniform sampler2D emissiveMap;");
            if (material.emissiveMap.matrix) {
                src.push("uniform mat4 emissiveMapMatrix;");
            }
        }

        if (geometry.normals && geometry.uv && material.metallicMap) {
            src.push("uniform sampler2D metallicMap;");
            if (material.metallicMap.matrix) {
                src.push("uniform mat4 metallicMapMatrix;");
            }
        }

        if (geometry.normals && geometry.uv && material.roughnessMap) {
            src.push("uniform sampler2D roughnessMap;");
            if (material.roughnessMap.matrix) {
                src.push("uniform mat4 roughnessMapMatrix;");
            }
        }

        if (geometry.normals && geometry.uv && material.metallicRoughnessMap) {
            src.push("uniform sampler2D metallicRoughnessMap;");
            if (material.metallicRoughnessMap.matrix) {
                src.push("uniform mat4 metallicRoughnessMapMatrix;");
            }
        }

        if (geometry.normals && material.normalMap) {
            src.push("uniform sampler2D normalMap;");
            if (material.normalMap.matrix) {
                src.push("uniform mat4 normalMapMatrix;");
            }

            src.push("vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {");
            src.push("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );");
            src.push("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );");
            src.push("      vec2 st0 = dFdx( uv.st );");
            src.push("      vec2 st1 = dFdy( uv.st );");
            src.push("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );");
            src.push("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );");
            src.push("      vec3 N = normalize( surf_norm );");
            src.push("      vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;");
            src.push("      mat3 tsn = mat3( S, T, N );");
            //     src.push("      mapN *= 3.0;");
            src.push("      return normalize( tsn * mapN );");
            src.push("}");
        }

        if (geometry.uv && material.occlusionMap) {
            src.push("uniform sampler2D occlusionMap;");
            if (material.occlusionMap.matrix) {
                src.push("uniform mat4 occlusionMapMatrix;");
            }
        }

        if (geometry.uv && material.alphaMap) {
            src.push("uniform sampler2D alphaMap;");
            if (material.alphaMap.matrix) {
                src.push("uniform mat4 alphaMapMatrix;");
            }
        }

        if (geometry.normals && geometry.uv && material.specularMap) {
            src.push("uniform sampler2D specularMap;");
            if (material.specularMap.matrix) {
                src.push("uniform mat4 specularMapMatrix;");
            }
        }

        if (geometry.normals && geometry.uv && material.glossinessMap) {
            src.push("uniform sampler2D glossinessMap;");
            if (material.glossinessMap.matrix) {
                src.push("uniform mat4 glossinessMapMatrix;");
            }
        }

        if (geometry.normals && geometry.uv && material.specularGlossinessMap) {
            src.push("uniform sampler2D materialSpecularGlossinessMap;");
            if (material.specularGlossinessMap.matrix) {
                src.push("uniform mat4 materialSpecularGlossinessMapMatrix;");
            }
        }

        //--------------------------------------------------------------------------------
        // MATERIAL FRESNEL INPUTS
        //--------------------------------------------------------------------------------

        if (geometry.normals && (material.diffuseFresnel ||
            material.specularFresnel ||
            material.alphaFresnel ||
            material.emissiveFresnel ||
            material.reflectivityFresnel)) {

            src.push("float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {");
            src.push("    float fr = abs(dot(eyeDir, normal));");
            src.push("    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);");
            src.push("    return pow(finalFr, power);");
            src.push("}");

            if (material.diffuseFresnel) {
                src.push("uniform float  diffuseFresnelCenterBias;");
                src.push("uniform float  diffuseFresnelEdgeBias;");
                src.push("uniform float  diffuseFresnelPower;");
                src.push("uniform vec3   diffuseFresnelCenterColor;");
                src.push("uniform vec3   diffuseFresnelEdgeColor;");
            }

            if (material.specularFresnel) {
                src.push("uniform float  specularFresnelCenterBias;");
                src.push("uniform float  specularFresnelEdgeBias;");
                src.push("uniform float  specularFresnelPower;");
                src.push("uniform vec3   specularFresnelCenterColor;");
                src.push("uniform vec3   specularFresnelEdgeColor;");
            }

            if (material.alphaFresnel) {
                src.push("uniform float  alphaFresnelCenterBias;");
                src.push("uniform float  alphaFresnelEdgeBias;");
                src.push("uniform float  alphaFresnelPower;");
                src.push("uniform vec3   alphaFresnelCenterColor;");
                src.push("uniform vec3   alphaFresnelEdgeColor;");
            }

            if (material.reflectivityFresnel) {
                src.push("uniform float  materialSpecularF0FresnelCenterBias;");
                src.push("uniform float  materialSpecularF0FresnelEdgeBias;");
                src.push("uniform float  materialSpecularF0FresnelPower;");
                src.push("uniform vec3   materialSpecularF0FresnelCenterColor;");
                src.push("uniform vec3   materialSpecularF0FresnelEdgeColor;");
            }

            if (material.emissiveFresnel) {
                src.push("uniform float  emissiveFresnelCenterBias;");
                src.push("uniform float  emissiveFresnelEdgeBias;");
                src.push("uniform float  emissiveFresnelPower;");
                src.push("uniform vec3   emissiveFresnelCenterColor;");
                src.push("uniform vec3   emissiveFresnelEdgeColor;");
            }
        }

        //--------------------------------------------------------------------------------
        // LIGHT SOURCES
        //--------------------------------------------------------------------------------

        src.push("uniform vec4   lightAmbient;");

        if (geometry.normals) {

            for (i = 0, len = lights.length; i < len; i++) { // Light sources

                light = lights[i];

                if (light.type === "ambient") {
                    continue;
                }

                src.push("uniform vec4 lightColor" + i + ";");

                if (light.type === "point") {
                    src.push("uniform vec3 lightAttenuation" + i + ";");
                }
                if (light.type === "dir" && light.space === "view") {
                    src.push("uniform vec3 lightDir" + i + ";");
                }
                if (light.type === "point" && light.space === "view") {
                    src.push("uniform vec3 lightPos" + i + ";");
                } else {
                    src.push("varying vec4 vViewLightReverseDirAndDist" + i + ";");
                }
            }
        }

        if (cfg.receiveShadow) {

            // Variance shadow mapping filter

            // src.push("float linstep(float low, float high, float v){");
            // src.push("      return clamp((v-low)/(high-low), 0.0, 1.0);");
            // src.push("}");
            //
            // src.push("float VSM(sampler2D depths, vec2 uv, float compare){");
            // src.push("      vec2 moments = texture2D(depths, uv).xy;");
            // src.push("      float p = smoothstep(compare-0.02, compare, moments.x);");
            // src.push("      float variance = max(moments.y - moments.x*moments.x, -0.001);");
            // src.push("      float d = compare - moments.x;");
            // src.push("      float p_max = linstep(0.2, 1.0, variance / (variance + d*d));");
            // src.push("      return clamp(max(p, p_max), 0.0, 1.0);");
            // src.push("}");

            for (i = 0, len = lights.length; i < len; i++) { // Light sources
                if (lights[i].shadow) {
                    src.push("varying vec4 vShadowPosFromLight" + i + ";");
                    src.push("uniform sampler2D shadowMap" + i + ";");
                }
            }
        }

        src.push("uniform vec4 colorize;");

        //================================================================================
        // MAIN
        //================================================================================

        src.push("void main(void) {");

        if (cfg.clipping) {
            src.push("if (clippable) {");
            src.push("  float dist = 0.0;");
            for (var i = 0; i < scene.clips.clips.length; i++) {
                src.push("if (clipActive" + i + ") {");
                src.push("   dist += clamp(dot(-clipDir" + i + ".xyz, vWorldPosition.xyz - clipPos" + i + ".xyz), 0.0, 1000.0);");
                src.push("}");
            }
            src.push("  if (dist > 0.0) { discard; }");
            if (cfg.solid) {
                src.push("  if (gl_FrontFacing == false) {");
                src.push("     gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);");
                src.push("     return;");
                src.push("  }");
            }
            src.push("}");
        }

        if (geometry.primitiveName === "points") {
            src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
            src.push("float r = dot(cxy, cxy);");
            src.push("if (r > 1.0) {");
            src.push("   discard;");
            src.push("}");
        }

        src.push("float occlusion = 1.0;");

        if (material.ambient) {
            src.push("vec3 ambientColor = materialAmbient;");
        } else {
            src.push("vec3 ambientColor = vec3(1.0, 1.0, 1.0);");
        }

        if (material.diffuse) {
            src.push("vec3 diffuseColor = materialDiffuse;");
        } else if (material.baseColor) {
            src.push("vec3 diffuseColor = materialBaseColor;");
        } else {
            src.push("vec3 diffuseColor = vec3(1.0, 1.0, 1.0);");
        }

        if (geometry.colors) {
            src.push("diffuseColor *= vColor.rgb;");
        }

        if (material.emissive) {
            src.push("vec3 emissiveColor = materialEmissive;"); // Emissive default is (0,0,0), so initializing here
        } else {
            src.push("vec3  emissiveColor = vec3(0.0, 0.0, 0.0);");
        }

        if (material.specular) {
            src.push("vec3 specular = materialSpecular;");
        } else {
            src.push("vec3 specular = vec3(1.0, 1.0, 1.0);");
        }

        if (material.alpha !== undefined) {
            src.push("float alpha = materialAlphaModeCutoff[0];");
        } else {
            src.push("float alpha = 1.0;");
        }

        if (geometry.colors) {
            src.push("alpha *= vColor.a;");
        }

        if (material.glossiness !== undefined) {
            src.push("float glossiness = materialGlossiness;");
        } else {
            src.push("float glossiness = 1.0;");
        }

        if (material.metallic !== undefined) {
            src.push("float metallic = materialMetallic;");
        } else {
            src.push("float metallic = 1.0;");
        }

        if (material.roughness !== undefined) {
            src.push("float roughness = materialRoughness;");
        } else {
            src.push("float roughness = 1.0;");
        }

        if (material.specularF0 !== undefined) {
            src.push("float specularF0 = materialSpecularF0;");
        } else {
            src.push("float specularF0 = 1.0;");
        }

        //--------------------------------------------------------------------------------
        // TEXTURING
        //--------------------------------------------------------------------------------

        if (geometry.uv
            && ((geometry.normals && material.normalMap)
            || material.ambientMap
            || material.baseColorMap
            || material.diffuseMap
            || material.occlusionMap
            || material.emissiveMap
            || material.metallicMap
            || material.roughnessMap
            || material.metallicRoughnessMap
            || material.specularMap
            || material.glossinessMap
            || material.specularGlossinessMap
            || material.alphaMap)) {
            src.push("vec4 texturePos = vec4(vUV.s, vUV.t, 1.0, 1.0);");
            src.push("vec2 textureCoord;");
        }

        if (geometry.uv && material.ambientMap) {
            if (material.ambientMap.matrix) {
                src.push("textureCoord = (ambientMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("vec4 ambientTexel = texture2D(ambientMap, textureCoord).rgb;");
            src.push("ambientTexel = " + TEXTURE_DECODE_FUNCS[material.ambientMap.encoding] + "(ambientTexel);");
            src.push("ambientColor *= ambientTexel.rgb;");
        }

        if (geometry.uv && material.diffuseMap) {
            if (material.diffuseMap.matrix) {
                src.push("textureCoord = (diffuseMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("vec4 diffuseTexel = texture2D(diffuseMap, textureCoord);");
            src.push("diffuseTexel = " + TEXTURE_DECODE_FUNCS[material.diffuseMap.encoding] + "(diffuseTexel);");
            src.push("diffuseColor *= diffuseTexel.rgb;");
            src.push("alpha *= diffuseTexel.a;");
        }

        if (geometry.uv && material.baseColorMap) {
            if (material.baseColorMap.matrix) {
                src.push("textureCoord = (baseColorMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("vec4 baseColorTexel = texture2D(baseColorMap, textureCoord);");
            src.push("baseColorTexel = " + TEXTURE_DECODE_FUNCS[material.baseColorMap.encoding] + "(baseColorTexel);");
            src.push("diffuseColor *= baseColorTexel.rgb;");
            src.push("alpha *= baseColorTexel.a;");
        }

        if (geometry.uv && material.emissiveMap) {
            if (material.emissiveMap.matrix) {
                src.push("textureCoord = (emissiveMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("vec4 emissiveTexel = texture2D(emissiveMap, textureCoord);");
            src.push("emissiveTexel = " + TEXTURE_DECODE_FUNCS[material.emissiveMap.encoding] + "(emissiveTexel);");
            src.push("emissiveColor *= emissiveTexel.rgb;");
        }

        if (geometry.uv && material.alphaMap) {
            if (material.alphaMap.matrix) {
                src.push("textureCoord = (alphaMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("alpha *= texture2D(alphaMap, textureCoord).r;");
        }

        if (geometry.uv && material.occlusionMap) {
            if (material.occlusionMap.matrix) {
                src.push("textureCoord = (occlusionMapMatrix * texturePos).xy;");
            } else {
                src.push("textureCoord = texturePos.xy;");
            }
            src.push("occlusion *= texture2D(occlusionMap, textureCoord).r;");
        }

        if (geometry.normals && ((lights.length > 0) || scene.lights.lightMap || scene.lights.reflectionMap)) {

            //--------------------------------------------------------------------------------
            // SHADING
            //--------------------------------------------------------------------------------

            if (geometry.uv && material.normalMap) {
                if (material.normalMap.matrix) {
                    src.push("textureCoord = (normalMapMatrix * texturePos).xy;");
                } else {
                    src.push("textureCoord = texturePos.xy;");
                }
                src.push("vec3 viewNormal = perturbNormal2Arb( vViewPosition, normalize(vViewNormal), textureCoord );");
            } else {
                src.push("vec3 viewNormal = normalize(vViewNormal);");
            }

            if (geometry.uv && material.specularMap) {
                if (material.specularMap.matrix) {
                    src.push("textureCoord = (specularMapMatrix * texturePos).xy;");
                } else {
                    src.push("textureCoord = texturePos.xy;");
                }
                src.push("specular *= texture2D(specularMap, textureCoord).rgb;");
            }

            if (geometry.uv && material.glossinessMap) {
                if (material.glossinessMap.matrix) {
                    src.push("textureCoord = (glossinessMapMatrix * texturePos).xy;");
                } else {
                    src.push("textureCoord = texturePos.xy;");
                }
                src.push("glossiness *= texture2D(glossinessMap, textureCoord).r;");
            }

            if (geometry.uv && material.specularGlossinessMap) {
                if (material.specularGlossinessMap.matrix) {
                    src.push("textureCoord = (materialSpecularGlossinessMapMatrix * texturePos).xy;");
                } else {
                    src.push("textureCoord = texturePos.xy;");
                }
                src.push("vec4 specGlossRGB = texture2D(materialSpecularGlossinessMap, textureCoord).rgba;"); // TODO: what if only RGB texture?
                src.push("specular *= specGlossRGB.rgb;");
                src.push("glossiness *= specGlossRGB.a;");
            }

            if (geometry.uv && material.metallicMap) {
                if (material.metallicMap.matrix) {
                    src.push("textureCoord = (metallicMapMatrix * texturePos).xy;");
                } else {
                    src.push("textureCoord = texturePos.xy;");
                }
                src.push("metallic *= texture2D(metallicMap, textureCoord).r;");
            }

            if (geometry.uv && material.roughnessMap) {
                if (material.roughnessMap.matrix) {
                    src.push("textureCoord = (roughnessMapMatrix * texturePos).xy;");
                } else {
                    src.push("textureCoord = texturePos.xy;");
                }
                src.push("roughness *= texture2D(roughnessMap, textureCoord).r;");
            }

            if (geometry.uv && material.metallicRoughnessMap) {
                if (material.metallicRoughnessMap.matrix) {
                    src.push("textureCoord = (metallicRoughnessMapMatrix * texturePos).xy;");
                } else {
                    src.push("textureCoord = texturePos.xy;");
                }
                src.push("vec3 metalRoughRGB = texture2D(metallicRoughnessMap, textureCoord).rgb;");
                src.push("metallic *= metalRoughRGB.b;");
                src.push("roughness *= metalRoughRGB.g;");
            }

            src.push("vec3 viewEyeDir = normalize(-vViewPosition);");

            if (material.diffuseFresnel || material.specularFresnel || material.alphaFresnel || material.emissiveFresnel || material.reflectivityFresnel) {
                if (material.diffuseFresnel) {
                    src.push("float diffuseFresnel = fresnel(viewEyeDir, viewNormal, diffuseFresnelEdgeBias, diffuseFresnelCenterBias, diffuseFresnelPower);");
                    src.push("diffuseColor *= mix(diffuseFresnelEdgeColor, diffuseFresnelCenterColor, diffuseFresnel);");
                }
                if (material.specularFresnel) {
                    src.push("float specularFresnel = fresnel(viewEyeDir, viewNormal, specularFresnelEdgeBias, specularFresnelCenterBias, specularFresnelPower);");
                    src.push("specular *= mix(specularFresnelEdgeColor, specularFresnelCenterColor, specularFresnel);");
                }
                if (material.alphaFresnel) {
                    src.push("float alphaFresnel = fresnel(viewEyeDir, viewNormal, alphaFresnelEdgeBias, alphaFresnelCenterBias, alphaFresnelPower);");
                    src.push("alpha *= mix(alphaFresnelEdgeColor.r, alphaFresnelCenterColor.r, alphaFresnel);");
                }
                if (material.emissiveFresnel) {
                    src.push("float emissiveFresnel = fresnel(viewEyeDir, viewNormal, emissiveFresnelEdgeBias, emissiveFresnelCenterBias, emissiveFresnelPower);");
                    src.push("emissiveColor *= mix(emissiveFresnelEdgeColor, emissiveFresnelCenterColor, emissiveFresnel);");
                }
            }

            src.push("if (materialAlphaModeCutoff[1] == 1.0 && alpha < materialAlphaModeCutoff[2]) {"); // ie. (alphaMode == "mask" && alpha < alphaCutoff)
            src.push("   discard;"); // TODO: Discard earlier within this shader?
            src.push("}");

            // PREPARE INPUTS FOR SHADER FUNCTIONS

            src.push("IncidentLight  light;");
            src.push("Material       material;");
            src.push("Geometry       geometry;");
            src.push("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));");
            src.push("vec3           viewLightDir;");

            if (cfg.phongMaterial) {
                src.push("material.diffuseColor      = diffuseColor;");
                src.push("material.specularColor     = specular;");
                src.push("material.shine             = materialShininess;");
            }

            if (cfg.specularMaterial) {
                src.push("float oneMinusSpecularStrength = 1.0 - max(max(specular.r, specular.g ),specular.b);"); // Energy conservation
                src.push("material.diffuseColor      = diffuseColor * oneMinusSpecularStrength;");
                src.push("material.specularRoughness = clamp( 1.0 - glossiness, 0.04, 1.0 );");
                src.push("material.specularColor     = specular;");
            }

            if (cfg.metallicMaterial) {
                src.push("float dielectricSpecular = 0.16 * specularF0 * specularF0;");
                src.push("material.diffuseColor      = diffuseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);");
                src.push("material.specularRoughness = clamp(roughness, 0.04, 1.0);");
                src.push("material.specularColor     = mix(vec3(dielectricSpecular), diffuseColor, metallic);");
            }

            src.push("geometry.position      = vViewPosition;");
            if (scene.lights.lightMap) {
                src.push("geometry.worldNormal   = normalize(vWorldNormal);");
            }
            src.push("geometry.viewNormal    = viewNormal;");
            src.push("geometry.viewEyeDir    = viewEyeDir;");

            // ENVIRONMENT AND REFLECTION MAP SHADING

            if ((cfg.phongMaterial) && (scene.lights.lightMap || scene.lights.reflectionMap)) {
                src.push("computePhongLightMapping(geometry, material, reflectedLight);");
            }

            if ((cfg.specularMaterial || cfg.metallicMaterial) && (scene.lights.lightMap || scene.lights.reflectionMap)) {
                src.push("computePBRLightMapping(geometry, material, reflectedLight);");
            }

            // LIGHT SOURCE SHADING

            var light;

            src.push("float shadow = 1.0;");

            // if (cfg.receiveShadow) {
            //
            //     src.push("float lightDepth2 = clamp(length(lightPos)/40.0, 0.0, 1.0);");
            //     src.push("float illuminated = VSM(sLightDepth, lightUV, lightDepth2);");
            //
            src.push("float shadowAcneRemover = 0.0007;");
            src.push("vec3 fragmentDepth;");
            src.push("float texelSize = 1.0 / 1024.0;");
            src.push("float amountInLight = 0.0;");
            src.push("vec3 shadowCoord;");
            src.push('vec4 rgbaDepth;');
            src.push("float depth;");
            // }

            var numShadows = 0;
            for (i = 0, len = lights.length; i < len; i++) {

                light = lights[i];

                if (light.type === "ambient") {
                    continue;
                }
                if (light.type === "dir" && light.space === "view") {
                    src.push("viewLightDir = -normalize(lightDir" + i + ");");
                } else if (light.type === "point" && light.space === "view") {
                    src.push("viewLightDir = normalize(lightPos" + i + " - vViewPosition);");
                    //src.push("tmpVec3 = lightPos" + i + ".xyz - viewPosition.xyz;");
                    //src.push("lightDist = abs(length(tmpVec3));");
                } else {
                    src.push("viewLightDir = normalize(vViewLightReverseDirAndDist" + i + ".xyz);"); // If normal mapping, the fragment->light vector will be in tangent space
                }

                if (cfg.receiveShadow && light.shadow) {

                    // if (true) {
                    //     src.push('shadowCoord = (vShadowPosFromLight' + i + '.xyz/vShadowPosFromLight' + i + '.w)/2.0 + 0.5;');
                    //     src.push("lightDepth2 = clamp(length(vec3[0.0, 20.0, 20.0])/40.0, 0.0, 1.0);");
                    //     src.push("shadow *= VSM(shadowMap' + i + ', shadowCoord, lightDepth2);");
                    // }
                    //
                    // if (false) {
                    //
                    // PCF

                    src.push("shadow = 0.0;");

                    src.push("fragmentDepth = vShadowPosFromLight" + i + ".xyz;");
                    src.push("fragmentDepth.z -= shadowAcneRemover;");
                    src.push("for (int x = -3; x <= 3; x++) {");
                    src.push("  for (int y = -3; y <= 3; y++) {");
                    src.push("      float texelDepth = unpackDepth(texture2D(shadowMap" + i + ", fragmentDepth.xy + vec2(x, y) * texelSize));");
                    src.push("      if (fragmentDepth.z < texelDepth) {");
                    src.push("          shadow += 1.0;");
                    src.push("      }");
                    src.push("  }");
                    src.push("}");

                    src.push("light.color =  lightColor" + i + ".rgb * (lightColor" + i + ".a * (shadow / 49.0));");
                    //
                    // }
                    //
                    // if (false){
                    //
                    //     src.push("shadow = 1.0;");
                    //
                    //     src.push('shadowCoord = (vShadowPosFromLight' + i + '.xyz/vShadowPosFromLight' + i + '.w)/2.0 + 0.5;');
                    //
                    //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( -0.94201624, -0.39906216 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
                    //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( 0.94558609, -0.76890725 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
                    //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( -0.094184101, -0.92938870 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
                    //     src.push('shadow -= (shadowCoord.z > unpackDepth(texture2D(shadowMap' + i + ', shadowCoord.xy + vec2( 0.34495938, 0.29387760 ) / 700.0)) + 0.0015) ? 0.2 : 0.0;');
                    //
                    //     src.push("light.color =  lightColor" + i + ".rgb * (lightColor" + i + ".a * shadow);");
                    // }
                } else {
                    src.push("light.color =  lightColor" + i + ".rgb * (lightColor" + i + ".a );");
                }

                src.push("light.direction = viewLightDir;");


                if (cfg.phongMaterial) {
                    src.push("computePhongLighting(light, geometry, material, reflectedLight);");
                }

                if (cfg.specularMaterial || cfg.metallicMaterial) {
                    src.push("computePBRLighting(light, geometry, material, reflectedLight);");
                }
            }

            if (numShadows > 0) {
                //src.push("shadow /= " + (9 * numShadows) + ".0;");
            }

            //src.push("reflectedLight.diffuse *= shadow;");

            // COMBINE TERMS

            if (cfg.phongMaterial) {

                src.push("ambientColor *= (lightAmbient.rgb * lightAmbient.a);");

                src.push("vec3 outgoingLight =  ((occlusion * (( reflectedLight.diffuse + reflectedLight.specular)))) + emissiveColor;");

            } else {
                src.push("vec3 outgoingLight = (occlusion * (reflectedLight.diffuse)) + (shadow * occlusion * reflectedLight.specular) + emissiveColor;");
            }

        }

        else {

            //--------------------------------------------------------------------------------
            // NO SHADING - EMISSIVE and AMBIENT ONLY
            //--------------------------------------------------------------------------------

            src.push("ambientColor *= (lightAmbient.rgb * lightAmbient.a);");

            src.push("vec3 outgoingLight = emissiveColor + ambientColor;");
        }

        src.push("gl_FragColor = vec4(outgoingLight, alpha) * colorize;");

        if (cfg.gammaOutput) {
            src.push("gl_FragColor = linearToGamma(gl_FragColor, gammaFactor);");
        }

        src.push("}");

        return src;
    }
})();;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    var ids = new xeogl.utils.Map({});

    xeogl.renderer.OutlineRenderer = function (gl, hash, scene, object) {
        this._init(gl, hash, scene, object);
    };

    var outlineRenderers = {};

    xeogl.renderer.OutlineRenderer.create = function (gl, hash, scene, object) {
        var renderer = outlineRenderers[hash];
        if (!renderer) {
            renderer = new xeogl.renderer.OutlineRenderer(gl, hash, scene, object);
            outlineRenderers[hash] = renderer;
            xeogl.stats.memory.programs++;
        }
        renderer._useCount++;
        return renderer;
    };

    xeogl.renderer.OutlineRenderer.prototype.destroy = function () {
        if (--this._useCount === 0) {
            ids.removeItem(this.id);
            this._program.destroy();
            delete outlineRenderers[this._hash];
            xeogl.stats.memory.programs--;
        }
    };

    xeogl.renderer.OutlineRenderer.prototype._init = function (gl, hash, scene, object) {

        this.id = ids.addItem({});
        this._gl = gl;
        this._hash = hash;
        this._shaderSource = new xeogl.renderer.OutlineShaderSource(gl, scene, object);
        this._program = new xeogl.renderer.Program(gl, this._shaderSource);
        this._scene = scene;
        this._useCount = 0;

        if (this._program.errors) {
            this.errors = this._program.errors;
            return;
        }

        var program = this._program;

        this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

        this._uModelMatrix = program.getLocation("modelMatrix");
        this._uViewMatrix = program.getLocation("viewMatrix");
        this._uProjMatrix = program.getLocation("projMatrix");

        this._uClips = [];

        var clips = scene.clips.clips;
        for (var i = 0, len = clips.length; i < len; i++) {
            this._uClips.push({
                active: program.getLocation("clipActive" + i),
                pos: program.getLocation("clipPos" + i),
                dir: program.getLocation("clipDir" + i)
            });
        }

        this._uColor = program.getLocation("color");
        this._uWidth = program.getLocation("width");
        this._aPosition = program.getAttribute("position");
        this._aNormal = program.getAttribute("normal");
        this._uClippable = program.getLocation("clippable");
        this._uGammaFactor = program.getLocation("gammaFactor");

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;
    };

    xeogl.renderer.OutlineRenderer.prototype._bindProgram = function (frame) {

        var program = this._program;

        program.bind();

        frame.useProgram++;

        var gl = this._gl;
        var scene = this._scene;

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;

        gl.uniformMatrix4fv(this._uViewMatrix, false, scene.viewTransform.matrix);
        gl.uniformMatrix4fv(this._uProjMatrix, false, scene.projTransform.matrix);

        if (scene.clips.clips.length > 0) {
            var clips = scene.clips.clips;
            var clipUniforms;
            var uClipActive;
            var clip;
            var uClipPos;
            var uClipDir;
            for (var i = 0, len = this._uClips.length; i < len; i++) {
                clipUniforms = this._uClips[i];
                uClipActive = clipUniforms.active;
                clip = clips[i];
                if (uClipActive) {
                    gl.uniform1i(uClipActive, clip.active);
                }
                uClipPos = clipUniforms.pos;
                if (uClipPos) {
                    gl.uniform3fv(clipUniforms.pos, clip.pos);
                }
                uClipDir = clipUniforms.dir;
                if (uClipDir) {
                    gl.uniform3fv(clipUniforms.dir, clip.dir);
                }
            }
        }

        if (this._uGammaFactor) {
            gl.uniform1f(this._uGammaFactor, scene.gammaFactor);
        }
    };

    xeogl.renderer.OutlineRenderer.prototype.drawObject = function (frame, object) {

        if (frame.lastProgramId !== this._program.id) {
            frame.lastProgramId = this._program.id;
            this._bindProgram(frame);
        }

        var gl = this._gl;
        var material = object.outlineMaterial;
        var modelTransform = object.modelTransform;
        var geometry = object.geometry;

        if (material.id !== this._lastMaterialId) {

            if (this._uWidth) {
                gl.uniform1f(this._uWidth, material.width);
            }

            if (this._uColor) {
                var color = material.color;
                var alpha = material.alpha;
                gl.uniform4f(this._uColor, color[0], color[1], color[2], alpha);
            }

            this._lastMaterialId = material.id;
        }

        if (modelTransform.id !== this._lastModelTransformId) {
            gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, modelTransform.getMatrix());
            if (this._uModelNormalMatrix) {
                gl.uniformMatrix4fv(this._uModelNormalMatrix, gl.FALSE, modelTransform.getNormalMatrix());
            }
            this._lastModelTransformId = modelTransform.id;
        }

        var modes = object.modes;

        if (this._uClippable) {
            gl.uniform1i(this._uClippable, modes.clippable);
        }

        if (geometry.combined) {
            var vertexBufs = object.vertexBufs;
            if (vertexBufs.id !== this._lastVertexBufsId) {
                if (vertexBufs.positionsBuf && this._aPosition) {
                    this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf, vertexBufs.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (vertexBufs.normalsBuf && this._aNormal) {
                    this._aNormal.bindArrayBuffer(vertexBufs.normalsBuf, vertexBufs.quantized ? gl.BYTE : gl.FLOAT);
                    frame.bindArray++;
                }
                this._lastVertexBufsId = vertexBufs.id;
            }
        }

        // Bind VBOs

        if (geometry.id !== this._lastGeometryId) {

            if (this._uPositionsDecodeMatrix) {
                gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometry.positionsDecodeMatrix);
            }

            if (this._uUVDecodeMatrix) {
                gl.uniformMatrix3fv(this._uUVDecodeMatrix, false, geometry.uvDecodeMatrix);
            }

            if (geometry.combined) { // VBOs were bound by the VertexBufs logic above
                if (geometry.indicesBufCombined) {
                    geometry.indicesBufCombined.bind();
                    frame.bindArray++;
                }
            } else {
                if (this._aPosition) {
                    this._aPosition.bindArrayBuffer(geometry.positionsBuf, geometry.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (this._aNormal) {
                    this._aNormal.bindArrayBuffer(geometry.normalsBuf, geometry.quantized ? gl.BYTE : gl.FLOAT);
                    frame.bindArray++;
                }
                if (geometry.indicesBuf) {
                    geometry.indicesBuf.bind();
                    frame.bindArray++;
                    // gl.drawElements(geometry.primitive, geometry.indicesBuf.numItems, geometry.indicesBuf.itemType, 0);
                    // frame.drawElements++;
                } else if (geometry.positions) {
                    // gl.drawArrays(gl.TRIANGLES, 0, geometry.positions.numItems);
                    //  frame.drawArrays++;
                }
            }
            this._lastGeometryId = geometry.id;
        }

        // Draw (indices bound in prev step)

        if (geometry.combined) {
            if (geometry.indicesBufCombined) { // Geometry indices into portion of uber-array
                gl.drawElements(geometry.primitive, geometry.indicesBufCombined.numItems, geometry.indicesBufCombined.itemType, 0);
                frame.drawElements++;
            } else {
                // TODO: drawArrays() with VertexBufs positions
            }
        } else {
            if (geometry.indicesBuf) {
                gl.drawElements(geometry.primitive, geometry.indicesBuf.numItems, geometry.indicesBuf.itemType, 0);
                frame.drawElements++;
            } else if (geometry.positions) {
                gl.drawArrays(gl.TRIANGLES, 0, geometry.positions.numItems);
                frame.drawArrays++;
            }
        }
    };
})();
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.OutlineShaderSource = function (gl, scene, object) {
        var cfg = {
            normals: hasNormals(object),
            clipping: scene.clips.clips.length > 0,
            quantizedGeometry: !!object.geometry.quantized
        };
        this.vertex = buildVertex(gl, cfg, object);
        this.fragment = buildFragment(gl, cfg, scene);
    };

    function hasNormals(object) {
        var primitive = object.geometry.primitiveName;
        if ((object.geometry.autoVertexNormals || object.geometry.normals) && (primitive === "triangles" || primitive === "triangle-strip" || primitive === "triangle-fan")) {
            return true;
        }
        return false;
    }

    function buildVertex(gl, cfg, object) {

        var billboard = object.modes.billboard;

        var src = [];

        src.push("// Outline effect vertex shader");

        src.push("attribute vec3 position;");

        src.push("uniform mat4 modelMatrix;");
        src.push("uniform mat4 viewMatrix;");
        src.push("uniform mat4 projMatrix;");

        src.push("uniform float width;");

        if (cfg.quantizedGeometry) {
            src.push("uniform mat4 positionsDecodeMatrix;");
        }

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
        }

        if (cfg.normals) {
            src.push("attribute vec3 normal;");
            if (cfg.quantizedGeometry) {
                src.push("vec3 octDecode(vec2 oct) {");
                src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
                src.push("    if (v.z < 0.0) {");
                src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
                src.push("    }");
                src.push("    return normalize(v);");
                src.push("}");
            }
        }

        if (billboard === "spherical" || billboard === "cylindrical") {
            src.push("void billboard(inout mat4 mat) {");
            src.push("   mat[0][0] = 1.0;");
            src.push("   mat[0][1] = 0.0;");
            src.push("   mat[0][2] = 0.0;");
            if (billboard === "spherical") {
                src.push("   mat[1][0] = 0.0;");
                src.push("   mat[1][1] = 1.0;");
                src.push("   mat[1][2] = 0.0;");
            }
            src.push("   mat[2][0] = 0.0;");
            src.push("   mat[2][1] = 0.0;");
            src.push("   mat[2][2] =1.0;");
            src.push("}");
        }

        src.push("void main(void) {");

        src.push("vec4 localPosition = vec4(position, 1.0); ");
        src.push("vec4 worldPosition;");

        if (cfg.quantizedGeometry) {
            src.push("localPosition = positionsDecodeMatrix * localPosition;");
        }

        if (cfg.normals) {
            if (cfg.quantizedGeometry) {
                src.push("vec3 localNormal = octDecode(normal.xy); ");
            } else {
                src.push("vec3 localNormal = normal; ");
            }
            //src.push("  localPosition.xyz += (normalize(normal) * (width * 0.0005 * (projPos.z/1.0)));");
            src.push("  localPosition.xyz += (normalize(normal) * (width * 0.0005));");
        }

        src.push("mat4 viewMatrix2 = viewMatrix;");
        src.push("mat4 modelMatrix2 = modelMatrix;");

        if (object.modes.stationary) {
            src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")
        }

        if (billboard === "spherical" || billboard === "cylindrical") {

            src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
            src.push("billboard(modelMatrix2);");
            src.push("billboard(viewMatrix2);");
            src.push("billboard(modelViewMatrix);");
            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition = modelViewMatrix * localPosition;");

        } else {
            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
        }

        if (cfg.clipping) {
            src.push("vWorldPosition = worldPosition;");
        }

        src.push("   gl_Position = projMatrix * viewPosition;");

        src.push("}");
        return src;
    }

    function buildFragment(gl, cfg, scene) {
        var src = [];
        //src.push("precision " + getFragmentFloatPrecision(gl) + " float;");
        src.push("precision lowp float;");
        src.push("uniform vec4  color;");
        if (cfg.clipping) {
            src.push("uniform bool clippable;");
            src.push("varying vec4 vWorldPosition;");
            for (var i = 0; i < scene.clips.clips.length; i++) {
                src.push("uniform bool clipActive" + i + ";");
                src.push("uniform vec3 clipPos" + i + ";");
                src.push("uniform vec3 clipDir" + i + ";");
            }
        }
        src.push("void main(void) {");
        if (cfg.clipping) {
            src.push("if (clippable) {");
            src.push("  float dist = 0.0;");
            for (var i = 0; i < scene.clips.clips.length; i++) {
                src.push("if (clipActive" + i + ") {");
                src.push("   dist += clamp(dot(-clipDir" + i + ".xyz, vWorldPosition.xyz - clipPos" + i + ".xyz), 0.0, 1000.0);");
                src.push("}");
            }
            src.push("  if (dist > 0.0) { discard; }");
            src.push("}");
        }
        src.push("   gl_FragColor = color;");
        src.push("}");
        return src;
    }

    function getFragmentFloatPrecision(gl) {
        if (!gl.getShaderPrecisionFormat) {
            return "mediump";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
            return "highp";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
            return "mediump";
        }
        return "lowp";
    }

})();;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.PickObjectRenderer = function (gl, hash, scene, object) {

        this._gl = gl;
        this._hash = hash;
        this._shaderSource = new xeogl.renderer.PickObjectShaderSource(gl, scene, object);
        this._program = new xeogl.renderer.Program(gl, this._shaderSource);
        this._scene = scene;
        this._useCount = 0;

        if (this._program.errors) {
            this.errors = this._program.errors;
            return;
        }

        var program = this._program;

        this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

        this._uModelMatrix = program.getLocation("modelMatrix");
        this._uViewMatrix = program.getLocation("viewMatrix");
        this._uProjMatrix = program.getLocation("projMatrix");

        this._uClips = [];
        var clips = scene.clips.clips;
        for (var i = 0, len = clips.length; i < len; i++) {
            this._uClips.push({
                active: program.getLocation("clipActive" + i),
                pos: program.getLocation("clipPos" + i),
                dir: program.getLocation("clipDir" + i)
            });
        }

        this._aPosition = program.getAttribute("position");
        this._uClippable = program.getLocation("clippable");
        this._uPickColor = program.getLocation("pickColor");

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;
    };

    var renderers = {};

    xeogl.renderer.PickObjectRenderer.create = function (gl, hash, scene, object) {
        var renderer = renderers[hash];
        if (!renderer) {
            renderer = new xeogl.renderer.PickObjectRenderer(gl, hash, scene, object);
            renderers[hash] = renderer;
            xeogl.stats.memory.programs++;
        }
        renderer._useCount++;
        return renderer;
    };

    xeogl.renderer.PickObjectRenderer.prototype.destroy = function () {
        if (--this._useCount === 0) {
            this._program.destroy();
            delete renderers[this._hash];
            xeogl.stats.memory.programs--;
        }
    };

    xeogl.renderer.PickObjectRenderer.prototype._bindProgram = function (frame) {

        var gl = this._gl;
        var scene = this._scene;

        this._program.bind();

        frame.useProgram++;

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;

        gl.uniformMatrix4fv(this._uViewMatrix, false, frame.pickViewMatrix || scene.viewTransform.matrix);
        gl.uniformMatrix4fv(this._uProjMatrix, false, frame.pickProjMatrix || scene.projTransform.matrix);

        if (scene.clips.clips.length > 0) {
            var clips = scene.clips.clips;
            var clipUniforms;
            var uClipActive;
            var clip;
            var uClipPos;
            var uClipDir;
            for (var i = 0, len = this._uClips.length; i < len; i++) {
                clipUniforms = this._uClips[i];
                uClipActive = clipUniforms.active;
                clip = clips[i];
                if (uClipActive) {
                    gl.uniform1i(uClipActive, clip.active);
                }
                uClipPos = clipUniforms.pos;
                if (uClipPos) {
                    gl.uniform3fv(clipUniforms.pos, clip.pos);
                }
                uClipDir = clipUniforms.dir;
                if (uClipDir) {
                    gl.uniform3fv(clipUniforms.dir, clip.dir);
                }
            }
        }
    };

    xeogl.renderer.PickObjectRenderer.prototype.drawObject = function (frame, object) {

        if (frame.lastProgramId !== this._program.id) {
            frame.lastProgramId = this._program.id;
            this._bindProgram(frame);
        }

        var gl = this._gl;
        var material = object.material;
        var modelTransform = object.modelTransform;
        var geometry = object.geometry;

        if (material.id !== this._lastMaterialId) {
            var backfaces = material.backfaces;
            if (frame.backfaces !== backfaces) {
                if (backfaces) {
                    gl.disable(gl.CULL_FACE);
                } else {
                    gl.enable(gl.CULL_FACE);
                }
                frame.backfaces = backfaces;
            }
            var frontface = material.frontface;
            if (frame.frontface !== frontface) {
                if (frontface) {
                    gl.frontFace(gl.CCW);
                } else {
                    gl.frontFace(gl.CW);
                }
                frame.frontface = frontface;
            }

            if (frame.lineWidth !== material.lineWidth) {
                gl.lineWidth(material.lineWidth);
                frame.lineWidth = material.lineWidth;
            }

            if (this._uPointSize) {
                gl.uniform1i(this._uPointSize, material.pointSize);
            }
            this._lastMaterialId = material.id;
        }

        if (modelTransform.id !== this._lastModelTransformId) {
            gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, modelTransform.getMatrix());
            this._lastModelTransformId = modelTransform.id;
        }

        if (geometry.combined) {
            var vertexBufs = object.vertexBufs;
            if (vertexBufs.id !== this._lastVertexBufsId) {
                if (vertexBufs.positionsBuf && this._aPosition) {
                    this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf, vertexBufs.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                this._lastVertexBufsId = vertexBufs.id;
            }
        }

        // Entity state

        if (this._uClippable) {
            gl.uniform1i(this._uClippable, object.modes.clippable);
        }

        // Bind VBOs

        if (geometry.id !== this._lastGeometryId) {

            if (this._uPositionsDecodeMatrix) {
                gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometry.positionsDecodeMatrix);
            }

            if (geometry.combined) { // VBOs were bound by the preceding VertexBufs chunk
                if (geometry.indicesBufCombined) {
                    geometry.indicesBufCombined.bind();
                    frame.bindArray++;
                }
            } else {
                if (this._aPosition) {
                    this._aPosition.bindArrayBuffer(geometry.positionsBuf, geometry.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (geometry.indicesBuf) {
                    geometry.indicesBuf.bind();
                    frame.bindArray++;
                }
            }
            this._lastGeometryId = geometry.id;
        }

        // Entity-indexed color

        var a = frame.pickObjectIndex >> 24 & 0xFF;
        var b = frame.pickObjectIndex >> 16 & 0xFF;
        var g = frame.pickObjectIndex >> 8 & 0xFF;
        var r = frame.pickObjectIndex & 0xFF;

        frame.pickObjectIndex++;

        gl.uniform4f(this._uPickColor, r / 255, g / 255, b / 255, a / 255);

        // Draw (indices bound in prev step)

        if (geometry.combined) {
            if (geometry.indicesBufCombined) { // Geometry indices into portion of uber-array
                gl.drawElements(geometry.primitive, geometry.indicesBufCombined.numItems, geometry.indicesBufCombined.itemType, 0);
                frame.drawElements++;
            } else {
                // TODO: drawArrays() with VertexBufs positions
            }
        } else {
            if (geometry.indicesBuf) {
                gl.drawElements(geometry.primitive, geometry.indicesBuf.numItems, geometry.indicesBuf.itemType, 0);
                frame.drawElements++;
            } else if (geometry.positions) {
                gl.drawArrays(gl.TRIANGLES, 0, geometry.positions.numItems);
            }
        }
    };
})();
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.PickObjectShaderSource = function (gl, scene, object) {
        var cfg = {
            clipping: scene.clips.clips.length > 0,
            quantizedGeometry: !!object.geometry.quantized
        };
        this.vertex = buildVertex(gl, cfg, object);
        this.fragment = buildFragment(gl, cfg, scene);
    };
    
    function buildVertex(gl, cfg, object) {
        var src = [];

        src.push("// Object picking vertex shader");

        src.push("attribute vec3 position;");

        src.push("uniform mat4 modelMatrix;");
        src.push("uniform mat4 viewMatrix;");
        src.push("uniform mat4 viewNormalMatrix;");
        src.push("uniform mat4 projMatrix;");

        src.push("varying vec4 vViewPosition;");

        if (cfg.quantizedGeometry) {
            src.push("uniform mat4 positionsDecodeMatrix;");
        }

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
        }

        var billboard = object.modes.billboard;
        if (billboard === "spherical" || billboard === "cylindrical") {
            src.push("void billboard(inout mat4 mat) {");
            src.push("   mat[0][0] = 1.0;");
            src.push("   mat[0][1] = 0.0;");
            src.push("   mat[0][2] = 0.0;");
            if (billboard === "spherical") {
                src.push("   mat[1][0] = 0.0;");
                src.push("   mat[1][1] = 1.0;");
                src.push("   mat[1][2] = 0.0;");
            }
            src.push("   mat[2][0] = 0.0;");
            src.push("   mat[2][1] = 0.0;");
            src.push("   mat[2][2] =1.0;");
            src.push("}");
        }

        src.push("void main(void) {");

        src.push("vec4 localPosition = vec4(position, 1.0); ");
        if (cfg.quantizedGeometry) {
            src.push("localPosition = positionsDecodeMatrix * localPosition;");
        }

        src.push("mat4 viewMatrix2 = viewMatrix;");
        src.push("mat4 modelMatrix2 = modelMatrix;");

        if (object.modes.stationary) {
            src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")
        }
        if (billboard === "spherical" || billboard === "cylindrical") {
            src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
            src.push("billboard(modelMatrix2);");
            src.push("billboard(viewMatrix2);");
        }

        src.push("   vec4 worldPosition = modelMatrix2 * localPosition;");
        src.push("   vec4 viewPosition = viewMatrix2 * worldPosition;");

        if (cfg.clipping) {
            src.push("   vWorldPosition = worldPosition;");
        }

        src.push("   gl_Position = projMatrix * viewPosition;");
        src.push("}");
        return src;
    }

    function buildFragment(gl, cfg, scene) {
        var src = [];
        src.push("// Object picking fragment shader");
        src.push("precision lowp float;");
        src.push("uniform vec4 pickColor;");
        if (cfg.clipping) {
            src.push("uniform bool clippable;");
            src.push("varying vec4 vWorldPosition;");
            for (var i = 0; i < scene.clips.clips.length; i++) {
                src.push("uniform bool clipActive" + i + ";");
                src.push("uniform vec3 clipPos" + i + ";");
                src.push("uniform vec3 clipDir" + i + ";");
            }
        }
        src.push("void main(void) {");
        if (cfg.clipping) {
            src.push("if (clippable) {");
            src.push("  float dist = 0.0;");
            for (var i = 0; i < scene.clips.clips.length; i++) {
                src.push("if (clipActive" + i + ") {");
                src.push("   dist += clamp(dot(-clipDir" + i + ".xyz, vWorldPosition.xyz - clipPos" + i + ".xyz), 0.0, 1000.0);");
                src.push("}");
            }
            src.push("  if (dist > 0.0) { discard; }");
            src.push("}");
        }
        src.push("   gl_FragColor = pickColor; ");
        src.push("}");
        return src;
    }

    function getFragmentFloatPrecision(gl) {
        if (!gl.getShaderPrecisionFormat) {
            return "mediump";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
            return "highp";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
            return "mediump";
        }
        return "lowp";
    }

})();;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.PickTriangleRenderer = function (gl, hash, scene, object) {

        this._gl = gl;
        this._hash = hash;
        this._shaderSource = new xeogl.renderer.PickTriangleShaderSource(gl, scene, object);
        this._program = new xeogl.renderer.Program(gl, this._shaderSource);
        this._scene = scene;
        this._useCount = 0;

        if (this._program.errors) {
            this.errors = this._program.errors;
            return;
        }

        var program = this._program;

        this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

        this._uModelMatrix = program.getLocation("modelMatrix");
        this._uViewMatrix = program.getLocation("viewMatrix");
        this._uProjMatrix = program.getLocation("projMatrix");

        this._uClips = [];
        var clips = scene.clips.clips;
        for (var i = 0, len = clips.length; i < len; i++) {
            this._uClips.push({
                active: program.getLocation("clipActive" + i),
                pos: program.getLocation("clipPos" + i),
                dir: program.getLocation("clipDir" + i)
            });
        }

        this._aPosition = program.getAttribute("position");
        this._aColor = program.getAttribute("color");
        this._uClippable = program.getLocation("clippable");
    };

    var renderers = {};

    xeogl.renderer.PickTriangleRenderer.create = function (gl, hash, scene, object) {
        var renderer = renderers[hash];
        if (!renderer) {
            renderer = new xeogl.renderer.PickTriangleRenderer(gl, hash, scene, object);
            renderers[hash] = renderer;
            xeogl.stats.memory.programs++;
        }
        renderer._useCount++;
        return renderer;
    };

    xeogl.renderer.PickTriangleRenderer.prototype.destroy = function () {
        if (--this._useCount === 0) {
            this._program.destroy();
            delete renderers[this._hash];
            xeogl.stats.memory.programs--;
        }
    };

    xeogl.renderer.PickTriangleRenderer.prototype.drawObject = function (frame, object) {

        // Only rendering one object within a surface picking pass

        var gl = this._gl;
        var scene = this._scene;

        this._program.bind();

        frame.useProgram++;

        gl.uniformMatrix4fv(this._uViewMatrix, false, frame.pickViewMatrix || scene.viewTransform.matrix);
        gl.uniformMatrix4fv(this._uProjMatrix, false, frame.pickProjMatrix || scene.projTransform.matrix);

        if (scene.clips.clips.length > 0) {
            var clips = scene.clips.clips;
            var clipUniforms;
            var uClipActive;
            var clip;
            var uClipPos;
            var uClipDir;
            for (var i = 0, len = this._uClips.length; i < len; i++) {
                clipUniforms = this._uClips[i];
                uClipActive = clipUniforms.active;
                clip = clips[i];
                if (uClipActive) {
                    gl.uniform1i(uClipActive, clip.active);
                }
                uClipPos = clipUniforms.pos;
                if (uClipPos) {
                    gl.uniform3fv(clipUniforms.pos, clip.pos);
                }
                uClipDir = clipUniforms.dir;
                if (uClipDir) {
                    gl.uniform3fv(clipUniforms.dir, clip.dir);
                }
            }
        }

        var material = object.material;
        var modelTransform = object.modelTransform;
        var geometry = object.geometry;

        var backfaces = material.backfaces;
        if (frame.backfaces !== backfaces) {
            if (backfaces) {
                gl.disable(gl.CULL_FACE);
            } else {
                gl.enable(gl.CULL_FACE);
            }
            frame.backfaces = backfaces;
        }

        var frontface = material.frontface;
        if (frame.frontface !== frontface) {
            if (frontface) {
                gl.frontFace(gl.CCW);
            } else {
                gl.frontFace(gl.CW);
            }
            frame.frontface = frontface;
        }

        this._lastMaterialId = material.id;

        gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, modelTransform.getMatrix());

        if (this._uClippable) {
            gl.uniform1i(this._uClippable, object.modes.clippable);
        }

        var positions = geometry.getPickTrianglePositions();

        if (this._uPositionsDecodeMatrix) {
            gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometry.positionsDecodeMatrix);
            this._aPosition.bindArrayBuffer(positions, geometry.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
        } else {
            this._aPosition.bindArrayBuffer(positions);
        }

        var pickColorsBuf = geometry.getPickTriangleColors();
        pickColorsBuf.bind();
        gl.enableVertexAttribArray(this._aColor.location);
        this._gl.vertexAttribPointer(this._aColor.location, pickColorsBuf.itemSize, pickColorsBuf.itemType, true, 0, 0); // Normalize

        gl.drawArrays(geometry.primitive, 0, positions.numItems / 3);
    };
})();



;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.PickTriangleShaderSource = function (gl, scene, object) {
        var cfg = {
            clipping: scene.clips.clips.length > 0,
            quantizedGeometry: !!object.geometry.quantized
        };
        this.vertex = buildVertex(gl, cfg);
        this.fragment = buildFragment(gl, cfg, scene);
    };

    function buildVertex(gl, cfg) {

        var src = [];

        src.push("// Surface picking vertex shader");

        src.push("attribute vec3 position;");
        src.push("attribute vec4 color;");

        src.push("uniform mat4 modelMatrix;");
        src.push("uniform mat4 viewMatrix;");
        src.push("uniform mat4 projMatrix;");

        if (cfg.clipping) {
            src.push("uniform bool clippable;");
            src.push("varying vec4 vWorldPosition;");
        }

        src.push("varying vec4 vColor;");

        if (cfg.quantizedGeometry) {
            src.push("uniform mat4 positionsDecodeMatrix;");
        }

        src.push("void main(void) {");

        src.push("vec4 localPosition = vec4(position, 1.0); ");

        if (cfg.quantizedGeometry) {
            src.push("localPosition = positionsDecodeMatrix * localPosition;");
        }

        src.push("   vec4 worldPosition = modelMatrix * localPosition; ");
        src.push("   vec4 viewPosition = viewMatrix * worldPosition;");

        if (cfg.clipping) {
            src.push("   vWorldPosition = worldPosition;");
        }

        src.push("   vColor = color;");
        src.push("   gl_Position = projMatrix * viewPosition;");
        src.push("}");
        return src;
    }

    function buildFragment(gl, cfg, scene) {

        var src = [];

        src.push("// Surface picking fragment shader");

        src.push("precision lowp float;");

        src.push("varying vec4 vColor;");

        if (cfg.clipping) {
            src.push("uniform bool clippable;");
            src.push("varying vec4 vWorldPosition;");
            for (var i = 0; i < scene.clips.clips.length; i++) {
                src.push("uniform bool clipActive" + i + ";");
                src.push("uniform vec3 clipPos" + i + ";");
                src.push("uniform vec3 clipDir" + i + ";");
            }
        }

        src.push("void main(void) {");

        if (cfg.clipping) {
            src.push("if (clippable) {");
            src.push("  float dist = 0.0;");
            for (var i = 0; i < scene.clips.clips.length; i++) {
                src.push("if (clipActive" + i + ") {");
                src.push("   dist += clamp(dot(-clipDir" + i + ".xyz, vWorldPosition.xyz - clipPos" + i + ".xyz), 0.0, 1000.0);");
                src.push("}");
            }
            src.push("  if (dist > 0.0) { discard; }");
            src.push("}");
        }

        src.push("   gl_FragColor = vColor;");
        src.push("}");
        return src;
    }

    function getFragmentFloatPrecision(gl) {
        if (!gl.getShaderPrecisionFormat) {
            return "mediump";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
            return "highp";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
            return "mediump";
        }
        return "lowp";
    }

})();;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.ShadowRenderer = function (gl, hash, scene, object) {

        this._gl = gl;
        this._hash = hash;
        this._shaderSource = new xeogl.renderer.ShadowShaderSource(gl, scene,  object);
        this._program = new xeogl.renderer.Program(gl, this._shaderSource);
        this._scene = scene;
        this._useCount = 0;

        if (this._program.errors) {
            this.errors = this._program.errors;
            return;
        }

        var program = this._program;

        this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

        this._uModelMatrix = program.getLocation("modelMatrix");
        this._uViewMatrix = program.getLocation("viewMatrix");
        this._uProjMatrix = program.getLocation("projMatrix");

        this._uClips = {};
        var clips = scene.clips;
        for (var i = 0, len = clips.length; i < len; i++) {
            this._uClips.push({
                active: program.getLocation("clipActive" + i),
                pos: program.getLocation("clipPos" + i),
                dir: program.getLocation("clipDir" + i)
            });
        }

        this._aPosition = program.getAttribute("position");
        this._uClippable = program.getLocation("clippable");

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;
    };

    var renderers = {};

    xeogl.renderer.ShadowRenderer.create = function (gl, hash, scene, object) {
        var renderer = renderers[hash];
        if (!renderer) {
            renderer = new xeogl.renderer.ShadowRenderer(gl, hash, scene, object);
            renderers[hash] = renderer;
        }
        renderer._useCount++;
        return renderer;
    };

    xeogl.renderer.ShadowRenderer.prototype.destroy = function () {
        if (--this._useCount === 0) {
            this._program.destroy();
            delete renderers[this._hash];
        }
    };

    xeogl.renderer.ShadowRenderer.prototype._bindProgram = function (frame) {

        var gl = this._gl;
        var scene = this._scene;

        this._program.bind();

        frame.useProgram++;

        this._lastLightId = null;
        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;

        if (scene.clips.clips.length > 0) {
            var clips = scene.clips.clips;
            var clipUniforms;
            var uClipActive;
            var clip;
            var uClipPos;
            var uClipDir;
            for (var i = 0, len = this._uClips.length; i < len; i++) {
                clipUniforms = this._uClips[i];
                uClipActive = clipUniforms.active;
                clip = clips[i];
                if (uClipActive) {
                    gl.uniform1i(uClipActive, clip.active);
                }
                uClipPos = clipUniforms.pos;
                if (uClipPos) {
                    gl.uniform3fv(clipUniforms.pos, clip.pos);
                }
                uClipDir = clipUniforms.dir;
                if (uClipDir) {
                    gl.uniform3fv(clipUniforms.dir, clip.dir);
                }
            }
        }
    };

    xeogl.renderer.ShadowRenderer.prototype.drawObject = function (frame, object, light) {

        if (frame.lastProgramId !== this._program.id) {
            frame.lastProgramId = this._program.id;
            this._bindProgram(frame);
        }

        var gl = this._gl;
        var material = object.material;
        var modelTransform = object.modelTransform;
        var geometry = object.geometry;

        frame.textureUnit = 0;

        if (light.id !== this._lastLightId) {
            gl.uniformMatrix4fv(this._uViewMatrix, false, light.getShadowViewMatrix());
            gl.uniformMatrix4fv(this._uProjMatrix, false, light.getShadowProjMatrix());
            this._lastLightId = light.id;
        }

        // gl.uniformMatrix4fv(this._uViewMatrix, false, this._scene.viewTransform.matrix);
        // gl.uniformMatrix4fv(this._uProjMatrix, false, this._scene.projTransform.matrix);

        if (material.id !== this._lastMaterialId) {
            var backfaces = material.backfaces;
            if (frame.backfaces !== backfaces) {
                if (backfaces) {
                    gl.disable(gl.CULL_FACE);
                } else {
                    gl.enable(gl.CULL_FACE);
                }
                frame.backfaces = backfaces;
            }

            var frontface = material.frontface;
            if (frame.frontface !== frontface) {
                if (frontface) {
                    gl.frontFace(gl.CCW);
                } else {
                    gl.frontFace(gl.CW);
                }
                frame.frontface = frontface;
            }

            if (frame.lineWidth !== material.lineWidth) {
                gl.lineWidth(material.lineWidth);
                frame.lineWidth = material.lineWidth;
            }

            if (this._uPointSize) {
                gl.uniform1i(this._uPointSize, material.pointSize);
            }
            this._lastMaterialId = material.id;
        }

        if (modelTransform.id !== this._lastModelTransformId) {
            gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, modelTransform.getMatrix());
            this._lastModelTransformId = modelTransform.id;
        }

        if (this._uClippable) {
            gl.uniform1i(this._uClippable, object.modes.clippable);
        }

        if (geometry.combined) {
            var vertexBufs = object.vertexBufs;
            if (vertexBufs.id !== this._lastVertexBufsId) {
                if (vertexBufs.positionsBuf && this._aPosition) {
                    this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf, vertexBufs.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                this._lastVertexBufsId = vertexBufs.id;
            }
        }

        if (geometry.id !== this._lastGeometryId) {

            if (this._uPositionsDecodeMatrix) {
                gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometry.positionsDecodeMatrix);
            }

            if (geometry.combined) { // VBOs were bound by the preceding VertexBufs chunk
                if (geometry.indicesBufCombined) {
                    geometry.indicesBufCombined.bind();
                    frame.bindArray++;
                }
            } else {
                if (this._aPosition) {
                    this._aPosition.bindArrayBuffer(geometry.positionsBuf, geometry.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (geometry.indicesBuf) {
                    geometry.indicesBuf.bind();
                    frame.bindArray++;
                }
            }
            this._lastGeometryId = geometry.id;
        }

        if (geometry.combined) {
            if (geometry.indicesBufCombined) {
                gl.drawElements(geometry.primitive, geometry.indicesBufCombined.numItems, geometry.indicesBufCombined.itemType, 0);
                frame.drawElements++;
            } else {
                // TODO: drawArrays() with VertexBufs positions
            }
        } else {
            if (geometry.indicesBuf) {
                gl.drawElements(geometry.primitive, geometry.indicesBuf.numItems, geometry.indicesBuf.itemType, 0);
                frame.drawElements++;
            } else if (geometry.positions) {
                gl.drawArrays(gl.TRIANGLES, 0, geometry.positions.numItems);
                frame.drawArrays++;
            }
        }
    };
})();



;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.ShadowShaderSource = function (gl, scene, object) {
        var cfg = {
            clipping: scene.clips.clips.length > 0,
            quantizedGeometry: !!object.geometry.quantized
        };
        this.vertex = buildVertex(gl, cfg, scene, object);
        this.fragment = buildFragment(gl, cfg, scene, object);
    };

    function hasTextures(object) {
        if (!object.geometry.uv) {
            return false;
        }
        var material = object.material;
        return material.alphaMap;
    }
    
    function buildVertex(gl, cfg, scene, object) {

        var i;
        var len;
        var lights = scene.lights.lights;
        var light;
        var billboard = object.modes.billboard;

        var src = [];

        src.push("// Shadow drawing vertex shader");

        src.push("attribute vec3 position;");

        src.push("uniform mat4 modelMatrix;");
        src.push("uniform mat4 viewMatrix;");
        src.push("uniform mat4 projMatrix;");

        if (cfg.quantizedGeometry) {
            src.push("uniform mat4 positionsDecodeMatrix;");
        }

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
        }

        if (object.geometry.primitiveName === "points") {
            src.push("uniform float pointSize;");
        }

        if (billboard === "spherical" || billboard === "cylindrical") {
            src.push("void billboard(inout mat4 mat) {");
            src.push("   mat[0][0] = 1.0;");
            src.push("   mat[0][1] = 0.0;");
            src.push("   mat[0][2] = 0.0;");
            if (billboard === "spherical") {
                src.push("   mat[1][0] = 0.0;");
                src.push("   mat[1][1] = 1.0;");
                src.push("   mat[1][2] = 0.0;");
            }
            src.push("   mat[2][0] = 0.0;");
            src.push("   mat[2][1] = 0.0;");
            src.push("   mat[2][2] =1.0;");
            src.push("}");
        }

        src.push("void main(void) {");

        src.push("vec4 localPosition = vec4(position, 1.0); ");
        src.push("vec4 worldPosition;");

        if (cfg.quantizedGeometry) {
            src.push("localPosition = positionsDecodeMatrix * localPosition;");
        }

        src.push("mat4 viewMatrix2 = viewMatrix;");
        src.push("mat4 modelMatrix2 = modelMatrix;");

        if (object.modes.stationary) {
            src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")
        }

        if (billboard === "spherical" || billboard === "cylindrical") {

            src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
            src.push("billboard(modelMatrix2);");
            src.push("billboard(viewMatrix2);");
            src.push("billboard(modelViewMatrix);");

            if (cfg.normals) {
                src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");
                src.push("billboard(modelNormalMatrix2);");
                src.push("billboard(viewNormalMatrix2);");
                src.push("billboard(modelViewNormalMatrix);");
            }

            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition = modelViewMatrix * localPosition;");

        } else {
            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
        }

        if (cfg.clipping) {
            src.push("vWorldPosition = worldPosition;");
        }

        if (object.geometry.primitiveName === "points") {
            src.push("gl_PointSize = pointSize;");
        }

        src.push("   gl_Position = projMatrix * viewPosition;");

        src.push("}");

        return src;
    }

    function buildFragment(gl, cfg, scene, object) {

        var i;
        var src = [];

        src.push("// Shadow fragment shader");

        src.push("precision " + getFragmentFloatPrecision(gl) + " float;");

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
            src.push("uniform bool clippable;");
            for (i = 0; i < scene.clips.clips.length; i++) {
                src.push("uniform bool clipActive" + i + ";");
                src.push("uniform vec3 clipPos" + i + ";");
                src.push("uniform vec3 clipDir" + i + ";");
            }
        }
        src.push("vec4 packDepth (float depth) {");
        src.push("  const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);");
        src.push("  const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0);");
        src.push("  vec4 comp = fract(depth * bitShift);");
        src.push("  comp -= comp.gbaa * bitMask;");
        src.push("  return comp;");
        src.push("}");
        src.push("void main(void) {");
        if (cfg.clipping) {
            src.push("if (clippable) {");
            src.push("  float dist = 0.0;");
            for (i = 0; i < scene.clips.clips.length; i++) {
                src.push("if (clipActive" + i + ") {");
                src.push("   dist += clamp(dot(-clipDir" + i + ".xyz, vWorldPosition.xyz - clipPos" + i + ".xyz), 0.0, 1000.0);");
                src.push("}");
            }
            src.push("  if (dist > 0.0) { discard; }");
            if (cfg.solid) {
                src.push("  if (gl_FrontFacing == false) {");
                src.push("     gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);");
                src.push("     return;");
                src.push("  }");
            }
            src.push("}");
        }
        if (object.geometry.primitiveName === "points") {
            src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
            src.push("float r = dot(cxy, cxy);");
            src.push("if (r > 1.0) {");
            src.push("   discard;");
            src.push("}");

        }
        src.push("gl_FragColor = packDepth(gl_FragCoord.z);");
        src.push("}");
        return src;
    }

    function getFragmentFloatPrecision(gl) {
        if (!gl.getShaderPrecisionFormat) {
            return "mediump";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
            return "highp";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
            return "mediump";
        }
        return "lowp";
    }

})();;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    var ids = new xeogl.utils.Map({});

    xeogl.renderer.GhostFillRenderer = function (gl, hash, scene, object) {
        this._init(gl, hash, scene, object);
    };

    var ghostFillRenderers = {};

    xeogl.renderer.GhostFillRenderer.create = function (gl, hash, scene, object) {
        var renderer = ghostFillRenderers[hash];
        if (!renderer) {
            renderer = new xeogl.renderer.GhostFillRenderer(gl, hash, scene, object);
            ghostFillRenderers[hash] = renderer;
            xeogl.stats.memory.programs++;
        }
        renderer._useCount++;
        return renderer;
    };

    xeogl.renderer.GhostFillRenderer.prototype.destroy = function () {
        if (--this._useCount === 0) {
            ids.removeItem(this.id);
            this._program.destroy();
            delete ghostFillRenderers[this._hash];
            xeogl.stats.memory.programs--;
        }
    };

    xeogl.renderer.GhostFillRenderer.prototype._init = function (gl, hash, scene, object) {

        this.id = ids.addItem({});
        this._gl = gl;
        this._hash = hash;
        this._shaderSource = new xeogl.renderer.GhostFillShaderSource(gl, scene, object);
        this._program = new xeogl.renderer.Program(gl, this._shaderSource);
        this._scene = scene;
        this._useCount = 0;

        if (this._program.errors) {
            this.errors = this._program.errors;
            return;
        }

        var program = this._program;

        this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

        this._uModelMatrix = program.getLocation("modelMatrix");
        this._uModelNormalMatrix = program.getLocation("modelNormalMatrix");
        this._uViewMatrix = program.getLocation("viewMatrix");
        this._uViewNormalMatrix = program.getLocation("viewNormalMatrix");
        this._uProjMatrix = program.getLocation("projMatrix");

        this._uLightAmbient = [];
        this._uLightColor = [];
        this._uLightDir = [];
        this._uLightPos = [];
        this._uLightAttenuation = [];

        var lights = scene.lights.lights;
        var light;

        for (var i = 0, len = lights.length; i < len; i++) {
            light = lights[i];
            switch (light.type) {

                case "ambient":
                    this._uLightAmbient[i] = program.getLocation("lightAmbient");
                    break;

                case "dir":
                    this._uLightColor[i] = program.getLocation("lightColor" + i);
                    this._uLightPos[i] = null;
                    this._uLightDir[i] = program.getLocation("lightDir" + i);
                    break;

                case "point":
                    this._uLightColor[i] = program.getLocation("lightColor" + i);
                    this._uLightPos[i] = program.getLocation("lightPos" + i);
                    this._uLightDir[i] = null;
                    this._uLightAttenuation[i] = program.getLocation("lightAttenuation" + i);
                    break;
            }
        }

        this._uClips = [];
        var clips = scene.clips.clips;
        for (var i = 0, len = clips.length; i < len; i++) {
            this._uClips.push({
                active: program.getLocation("clipActive" + i),
                pos: program.getLocation("clipPos" + i),
                dir: program.getLocation("clipDir" + i)
            });
        }

        var material = object.material;

        this._uFillColor = program.getLocation("fillColor");

        this._aPosition = program.getAttribute("position");
        this._aNormal = program.getAttribute("normal");

        this._uClippable = program.getLocation("clippable");
        this._uGammaFactor = program.getLocation("gammaFactor");

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;
    };

    xeogl.renderer.GhostFillRenderer.prototype._bindProgram = function (frame) {

        var program = this._program;

        program.bind();

        frame.useProgram++;
        frame.textureUnit = 0;

        var gl = this._gl;
        var scene = this._scene;
        var lights = scene.lights;
        var light;

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;
        this._lastIndicesBufId = null;

        gl.uniformMatrix4fv(this._uViewMatrix, false, scene.viewTransform.matrix);
        gl.uniformMatrix4fv(this._uViewNormalMatrix, false, scene.viewTransform.normalMatrix);
        gl.uniformMatrix4fv(this._uProjMatrix, false, scene.projTransform.matrix);

        for (var i = 0, len = lights.lights.length; i < len; i++) {

            light = lights.lights[i];

            if (this._uLightAmbient[i]) {
                gl.uniform4f(this._uLightAmbient[i], light.color[0], light.color[1], light.color[2], light.intensity);

            } else {

                if (this._uLightColor[i]) {
                    gl.uniform4f(this._uLightColor[i], light.color[0], light.color[1], light.color[2], light.intensity);
                }

                if (this._uLightPos[i]) {
                    gl.uniform3fv(this._uLightPos[i], light.pos);
                    if (this._uLightAttenuation[i]) {
                        gl.uniform1f(this._uLightAttenuation[i], light.attenuation);
                    }
                }

                if (this._uLightDir[i]) {
                    gl.uniform3fv(this._uLightDir[i], light.dir);
                }
            }
        }

        if (scene.clips.clips.length > 0) {
            var clips = scene.clips.clips;
            var clipUniforms;
            var uClipActive;
            var clip;
            var uClipPos;
            var uClipDir;
            for (var i = 0, len = this._uClips.length; i < len; i++) {
                clipUniforms = this._uClips[i];
                uClipActive = clipUniforms.active;
                clip = clips[i];
                if (uClipActive) {
                    gl.uniform1i(uClipActive, clip.active);
                }
                uClipPos = clipUniforms.pos;
                if (uClipPos) {
                    gl.uniform3fv(clipUniforms.pos, clip.pos);
                }
                uClipDir = clipUniforms.dir;
                if (uClipDir) {
                    gl.uniform3fv(clipUniforms.dir, clip.dir);
                }
            }
        }

        if (this._uGammaFactor) {
            gl.uniform1f(this._uGammaFactor, scene.gammaFactor);
        }
    };

    xeogl.renderer.GhostFillRenderer.prototype.drawObject = function (frame, object, mode) {

        if (frame.lastProgramId !== this._program.id) {
            frame.lastProgramId = this._program.id;
            this._bindProgram(frame);
        }

        var gl = this._gl;
        var material = mode === 0 ? object.ghostMaterial : (mode === 1 ? object.highlightMaterial : object.selectedMaterial);
        var modelTransform = object.modelTransform;
        var geometry = object.geometry;

        if (material.id !== this._lastMaterialId) {
            var fillColor = material.fillColor;
            gl.uniform4f(this._uFillColor, fillColor[0], fillColor[1], fillColor[2], material.fillAlpha);
            this._lastMaterialId = material.id;
        }

        if (modelTransform.id !== this._lastModelTransformId) {
            gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, modelTransform.getMatrix());
            if (this._uModelNormalMatrix) {
                gl.uniformMatrix4fv(this._uModelNormalMatrix, gl.FALSE, modelTransform.getNormalMatrix());
            }
            this._lastModelTransformId = modelTransform.id;
        }

        var modes = object.modes;

        if (this._uClippable) {
            gl.uniform1i(this._uClippable, modes.clippable);
        }

        if (geometry.combined) {
            var vertexBufs = object.vertexBufs;
            if (vertexBufs.id !== this._lastVertexBufsId) {
                if (vertexBufs.positionsBuf && this._aPosition) {
                    this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf, vertexBufs.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (vertexBufs.normalsBuf && this._aNormal) {
                    this._aNormal.bindArrayBuffer(vertexBufs.normalsBuf, vertexBufs.quantized ? gl.BYTE : gl.FLOAT);
                    frame.bindArray++;
                }
                this._lastVertexBufsId = vertexBufs.id;
            }
        }

        // Bind VBOs

        if (geometry.id !== this._lastGeometryId) {

            if (this._uPositionsDecodeMatrix) {
                gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometry.positionsDecodeMatrix);
            }

            if (this._uUVDecodeMatrix) {
                gl.uniformMatrix3fv(this._uUVDecodeMatrix, false, geometry.uvDecodeMatrix);
            }

            if (geometry.combined) { // VBOs were bound by the VertexBufs logic above
                if (geometry.indicesBufCombined) {
                    geometry.indicesBufCombined.bind();
                    frame.bindArray++;
                }
            } else {
                if (this._aPosition) {
                    this._aPosition.bindArrayBuffer(geometry.positionsBuf, geometry.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (this._aNormal) {
                    this._aNormal.bindArrayBuffer(geometry.normalsBuf, geometry.quantized ? gl.BYTE : gl.FLOAT);
                    frame.bindArray++;
                }
                if (geometry.indicesBuf) {
                    geometry.indicesBuf.bind();
                    frame.bindArray++;
                    // gl.drawElements(geometry.primitive, geometry.indicesBuf.numItems, geometry.indicesBuf.itemType, 0);
                    // frame.drawElements++;
                } else if (geometry.positions) {
                    // gl.drawArrays(gl.TRIANGLES, 0, geometry.positions.numItems);
                    //  frame.drawArrays++;
                }
            }
            this._lastGeometryId = geometry.id;
        }

        // Draw (indices bound in prev step)

        if (geometry.combined) {
            if (geometry.indicesBufCombined) { // Geometry indices into portion of uber-array
                gl.drawElements(geometry.primitive, geometry.indicesBufCombined.numItems, geometry.indicesBufCombined.itemType, 0);
                frame.drawElements++;
            } else {
                // TODO: drawArrays() with VertexBufs positions
            }
        } else {
            if (geometry.indicesBuf) {
                gl.drawElements(geometry.primitive, geometry.indicesBuf.numItems, geometry.indicesBuf.itemType, 0);
                frame.drawElements++;
            } else if (geometry.positions) {
                gl.drawArrays(gl.TRIANGLES, 0, geometry.positions.numItems);
                frame.drawArrays++;
            }
        }
    };
})();
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.GhostFillShaderSource = function (gl, scene, object) {
        var cfg = {
            normals: hasNormals(object),
            clipping: scene.clips.clips.length > 0,
            quantizedGeometry: !!object.geometry.quantized,
            gammaOutput: scene.gammaOutput
        };
        this.vertex = buildVertex(gl, cfg, scene, object);
        this.fragment = buildFragment(gl, cfg, scene, object);
    };

    function hasNormals(object) {
        var primitive = object.geometry.primitiveName;
        if ((object.geometry.autoVertexNormals || object.geometry.normals) && (primitive === "triangles" || primitive === "triangle-strip" || primitive === "triangle-fan")) {
            return true;
        }
        return false;
    }
    
    function getFragmentFloatPrecision(gl) {
        if (!gl.getShaderPrecisionFormat) {
            return "mediump";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
            return "highp";
        }
        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
            return "mediump";
        }
        return "lowp";
    }

    function buildVertex(gl, cfg, scene, object) {

        var i;
        var len;
        var lights = scene.lights.lights;
        var light;
        var billboard = object.modes.billboard;

        var src = [];

        src.push("// Lambertian drawing vertex shader");

        src.push("attribute vec3 position;");

        src.push("uniform mat4 modelMatrix;");
        src.push("uniform mat4 viewMatrix;");
        src.push("uniform mat4 projMatrix;");
        src.push("uniform vec4 colorize;");

        if (cfg.quantizedGeometry) {
            src.push("uniform mat4 positionsDecodeMatrix;");
        }

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
        }

        src.push("uniform vec4   lightAmbient;");
        src.push("uniform vec4   fillColor;");

        if (cfg.normals) {

            src.push("attribute vec3 normal;");
            src.push("uniform mat4 modelNormalMatrix;");
            src.push("uniform mat4 viewNormalMatrix;");

            for (i = 0, len = lights.length; i < len; i++) {
                light = lights[i];

                if (light.type === "ambient") {
                    continue;
                }

                src.push("uniform vec4 lightColor" + i + ";");

                if (light.type === "dir") {
                    src.push("uniform vec3 lightDir" + i + ";");
                }
                if (light.type === "point") {
                    src.push("uniform vec3 lightPos" + i + ";");
                }
                if (light.type === "spot") {
                    src.push("uniform vec3 lightPos" + i + ";");
                }
            }

            if (cfg.quantizedGeometry) {
                src.push("vec3 octDecode(vec2 oct) {");
                src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
                src.push("    if (v.z < 0.0) {");
                src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
                src.push("    }");
                src.push("    return normalize(v);");
                src.push("}");
            }
        }

        src.push("varying vec4 vColor;");

        if (billboard === "spherical" || billboard === "cylindrical") {
            src.push("void billboard(inout mat4 mat) {");
            src.push("   mat[0][0] = 1.0;");
            src.push("   mat[0][1] = 0.0;");
            src.push("   mat[0][2] = 0.0;");
            if (billboard === "spherical") {
                src.push("   mat[1][0] = 0.0;");
                src.push("   mat[1][1] = 1.0;");
                src.push("   mat[1][2] = 0.0;");
            }
            src.push("   mat[2][0] = 0.0;");
            src.push("   mat[2][1] = 0.0;");
            src.push("   mat[2][2] =1.0;");
            src.push("}");
        }

        src.push("void main(void) {");

        src.push("vec4 localPosition = vec4(position, 1.0); ");
        src.push("vec4 worldPosition;");

        if (cfg.quantizedGeometry) {
            src.push("localPosition = positionsDecodeMatrix * localPosition;");
        }

        if (cfg.normals) {
            if (cfg.quantizedGeometry) {
                src.push("vec4 localNormal = vec4(octDecode(normal.xy), 0.0); ");
            } else {
                src.push("vec4 localNormal = vec4(normal, 0.0); ");
            }
            src.push("mat4 modelNormalMatrix2 = modelNormalMatrix;");
            src.push("mat4 viewNormalMatrix2 = viewNormalMatrix;");
        }

        src.push("mat4 viewMatrix2 = viewMatrix;");
        src.push("mat4 modelMatrix2 = modelMatrix;");

        if (object.modes.stationary) {
            src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")
        }

        if (billboard === "spherical" || billboard === "cylindrical") {

            src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
            src.push("billboard(modelMatrix2);");
            src.push("billboard(viewMatrix2);");
            src.push("billboard(modelViewMatrix);");

            if (cfg.normals) {
                src.push("mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;");
                src.push("billboard(modelNormalMatrix2);");
                src.push("billboard(viewNormalMatrix2);");
                src.push("billboard(modelViewNormalMatrix);");
            }

            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition = modelViewMatrix * localPosition;");

        } else {
            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
        }

        if (cfg.normals) {
            src.push("vec3 viewNormal = normalize((viewNormalMatrix2 * modelNormalMatrix2 * localNormal).xyz);");
        }

        src.push("vec3 reflectedColor = vec3(0.0, 0.0, 0.0);");
        src.push("vec3 viewLightDir = vec3(0.0, 0.0, -1.0);");
        src.push("float lambertian = 1.0;");

        if (cfg.normals) {
            for (i = 0, len = lights.length; i < len; i++) {

                light = lights[i];

                if (light.type === "ambient") {
                    continue;
                }

                if (light.type === "dir") {
                    if (light.space === "view") {
                        src.push("viewLightDir = normalize(lightDir" + i + ");");
                    } else {
                        src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightDir" + i + ", 0.0)).xyz);");
                    }
                } else if (light.type === "point") {
                    if (light.space === "view") {
                        src.push("viewLightDir = normalize(lightPos" + i + " - viewPosition.xyz);");
                    } else {
                        src.push("viewLightDir = normalize((viewMatrix2 * vec4(lightPos" + i + ", 0.0)).xyz);");
                    }
                } else {
                    continue;
                }

                src.push("lambertian = max(dot(-viewNormal, viewLightDir), 0.0);");
                src.push("reflectedColor += lambertian * (lightColor" + i + ".rgb * lightColor" + i + ".a);");
            }
        }

        // TODO: A blending mode for emphasis materials, to select add/multiply/mix

        //src.push("vColor = vec4((mix(reflectedColor, fillColor.rgb, 0.7)), fillColor.a);");
        src.push("vColor = vec4(reflectedColor * fillColor.rgb, fillColor.a);");
        //src.push("vColor = vec4(reflectedColor + fillColor.rgb, fillColor.a);");

        if (cfg.clipping) {
            src.push("vWorldPosition = worldPosition;");
        }

        if (object.geometry.primitiveName === "points") {
            src.push("gl_PointSize = pointSize;");
        }

        src.push("   gl_Position = projMatrix * viewPosition;");

        src.push("}");

        return src;
    }

    function buildFragment(gl, cfg, scene, object) {

        var i;
        var len;
        var src = [];

        src.push("// Lambertian drawing fragment shader");

        //src.push("precision " + getFragmentFloatPrecision(gl) + " float;");
        src.push("precision lowp float;");

        if (cfg.gammaOutput) {
            src.push("uniform float gammaFactor;");
            src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
            src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
            src.push("}");
        }

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
            src.push("uniform bool clippable;");
            for (i = 0; i < scene.clips.clips.length; i++) {
                src.push("uniform bool clipActive" + i + ";");
                src.push("uniform vec3 clipPos" + i + ";");
                src.push("uniform vec3 clipDir" + i + ";");
            }
        }
        src.push("varying vec4 vColor;");
        src.push("void main(void) {");
        if (cfg.clipping) {
            src.push("if (clippable) {");
            src.push("  float dist = 0.0;");
            for (i = 0; i < scene.clips.clips.length; i++) {
                src.push("if (clipActive" + i + ") {");
                src.push("   dist += clamp(dot(-clipDir" + i + ".xyz, vWorldPosition.xyz - clipPos" + i + ".xyz), 0.0, 1000.0);");
                src.push("}");
            }
            src.push("  if (dist > 0.0) { discard; }");
            src.push("}");
        }
        if (object.geometry.primitiveName === "points") {
            src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
            src.push("float r = dot(cxy, cxy);");
            src.push("if (r > 1.0) {");
            src.push("   discard;");
            src.push("}");
        }
        src.push("gl_FragColor = vColor;");

        if (cfg.gammaOutput) {
            src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);");
        } else {
            src.push("gl_FragColor = vColor;");
        }

        src.push("}");
        return src;
    }

})();;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    var ids = new xeogl.utils.Map({});

    xeogl.renderer.GhostVerticesRenderer = function (gl, hash, scene, object) {
        this._init(gl, hash, scene, object);
    };

    var ghostVerticesRenderers = {};

    xeogl.renderer.GhostVerticesRenderer.create = function (gl, hash, scene, object) {
        var renderer = ghostVerticesRenderers[hash];
        if (!renderer) {
            renderer = new xeogl.renderer.GhostVerticesRenderer(gl, hash, scene, object);
            ghostVerticesRenderers[hash] = renderer;
            xeogl.stats.memory.programs++;
        }
        renderer._useCount++;
        return renderer;
    };

    xeogl.renderer.GhostVerticesRenderer.prototype.destroy = function () {
        if (--this._useCount === 0) {
            ids.removeItem(this.id);
            this._program.destroy();
            delete ghostVerticesRenderers[this._hash];
            xeogl.stats.memory.programs--;
        }
    };

    xeogl.renderer.GhostVerticesRenderer.prototype._init = function (gl, hash, scene, object) {

        this.id = ids.addItem({});
        this._gl = gl;
        this._hash = hash;
        this._shaderSource = new xeogl.renderer.GhostVerticesShaderSource(gl, scene, object);
        this._program = new xeogl.renderer.Program(gl, this._shaderSource);
        this._scene = scene;
        this._useCount = 0;

        if (this._program.errors) {
            this.errors = this._program.errors;
            return;
        }

        var program = this._program;

        this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

        this._uModelMatrix = program.getLocation("modelMatrix");
        this._uViewMatrix = program.getLocation("viewMatrix");
        this._uProjMatrix = program.getLocation("projMatrix");

        this._uClips = [];

        var clips = scene.clips.clips;
        for (var i = 0, len = clips.length; i < len; i++) {
            this._uClips.push({
                active: program.getLocation("clipActive" + i),
                pos: program.getLocation("clipPos" + i),
                dir: program.getLocation("clipDir" + i)
            });
        }

        this._uVertexColor = program.getLocation("vertexColor");
        this._uVertexSize = program.getLocation("vertexSize");
        this._aPosition = program.getAttribute("position");
        this._aNormal = program.getAttribute("normal");
        this._uClippable = program.getLocation("clippable");
        this._uGammaFactor = program.getLocation("gammaFactor");

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;
    };

    xeogl.renderer.GhostVerticesRenderer.prototype._bindProgram = function (frame) {

        var program = this._program;

        program.bind();

        frame.useProgram++;
        frame.textureUnit = 0;

        var gl = this._gl;
        var scene = this._scene;

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;

        gl.uniformMatrix4fv(this._uViewMatrix, false, scene.viewTransform.matrix);
        gl.uniformMatrix4fv(this._uProjMatrix, false, scene.projTransform.matrix);

        if (scene.clips.clips.length > 0) {
            var clips = scene.clips.clips;
            var clipUniforms;
            var uClipActive;
            var clip;
            var uClipPos;
            var uClipDir;
            for (var i = 0, len = this._uClips.length; i < len; i++) {
                clipUniforms = this._uClips[i];
                uClipActive = clipUniforms.active;
                clip = clips[i];
                if (uClipActive) {
                    gl.uniform1i(uClipActive, clip.active);
                }
                uClipPos = clipUniforms.pos;
                if (uClipPos) {
                    gl.uniform3fv(clipUniforms.pos, clip.pos);
                }
                uClipDir = clipUniforms.dir;
                if (uClipDir) {
                    gl.uniform3fv(clipUniforms.dir, clip.dir);
                }
            }
        }

        if (this._uGammaFactor) {
            gl.uniform1f(this._uGammaFactor, scene.gammaFactor);
        }
    };

    xeogl.renderer.GhostVerticesRenderer.prototype.drawObject = function (frame, object, mode) {

        if (frame.lastProgramId !== this._program.id) {
            frame.lastProgramId = this._program.id;
            this._bindProgram(frame);
        }

        var gl = this._gl;
        var material = mode === 0 ? object.ghostMaterial : (mode === 1 ? object.highlightMaterial : object.selectedMaterial);
        var modelTransform = object.modelTransform;
        var geometry = object.geometry;

        if (material.id !== this._lastMaterialId) {
            if (this._uVertexSize) { // TODO: cache
                gl.uniform1f(this._uVertexSize, material.vertexSize);
            }
            if (this._uVertexColor) {
                var vertexColor = material.vertexColor;
                var vertexAlpha = material.vertexAlpha;
                gl.uniform4f(this._uVertexColor, vertexColor[0], vertexColor[1], vertexColor[2], vertexAlpha);
            }
            this._lastMaterialId = material.id;
        }

        if (modelTransform.id !== this._lastModelTransformId) {
            gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, modelTransform.getMatrix());
            if (this._uModelNormalMatrix) {
                gl.uniformMatrix4fv(this._uModelNormalMatrix, gl.FALSE, modelTransform.getNormalMatrix());
            }
            this._lastModelTransformId = modelTransform.id;
        }

        var modes = object.modes;

        if (this._uClippable) {
            gl.uniform1i(this._uClippable, modes.clippable);
        }

        if (geometry.combined) {
            var vertexBufs = object.vertexBufs;
            if (vertexBufs.id !== this._lastVertexBufsId) {
                if (vertexBufs.positionsBuf && this._aPosition) {
                    this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf, vertexBufs.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (vertexBufs.normalsBuf && this._aNormal) {
                    this._aNormal.bindArrayBuffer(vertexBufs.normalsBuf, vertexBufs.quantized ? gl.BYTE : gl.FLOAT);
                    frame.bindArray++;
                }
                this._lastVertexBufsId = vertexBufs.id;
            }
        }

        // Bind VBOs

        if (geometry.id !== this._lastGeometryId) {

            if (this._uPositionsDecodeMatrix) {
                gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometry.positionsDecodeMatrix);
            }

            if (geometry.combined) { // VBOs were bound by the VertexBufs logic above
                if (geometry.indicesBufCombined) {
                    geometry.indicesBufCombined.bind();
                    frame.bindArray++;
                }
            } else {

                if (this._aPosition) {
                    this._aPosition.bindArrayBuffer(geometry.positionsBuf, geometry.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }

                if (this._aNormal) {
                    this._aNormal.bindArrayBuffer(geometry.normalsBuf, geometry.quantized ? gl.BYTE : gl.FLOAT);
                    frame.bindArray++;
                }

                if (geometry.indicesBuf) {
                    geometry.indicesBuf.bind();
                    frame.bindArray++;
                    // gl.drawElements(geometry.primitive, geometry.indicesBuf.numItems, geometry.indicesBuf.itemType, 0);
                    // frame.drawElements++;
                } else if (geometry.positions) {
                    // gl.drawArrays(gl.TRIANGLES, 0, geometry.positions.numItems);
                    //  frame.drawArrays++;
                }
            }
            this._lastGeometryId = geometry.id;
        }

        // Draw (indices bound in prev step)

        if (geometry.combined) {
            if (geometry.indicesBufCombined) { // Geometry indices into portion of uber-array
                gl.drawElements(gl.POINTS, geometry.indicesBufCombined.numItems, geometry.indicesBufCombined.itemType, 0);
                frame.drawElements++;
            } else {
                // TODO: drawArrays() with VertexBufs positions
            }
        } else {
            if (geometry.indicesBuf) {
                gl.drawElements(gl.POINTS, geometry.indicesBuf.numItems, geometry.indicesBuf.itemType, 0);
                frame.drawElements++;
            } else if (geometry.positions) {
                gl.drawArrays(gl.POINTS, 0, geometry.positions.numItems);
                frame.drawArrays++;
            }
        }
    };
})();
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.GhostVerticesShaderSource = function (gl, scene, object) {
        var cfg = {
            normals: hasNormals(object),
            clipping: scene.clips.clips.length > 0,
            quantizedGeometry: !!object.geometry.quantized,
            gammaOutput: scene.gammaOutput
        };
        this.vertex = buildVertex(gl, cfg, scene, object);
        this.fragment = buildFragment(gl, cfg, scene, object);
    };

    function hasNormals(object) {
        var primitive = object.geometry.primitiveName;
        if ((object.geometry.autoVertexNormals || object.geometry.normals) && (primitive === "triangles" || primitive === "triangle-strip" || primitive === "triangle-fan")) {
            return true;
        }
        return false;
    }

    function buildVertex(gl, cfg, scene, object) {

        var billboard = object.modes.billboard;

        var src = [];

        src.push("// Vertices drawing vertex shader");

        src.push("attribute vec3 position;");

        src.push("uniform mat4 modelMatrix;");
        src.push("uniform mat4 viewMatrix;");
        src.push("uniform mat4 projMatrix;");
        src.push("uniform vec4 vertexColor;");
        src.push("uniform float vertexSize;");

        if (cfg.quantizedGeometry) {
            src.push("uniform mat4 positionsDecodeMatrix;");
        }

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
        }

        if (cfg.normals) {
            src.push("attribute vec3 normal;");
            if (cfg.quantizedGeometry) {
                src.push("vec3 octDecode(vec2 oct) {");
                src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
                src.push("    if (v.z < 0.0) {");
                src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
                src.push("    }");
                src.push("    return normalize(v);");
                src.push("}");
            }
        }

        src.push("varying vec4 vColor;");

        if (billboard === "spherical" || billboard === "cylindrical") {
            src.push("void billboard(inout mat4 mat) {");
            src.push("   mat[0][0] = 1.0;");
            src.push("   mat[0][1] = 0.0;");
            src.push("   mat[0][2] = 0.0;");
            if (billboard === "spherical") {
                src.push("   mat[1][0] = 0.0;");
                src.push("   mat[1][1] = 1.0;");
                src.push("   mat[1][2] = 0.0;");
            }
            src.push("   mat[2][0] = 0.0;");
            src.push("   mat[2][1] = 0.0;");
            src.push("   mat[2][2] =1.0;");
            src.push("}");
        }

        src.push("void main(void) {");

        src.push("vec4 localPosition = vec4(position, 1.0); ");
        src.push("vec4 worldPosition;");

        if (cfg.quantizedGeometry) {
            src.push("localPosition = positionsDecodeMatrix * localPosition;");
        }

        if (cfg.normals) {
            if (cfg.quantizedGeometry) {
                src.push("vec3 localNormal = octDecode(normal.xy); ");
            } else {
                src.push("vec3 localNormal = normal; ");
            }
       //     src.push("localPosition.xyz +=  localNormal * 0.09; ");
        }

        src.push("mat4 viewMatrix2 = viewMatrix;");
        src.push("mat4 modelMatrix2 = modelMatrix;");

        if (object.modes.stationary) {
            src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")
        }

        if (billboard === "spherical" || billboard === "cylindrical") {
            src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
            src.push("billboard(modelMatrix2);");
            src.push("billboard(viewMatrix2);");
            src.push("billboard(modelViewMatrix);");
            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition = modelViewMatrix * (localPosition + normal);");
        } else {
            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
        }

        src.push("vColor = vertexColor;");

        src.push("gl_PointSize = vertexSize;");

        if (cfg.clipping) {
            src.push("vWorldPosition = worldPosition;");
        }

        src.push("   gl_Position = projMatrix * viewPosition;");

        src.push("}");

        return src;
    }

    function buildFragment(gl, cfg, scene, object) {

        var i;
        var len;
        var src = [];

        src.push("// Vertices drawing fragment shader");

        src.push("precision lowp float;");

        if (cfg.gammaOutput) {
            src.push("uniform float gammaFactor;");
            src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
            src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
            src.push("}");
        }

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
            src.push("uniform bool clippable;");
            for (i = 0; i < scene.clips.clips.length; i++) {
                src.push("uniform bool clipActive" + i + ";");
                src.push("uniform vec3 clipPos" + i + ";");
                src.push("uniform vec3 clipDir" + i + ";");
            }
        }
        src.push("varying vec4 vColor;");
        src.push("void main(void) {");
        if (cfg.clipping) {
            src.push("if (clippable) {");
            src.push("  float dist = 0.0;");
            for (i = 0; i < scene.clips.clips.length; i++) {
                src.push("if (clipActive" + i + ") {");
                src.push("   dist += clamp(dot(-clipDir" + i + ".xyz, vWorldPosition.xyz - clipPos" + i + ".xyz), 0.0, 1000.0);");
                src.push("}");
            }
            src.push("  if (dist > 0.0) { discard; }");
            src.push("}");
        }
        //if (roundPoints) {
        src.push("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
        src.push("float r = dot(cxy, cxy);");
        src.push("if (r > 1.0) {");
        src.push("   discard;");
        src.push("}");
        //}
        src.push("gl_FragColor = vColor;");
        if (cfg.gammaOutput) {
            src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);");
        } else {
            src.push("gl_FragColor = vColor;");
        }
        src.push("}");
        return src;
    }

})();;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    var ids = new xeogl.utils.Map({});

    xeogl.renderer.GhostEdgesRenderer = function (gl, hash, scene, object) {
        this._init(gl, hash, scene, object);
    };

    var ghostEdgesRenderers = {};

    xeogl.renderer.GhostEdgesRenderer.create = function (gl, hash, scene, object) {
        var renderer = ghostEdgesRenderers[hash];
        if (!renderer) {
            renderer = new xeogl.renderer.GhostEdgesRenderer(gl, hash, scene, object);
            ghostEdgesRenderers[hash] = renderer;
            xeogl.stats.memory.programs++;
        }
        renderer._useCount++;
        return renderer;
    };

    xeogl.renderer.GhostEdgesRenderer.prototype.destroy = function () {
        if (--this._useCount === 0) {
            ids.removeItem(this.id);
            this._program.destroy();
            delete ghostEdgesRenderers[this._hash];
            xeogl.stats.memory.programs--;
        }
    };

    xeogl.renderer.GhostEdgesRenderer.prototype._init = function (gl, hash, scene, object) {

        this.id = ids.addItem({});
        this._gl = gl;
        this._hash = hash;
        this._shaderSource = new xeogl.renderer.GhostEdgesShaderSource(gl, scene, object);
        this._program = new xeogl.renderer.Program(gl, this._shaderSource);
        this._scene = scene;
        this._useCount = 0;

        if (this._program.errors) {
            this.errors = this._program.errors;
            return;
        }

        var program = this._program;

        this._uPositionsDecodeMatrix = program.getLocation("positionsDecodeMatrix");

        this._uModelMatrix = program.getLocation("modelMatrix");
        this._uViewMatrix = program.getLocation("viewMatrix");
        this._uProjMatrix = program.getLocation("projMatrix");

        this._uClips = [];

        var clips = scene.clips.clips;
        for (var i = 0, len = clips.length; i < len; i++) {
            this._uClips.push({
                active: program.getLocation("clipActive" + i),
                pos: program.getLocation("clipPos" + i),
                dir: program.getLocation("clipDir" + i)
            });
        }

        this._uEdgeColor = program.getLocation("edgeColor");
        this._aPosition = program.getAttribute("position");
        this._aNormal = program.getAttribute("normal");
        this._uClippable = program.getLocation("clippable");
        this._uGammaFactor = program.getLocation("gammaFactor");

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;
    };

    xeogl.renderer.GhostEdgesRenderer.prototype._bindProgram = function (frame) {

        var program = this._program;

        program.bind();

        frame.useProgram++;

        var gl = this._gl;
        var scene = this._scene;

        this._lastMaterialId = null;
        this._lastModelTransformId = null;
        this._lastVertexBufsId = null;
        this._lastGeometryId = null;

        gl.uniformMatrix4fv(this._uViewMatrix, false, scene.viewTransform.matrix);
        gl.uniformMatrix4fv(this._uProjMatrix, false, scene.projTransform.matrix);

        if (scene.clips.clips.length > 0) {
            var clips = scene.clips.clips;
            var clipUniforms;
            var uClipActive;
            var clip;
            var uClipPos;
            var uClipDir;
            for (var i = 0, len = this._uClips.length; i < len; i++) {
                clipUniforms = this._uClips[i];
                uClipActive = clipUniforms.active;
                clip = clips[i];
                if (uClipActive) {
                    gl.uniform1i(uClipActive, clip.active);
                }
                uClipPos = clipUniforms.pos;
                if (uClipPos) {
                    gl.uniform3fv(clipUniforms.pos, clip.pos);
                }
                uClipDir = clipUniforms.dir;
                if (uClipDir) {
                    gl.uniform3fv(clipUniforms.dir, clip.dir);
                }
            }
        }

        if (this._uGammaFactor) {
            gl.uniform1f(this._uGammaFactor, scene.gammaFactor);
        }
    };

    xeogl.renderer.GhostEdgesRenderer.prototype.drawObject = function (frame, object, mode) {

        if (frame.lastProgramId !== this._program.id) {
            frame.lastProgramId = this._program.id;
            this._bindProgram(frame);
        }

        var gl = this._gl;
        var material = mode === 0 ? object.ghostMaterial : (mode === 1 ? object.highlightMaterial : object.selectedMaterial);
        var modelTransform = object.modelTransform;
        var geometry = object.geometry;

        if (material.id !== this._lastMaterialId) {

            if (frame.lineWidth !== material.edgeWidth) {
                gl.lineWidth(material.edgeWidth);
                frame.lineWidth = material.edgeWidth;
            }

            if (this._uEdgeColor) {
                var edgeColor = material.edgeColor;
                var edgeAlpha = material.edgeAlpha;
                gl.uniform4f(this._uEdgeColor, edgeColor[0], edgeColor[1], edgeColor[2], edgeAlpha);
            }

            this._lastMaterialId = material.id;
        }

        if (modelTransform.id !== this._lastModelTransformId) {
            gl.uniformMatrix4fv(this._uModelMatrix, gl.FALSE, modelTransform.getMatrix());
            if (this._uModelNormalMatrix) {
                gl.uniformMatrix4fv(this._uModelNormalMatrix, gl.FALSE, modelTransform.getNormalMatrix());
            }
            this._lastModelTransformId = modelTransform.id;
        }

        var modes = object.modes;

        if (this._uClippable) {
            gl.uniform1i(this._uClippable, modes.clippable);
        }

        if (geometry.combined) {
            var vertexBufs = object.vertexBufs;
            if (vertexBufs.id !== this._lastVertexBufsId) {
                if (vertexBufs.positionsBuf && this._aPosition) {
                    this._aPosition.bindArrayBuffer(vertexBufs.positionsBuf, vertexBufs.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                    frame.bindArray++;
                }
                if (vertexBufs.normalsBuf && this._aNormal) {
                    this._aNormal.bindArrayBuffer(vertexBufs.normalsBuf, vertexBufs.quantized ? gl.BYTE : gl.FLOAT);
                    frame.bindArray++;
                }
                this._lastVertexBufsId = vertexBufs.id;
            }
        }

        // Bind VBOs

        var indicesBuf;

        if (geometry.primitive === gl.TRIANGLES) {
            indicesBuf = geometry.getGhostEdgesIndices();
        } else if (geometry.primitive === gl.LINES) {
            indicesBuf = geometry.indicesBuf;
        }

        if (indicesBuf) {

            if (geometry.id !== this._lastGeometryId) {

                if (this._uPositionsDecodeMatrix) {
                    gl.uniformMatrix4fv(this._uPositionsDecodeMatrix, false, geometry.positionsDecodeMatrix);
                }

                if (!geometry.combined) { // VBOs were bound by the VertexBufs logic above
                    if (this._aPosition) {
                        this._aPosition.bindArrayBuffer(geometry.positionsBuf, geometry.quantized ? gl.UNSIGNED_SHORT : gl.FLOAT);
                        frame.bindArray++;
                    }
                    if (this._aNormal) {
                        this._aNormal.bindArrayBuffer(geometry.normalsBuf, geometry.quantized ? gl.BYTE : gl.FLOAT);
                        frame.bindArray++;
                    }
                }

                indicesBuf.bind();
                frame.bindArray++;

                this._lastGeometryId = geometry.id;
            }

            gl.drawElements(gl.LINES, indicesBuf.numItems, indicesBuf.itemType, 0);
            frame.drawElements++;
        }
    };
})();
;/**
 * @author xeolabs / https://github.com/xeolabs
 */

(function () {

    "use strict";

    xeogl.renderer.GhostEdgesShaderSource = function (gl, scene, object) {
        var cfg = {
            normals: hasNormals(object),
            clipping: scene.clips.clips.length > 0,
            quantizedGeometry: !!object.geometry.quantized,
            gammaOutput: scene.gammaOutput
        };
        this.vertex =  buildVertex(gl, cfg, scene, object);
        this.fragment = buildFragment(gl, cfg, scene, object);
    };

    function hasNormals(object) {
        var primitive = object.geometry.primitiveName;
        if ((object.geometry.autoVertexNormals || object.geometry.normals) && (primitive === "triangles" || primitive === "triangle-strip" || primitive === "triangle-fan")) {
            return true;
        }
        return false;
    }

    function buildVertex(gl, cfg, scene, object) {

        var billboard = object.modes.billboard;

        var src = [];

        src.push("// Edges drawing vertex shader");

        src.push("attribute vec3 position;");

        src.push("uniform mat4 modelMatrix;");
        src.push("uniform mat4 viewMatrix;");
        src.push("uniform mat4 projMatrix;");

        src.push("uniform vec4 edgeColor;");

        if (cfg.quantizedGeometry) {
            src.push("uniform mat4 positionsDecodeMatrix;");
        }

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
        }

        if (cfg.normals) {
            src.push("attribute vec3 normal;");
            if (cfg.quantizedGeometry) {
                src.push("vec3 octDecode(vec2 oct) {");
                src.push("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
                src.push("    if (v.z < 0.0) {");
                src.push("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
                src.push("    }");
                src.push("    return normalize(v);");
                src.push("}");
            }
        }

        src.push("varying vec4 vColor;");

        if (billboard === "spherical" || billboard === "cylindrical") {
            src.push("void billboard(inout mat4 mat) {");
            src.push("   mat[0][0] = 1.0;");
            src.push("   mat[0][1] = 0.0;");
            src.push("   mat[0][2] = 0.0;");
            if (billboard === "spherical") {
                src.push("   mat[1][0] = 0.0;");
                src.push("   mat[1][1] = 1.0;");
                src.push("   mat[1][2] = 0.0;");
            }
            src.push("   mat[2][0] = 0.0;");
            src.push("   mat[2][1] = 0.0;");
            src.push("   mat[2][2] =1.0;");
            src.push("}");
        }

        src.push("void main(void) {");

        src.push("vec4 localPosition = vec4(position, 1.0); ");
        src.push("vec4 worldPosition;");

        if (cfg.quantizedGeometry) {
            src.push("localPosition = positionsDecodeMatrix * localPosition;");
        }

        if (cfg.normals) {
            if (cfg.quantizedGeometry) {
                src.push("vec3 localNormal = octDecode(normal.xy); ");
            } else {
                src.push("vec3 localNormal = normal; ");
            }
            //src.push("localPosition.xyz +=  localNormal * 0.01; ");
        }

        src.push("mat4 viewMatrix2 = viewMatrix;");
        src.push("mat4 modelMatrix2 = modelMatrix;");

        if (object.modes.stationary) {
            src.push("viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;")
        }

        if (billboard === "spherical" || billboard === "cylindrical") {

            src.push("mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;");
            src.push("billboard(modelMatrix2);");
            src.push("billboard(viewMatrix2);");
            src.push("billboard(modelViewMatrix);");
            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition = modelViewMatrix * localPosition;");

        } else {
            src.push("worldPosition = modelMatrix2 * localPosition;");
            src.push("vec4 viewPosition  = viewMatrix2 * worldPosition; ");
        }

        src.push("vColor = edgeColor;");

        if (cfg.clipping) {
            src.push("vWorldPosition = worldPosition;");
        }
        
        src.push("   gl_Position = projMatrix * viewPosition;");

        src.push("}");

        return src;
    }

    function buildFragment(gl, cfg, scene, object) {

        var i;
        var len;
        var src = [];

        src.push("// Edges drawing fragment shader");

        src.push("precision lowp float;");

        if (cfg.gammaOutput) {
            src.push("uniform float gammaFactor;");
            src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
            src.push("  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
            src.push("}");
        }

        if (cfg.clipping) {
            src.push("varying vec4 vWorldPosition;");
            src.push("uniform bool clippable;");
            for (i = 0; i < scene.clips.clips.length; i++) {
                src.push("uniform bool clipActive" + i + ";");
                src.push("uniform vec3 clipPos" + i + ";");
                src.push("uniform vec3 clipDir" + i + ";");
            }
        }
        src.push("varying vec4 vColor;");
        src.push("void main(void) {");
        if (cfg.clipping) {
            src.push("if (clippable) {");
            src.push("  float dist = 0.0;");
            for (i = 0; i < scene.clips.clips.length; i++) {
                src.push("if (clipActive" + i + ") {");
                src.push("   dist += clamp(dot(-clipDir" + i + ".xyz, vWorldPosition.xyz - clipPos" + i + ".xyz), 0.0, 1000.0);");
                src.push("}");
            }
            src.push("  if (dist > 0.0) { discard; }");
            src.push("}");
        }
        src.push("gl_FragColor = vColor;");

        if (cfg.gammaOutput) {
            src.push("gl_FragColor = linearToGamma(vColor, gammaFactor);");
        } else {
            src.push("gl_FragColor = vColor;");
        }

        src.push("}");
        return src;
    }

})();;/**
 The **Component** class is the base class for all xeogl components.

 ## Usage

 * [Component IDs](#component-ids)
 * [Metadata](#metadata)
 * [Logging](#logging)
 * [Destruction](#destruction)
 * [Creating custom Components](#creating-custom-components)

 ### Component IDs

 Every Component has an ID that's unique within the parent {{#crossLink "Scene"}}{{/crossLink}}. xeogl generates
 the IDs automatically by default, however you can also specify them yourself. In the example below, we're creating a
 scene comprised of {{#crossLink "Scene"}}{{/crossLink}}, {{#crossLink "Material"}}{{/crossLink}}, {{#crossLink "Geometry"}}{{/crossLink}} and
 {{#crossLink "Entity"}}{{/crossLink}} components, while letting xeogl generate its own ID for
 the {{#crossLink "Geometry"}}{{/crossLink}}:

 ````javascript
 // The Scene is a Component too
 var scene = new xeogl.Scene({
    id: "myScene"
 });

 var material = new xeogl.PhongMaterial(scene, {
    id: "myMaterial"
 });

 var geometry = new xeogl.Geometry(scene, {
    id: "myGeometry"
 });

 // Let xeogl automatically generate the ID for our Entity
 var entity = new xeogl.Entity(scene, {
    material: material,
    geometry: geometry
 });
 ````

 We can then find those components like this:

 ````javascript
 // Find the Scene
 var theScene = xeogl.scenes["myScene"];

 // Find the Material
 var theMaterial = theScene.components["myMaterial"];

 // Find all PhongMaterials in the Scene
 var phongMaterials = theScene.types["xeogl.PhongMaterial"];

 // Find our Material within the PhongMaterials
 var theMaterial = phongMaterials["myMaterial"];
 ````

 ### Component inheritance


 TODO

 All xeogl components extend the Component base type. Each component

 For example, if this component is a {{#crossLink "Rotate"}}{{/crossLink}}, which
 extends {{#crossLink "Transform"}}{{/crossLink}}, which in turn extends {{#crossLink "Component"}}{{/crossLink}},
 then this property will have the value:

 ````json
 ["xeogl.Component", "xeogl.Transform"]
 ````

 TODO

 ````javascript
 // Evaluates true:
 var isComponent = theMaterial.isType("xeogl.Component");

 // Evaluates true:
 var isMaterial = theMaterial.isType("xeogl.Material");

 // Evaluates true:
 var isPhongMaterial = theMaterial.isType("xeogl.PhongMaterial");

 // Evaluates false:
 var isMetallicMaterial = theMaterial.isType("xeogl.MetallicMaterial");
 ````
 Note that the chain is ordered downwards in the hierarchy, ie. from super-class down towards sub-class.

 ### Metadata

 You can set optional **metadata** on your Components, which can be anything you like. These are intended
 to help manage your components within your application code or content pipeline. You could use metadata to attach
 authoring or version information, like this:

 ````javascript
 // Scene with authoring metadata
 var scene = new xeogl.Scene({
    id: "myScene",
    meta: {
        title: "My bodacious 3D scene",
        author: "@xeographics",
        date: "February 30 2018"
    }
 });

 // Material with descriptive metadata
 var material = new xeogl.PhongMaterial(scene, {
    id: "myMaterial",
    diffuse: [1, 0, 0],
    meta: {
        description: "Bright red color with no textures",
        version: "0.1",
        foo: "bar"
    }
 });
 ````

 ### Logging

 Components have methods to log ID-prefixed messages to the JavaScript console:

 ````javascript
 material.log("Everything is fine, situation normal.");
 material.warn("Wait, whats that red light?");
 material.error("Aw, snap!");
 ````

 The logged messages will look like this in the console:

 ````text
 [LOG]   myMaterial: Everything is fine, situation normal.
 [WARN]  myMaterial: Wait, whats that red light..
 [ERROR] myMaterial: Aw, snap!
 ````

 ### Destruction

 Get notification of destruction directly on the Components:

 ````javascript
 material.on("destroyed", function() {
    this.log("Component was destroyed: " + this.id);
 });
 ````

 Or get notification of destruction of any Component within its {{#crossLink "Scene"}}{{/crossLink}}, indiscriminately:

 ````javascript
 scene.on("componentDestroyed", function(component) {
    this.log("Component was destroyed: " + component.id);
 });
 ````

 Then destroy a component like this:

 ````javascript
 material.destroy();
 ````

 ### Creating custom Components

 Subclassing a Component to create a new ````xeogl.ColoredTorus```` type:

 ````javascript
 xeogl.ColoredTorus = xeogl.Component.extend({

     type: "xeogl.ColoredTorus",

     _init: function (cfg) { // Constructor

         this._torus = new xeogl.Entity({
             geometry: new xeogl.TorusGeometry({radius: 2, tube: .6}),
             material: new xeogl.MetallicMaterial({
                 baseColor: [1.0, 0.5, 0.5],
                 roughness: 0.4,
                 metallic: 0.1
             })
         });

         this.color = cfg.color;
     },

     _props: {

         // The color of this ColoredTorus.
         color: {
             set: function (color) {
                 this._torus.material.baseColor = color;
             },
             get: function () {
                 return this._torus.material.baseColor;
             }
         }
     },

     _destroy: function () {
         this._torus.geometry.destroy();
         this._torus.material.destroy();
         this._torus.destroy();
     }
 });
 ````

 #### Examples

 * [Custom component definition](../../examples/#extending_component_basic)
 * [Custom component that fires events](../../examples/#extending_component_changeEvents)
 * [Custom component that manages child components](../../examples/#extending_component_childCleanup)
 * [Custom component that schedules asynch tasks](../../examples/#extending_component_update)

 @class Component
 @module xeogl
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Component
 within the default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} DepthBuf configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Component.
 @param [cfg.isDefault] {Boolean} Set true when this is one of xeogl's default components.
 */
(function () {

    "use strict";

    xeogl.Component = Class.extend({

        __init: function () {

            var cfg = {};

            var arg1 = arguments[0];
            var arg2 = arguments[1];

            /**
             The parent {{#crossLink "Scene"}}{{/crossLink}} that contains this Component.

             @property scene
             @type {Scene}
             @final
             */
            this.scene = null;

            var adopter = null;

            if (this.type === "xeogl.Scene") {
                this.scene = this;
                if (arg1) {
                    cfg = arg1;
                }

            } else {
                if (arg1) {
                    if (arg1.type === "xeogl.Scene") {
                        this.scene = arg1;
                        adopter = this.scene;
                        if (arg2) {
                            cfg = arg2;
                        }

                    } else if (arg1.isType && arg1.isType("xeogl.Component")) {
                        this.scene = arg1.scene;
                        adopter = arg1;
                        if (arg2) {
                            cfg = arg2;
                        }

                    } else {
                        // Create this component within the default xeogl Scene
                        this.scene = xeogl.scene;
                        adopter = this.scene;

                        cfg = arg1;
                    }
                } else {
                    // Create this component within the default xeogl Scene
                    this.scene = xeogl.scene;
                    adopter = this.scene;
                }
                this._renderer = this.scene._renderer;
            }

            /**
             Arbitrary, user-defined metadata on this component.

             @property metadata
             @type Object
             */
            this.meta = cfg.meta || {};

            /**
             Indicates whether this is one of the {{#crossLink "Scene"}}Scene{{/crossLink}}'s built-in Components.

             @property isDefault
             @type Boolean
             */
            this.isDefault = cfg.isDefault;

            /**
             Unique ID for this Component within its parent {{#crossLink "Scene"}}Scene{{/crossLink}}.

             @property id
             @type String
             @final
             */
            this.id = cfg.id; // Auto-generated by xeogl.Scene by default

            /**
             True as soon as this Component has been destroyed

             @property destroyed
             @type Boolean
             */
            this.destroyed = false;

            /// Attached components with names.
            this._attached = {}; // Protected

            // Attached components keyed to IDs
            this._attachments = null; // Lazy-instantiated map

            // Event support - lazy creating these properties because
            // they are expensive to have around if not using them
            this._handleMap = null; // Subscription handle pool
            this._handleEvents = null; // Subscription handles mapped to event names
            this._eventSubs = null; // Event names mapped to subscribers
            this._events = null; // Maps names to events
            this._eventCallDepth = 0; // Helps us catch stack overflows from recursive events

            // Components created with #create
            this._adoptees = null; // Lazy-instantiated map

            if (this.scene && this.type !== "xeogl.Scene") { // HACK: Don't add scene to itself
                // Register this component on its scene
                // Assigns this component an automatic ID if not yet assigned
                this.scene._addComponent(this);
            }

            // True when #_update will be called on next tick
            this._updateScheduled = false;

            // Initialize this component
            if (this._init) {
                this._init(cfg);
            }

            if (adopter) {
                adopter._adopt(this);
            }
        },

        /**
         JavaScript class name for this Component.

         For example: "xeogl.AmbientLight", "xeogl.ColorTarget", "xeogl.Lights" etc.

         @property type
         @type String
         @final
         */
        type: "xeogl.Component",

        /**
         An array of strings that indicates the chain of super-types within this component's inheritance hierarchy.

         For example, if this component is a {{#crossLink "Rotate"}}{{/crossLink}}, which
         extends {{#crossLink "Transform"}}{{/crossLink}}, which in turn extends {{#crossLink "Component"}}{{/crossLink}},
         then this property will have the value:

         ````json
         ["xeogl.Component", "xeogl.Transform"]
         ````

         Note that the chain is ordered downwards in the hierarchy, ie. from super-class down towards sub-class.

         @property superTypes
         @type {Array of String}
         @final
         */
        superTypes: [],

        /**
         Tests if this component is of the given type, or is a subclass of the given type.

         The type may be given as either a string or a component constructor.

         This method works by walking up the inheritance type chain, which this component provides in
         property {{#crossLink "Component/superTypes:property"}}{{/crossLink}}, returning true as soon as one of the type strings in
         the chain matches the given type, of false if none match.

         #### Examples:

         ````javascript
         var myRotate = new xeogl.Rotate({ ... });

         myRotate.isType(xeogl.Component); // Returns true for all xeogl components
         myRotate.isType("xeogl.Component"); // Returns true for all xeogl components
         myRotate.isType(xeogl.Rotate); // Returns true
         myRotate.isType(xeogl.Transform); // Returns true
         myRotate.isType("xeogl.Transform"); // Returns true
         myRotate.isType(xeogl.Entity); // Returns false, because xeogl.Rotate does not (even indirectly) extend xeogl.Entity
         ````

         @method isType
         @param  {String|Function} type Component type to compare with, eg "xeogl.PhongMaterial", or a xeogl component constructor.
         @returns {Boolean} True if this component is of given type or is subclass of the given type.
         */
        isType: function (type) {
            if (!xeogl._isString(type)) {
                type = type.type;
                if (!type) {
                    return false;
                }
            }
            return xeogl._isComponentType(this.type, type);
        },

        /**
         * Initializes this component
         * @param cfg
         * @private
         */
        _init: function (cfg) {
        },

        /**
         * Fires an event on this component.
         *
         * Notifies existing subscribers to the event, optionally retains the event to give to
         * any subsequent notifications on the event as they are made.
         *
         * @method fire
         * @param {String} event The event type name
         * @param {Object} value The event parameters
         * @param {Boolean} [forget=false] When true, does not retain for subsequent subscribers
         */
        fire: function (event, value, forget) {
            if (!this._events) {
                this._events = {};
            }
            if (!this._eventSubs) {
                this._eventSubs = {};
            }
            if (forget !== true) {
                this._events[event] = value; // Save notification
            }
            var subs = this._eventSubs[event];
            var sub;
            if (subs) { // Notify subscriptions
                for (var handle in subs) {
                    if (subs.hasOwnProperty(handle)) {
                        sub = subs[handle];
                        this._eventCallDepth++;
                        if (this._eventCallDepth < 300) {
                            sub.callback.call(sub.scope, value);
                        } else {
                            this.error("fire: potential stack overflow from recursive event '" + event + "' - dropping this event");
                        }
                        this._eventCallDepth--;
                    }
                }
            }
        },

        /**
         * Subscribes to an event on this component.
         *
         * The callback is be called with this component as scope.
         *
         * @method on
         * @param {String} event The event
         * @param {Function} callback Called fired on the event
         * @param {Object} [scope=this] Scope for the callback
         * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
         */
        on: function (event, callback, scope) {
            if (!this._events) {
                this._events = {};
            }
            if (!this._handleMap) {
                this._handleMap = new xeogl.utils.Map(); // Subscription handle pool
            }
            if (!this._handleEvents) {
                this._handleEvents = {};
            }
            if (!this._eventSubs) {
                this._eventSubs = {};
            }
            var subs = this._eventSubs[event];
            if (!subs) {
                subs = {};
                this._eventSubs[event] = subs;
            }
            var handle = this._handleMap.addItem(); // Create unique handle
            subs[handle] = {
                callback: callback,
                scope: scope || this
            };
            this._handleEvents[handle] = event;
            var value = this._events[event];
            if (value !== undefined) { // A publication exists, notify callback immediately
                callback.call(scope || this, value);
            }
            return handle;
        },

        /**
         * Cancels an event subscription that was previously made with {{#crossLink "Component/on:method"}}{{/crossLink}} or
         * {{#crossLink "Component/once:method"}}{{/crossLink}}.
         *
         * @method off
         * @param {String} handle Publication handle
         */
        off: function (handle) {
            if (handle === undefined || handle === null) {
                return;
            }
            if (!this._handleEvents) {
                return;
            }
            var event = this._handleEvents[handle];
            if (event) {
                delete this._handleEvents[handle];
                var locSubs = this._eventSubs[event];
                if (locSubs) {
                    delete locSubs[handle];
                }
                this._handleMap.removeItem(handle); // Release handle
            }
        },

        /**
         * Subscribes to the next occurrence of the given event, then un-subscribes as soon as the event is handled.
         *
         * This is equivalent to calling {{#crossLink "Component/on:method"}}{{/crossLink}}, and then calling
         * {{#crossLink "Component/off:method"}}{{/crossLink}} inside the callback function.
         *
         * @method once
         * @param {String} event Data event to listen to
         * @param {Function(data)} callback Called when fresh data is available at the event
         * @param {Object} [scope=this] Scope for the callback
         */
        once: function (event, callback, scope) {
            var self = this;
            var handle = this.on(event,
                function (value) {
                    self.off(handle);
                    callback(value);
                },
                scope);
        },

        /**
         * Returns true if there are any subscribers to the given event on this component.
         *
         * @method hasSubs
         * @param {String} event The event
         * @return {Boolean} True if there are any subscribers to the given event on this component.
         */
        hasSubs: function (event) {
            return (this._eventSubs && !!this._eventSubs[event]);
        },

        /**
         * Logs a console debugging message for this component.
         *
         * The console message will have this format: *````[LOG] [<component type> <component id>: <message>````*
         *
         * Also fires the message as a {{#crossLink "Scene/log:event"}}{{/crossLink}} event on the
         * parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
         *
         * @method log
         * @param {String} message The message to log
         */
        log: function (message) {
            message = "[LOG]" + this._message(message);
            window.console.log(message);
            this.scene.fire("log", message);
        },

        _message: function (message) {
            return " [" + this.type + " " + xeogl._inQuotes(this.id) + "]: " + message;
        },

        /**
         * Logs a warning for this component to the JavaScript console.
         *
         * The console message will have this format: *````[WARN] [<component type> =<component id>: <message>````*
         *
         * Also fires the message as a {{#crossLink "Scene/warn:event"}}{{/crossLink}} event on the
         * parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
         *
         * @method warn
         * @param {String} message The message to log
         */
        warn: function (message) {
            message = "[WARN]" + this._message(message);
            window.console.warn(message);
            this.scene.fire("warn", message);
        },

        /**
         * Logs an error for this component to the JavaScript console.
         *
         * The console message will have this format: *````[ERROR] [<component type> =<component id>: <message>````*
         *
         * Also fires the message as an {{#crossLink "Scene/error:event"}}{{/crossLink}} event on the
         * parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
         *
         * @method error
         * @param {String} message The message to log
         */
        error: function (message) {
            message = "[ERROR]" + this._message(message);
            window.console.error(message);
            this.scene.fire("error", message);
        },

        /**
         * Adds a child component to this.
         * When component not given, attaches the scene's default instance for the given name (if any).
         * Publishes the new child component on this component, keyed to the given name.
         *
         * @param {*} params
         * @param {String} params.name component name
         * @param {Component} [params.component] The component
         * @param {String} [params.type] Optional expected type of base type of the child; when supplied, will
         * cause an exception if the given child is not the same type or a subtype of this.
         * @param {Boolean} [params.sceneDefault=false]
         * @param {Boolean} [params.sceneSingleton=false]
         * @param {Function} [params.onAttached] Optional callback called when component attached
         * @param {Function} [params.onAttached.callback] Callback function
         * @param {Function} [params.onAttached.scope] Optional scope for callback
         * @param {Function} [params.onDetached] Optional callback called when component is detached
         * @param {Function} [params.onDetached.callback] Callback function
         * @param {Function} [params.onDetached.scope] Optional scope for callback
         * @param {{String:Function}} [params.on] Callbacks to subscribe to properties on component
         * @param {Boolean} [params.recompiles=true] When true, fires "dirty" events on this component
         * @private
         */
        _attach: function (params) {

            var name = params.name;

            if (!name) {
                this.error("Component 'name' expected");
                return;
            }

            var component = params.component;
            var sceneDefault = params.sceneDefault;
            var sceneSingleton = params.sceneSingleton;
            var type = params.type;
            var on = params.on;
            var recompiles = params.recompiles !== false;

            // True when child given as config object, where parent manages its instantiation and destruction
            var managingLifecycle = false;

            if (component) {

                if (xeogl._isNumeric(component) || xeogl._isString(component)) {

                    // Component ID given
                    // Both numeric and string IDs are supported

                    var id = component;

                    component = this.scene.components[id];

                    if (!component) {

                        // Quote string IDs in errors

                        this.error("Component not found: " + xeogl._inQuotes(id));
                        return;
                    }

                } else if (xeogl._isObject(component)) {

                    // Component config given

                    var componentCfg = component;
                    var componentType = componentCfg.type || type || "xeogl.Component";
                    var componentClass = window[componentType];

                    if (!componentClass) {
                        this.error("Component type not found: " + componentType);
                        return;
                    }

                    if (type) {
                        if (!xeogl._isComponentType(componentType, type)) {
                            this.error("Expected a " + type + " type or subtype, not a " + componentType);
                            return;
                        }
                    }

                    component = new componentClass(this.scene, componentCfg);

                    managingLifecycle = true;
                }
            }


            if (!component) {

                if (sceneSingleton === true) {

                    // Using the first instance of the component type we find

                    var instances = this.scene.types[type];
                    for (var id2 in instances) {
                        if (instances.hasOwnProperty) {
                            component = instances[id2];
                            break;
                        }
                    }

                    if (!component) {
                        this.error("Scene has no default component for '" + name + "'");
                        return null;
                    }

                } else if (sceneDefault === true) {

                    // Using a default scene component

                    component = this.scene[name];

                    if (!component) {
                        this.error("Scene has no default component for '" + name + "'");
                        return null;
                    }
                }
            }

            if (component) {

                if (component.scene.id !== this.scene.id) {
                    this.error("Not in same scene: " + component.type + " " + xeogl._inQuotes(component.id));
                    return;
                }

                if (type) {

                    if (!component.isType(type)) {
                        this.error("Expected a " + type + " type or subtype: " + component.type + " " + xeogl._inQuotes(component.id));
                        return;
                    }
                }
            }

            if (!this._attachments) {
                this._attachments = {};
            }

            var oldComponent = this._attached[name];
            var subs;
            var i;
            var len;

            if (oldComponent) {

                if (component && oldComponent.id === component.id) {

                    // Reject attempt to reattach same component
                    return;
                }

                var oldAttachment = this._attachments[oldComponent.id];

                // Unsubscribe from events on old component

                subs = oldAttachment.subs;

                for (i = 0, len = subs.length; i < len; i++) {
                    oldComponent.off(subs[i]);
                }

                delete this._attached[name];
                delete this._attachments[oldComponent.id];

                var onDetached = oldAttachment.params.onDetached;
                if (onDetached) {
                    if (xeogl._isFunction(onDetached)) {
                        onDetached(oldComponent);
                    } else {
                        onDetached.scope ? onDetached.callback.call(onDetached.scope, oldComponent) : onDetached.callback(oldComponent);
                    }
                }

                if (oldAttachment.managingLifecycle) {

                    // Note that we just unsubscribed from all events fired by the child
                    // component, so destroying it won't fire events back at us now.

                    oldComponent.destroy();
                }
            }

            if (component) {

                // Set and publish the new component on this component

                var attachment = {
                    params: params,
                    component: component,
                    subs: [],
                    managingLifecycle: managingLifecycle
                };

                attachment.subs.push(
                    component.on("destroyed",
                        function () {
                            attachment.params.component = null;
                            this._attach(attachment.params);
                        },
                        this));

                if (recompiles) {
                    attachment.subs.push(
                        component.on("dirty",
                            function () {
                                this.fire("dirty", this);
                            },
                            this));
                }

                this._attached[name] = component;
                this._attachments[component.id] = attachment;

                // Bind destruct listener to new component to remove it
                // from this component when destroyed

                var onAttached = params.onAttached;
                if (onAttached) {
                    if (xeogl._isFunction(onAttached)) {
                        onAttached(component);
                    } else {
                        onAttached.scope ? onAttached.callback.call(onAttached.scope, component) : onAttached.callback(component);
                    }
                }

                if (on) {

                    var event;
                    var handler;
                    var callback;
                    var scope;

                    for (event in on) {
                        if (on.hasOwnProperty(event)) {

                            handler = on[event];

                            if (xeogl._isFunction(handler)) {
                                callback = handler;
                                scope = null;
                            } else {
                                callback = handler.callback;
                                scope = handler.scope;
                            }

                            if (!callback) {
                                continue;
                            }

                            attachment.subs.push(component.on(event, callback, scope));
                        }
                    }
                }
            }

            if (recompiles) {
                this.fire("dirty", this); // FIXME: May trigger spurous entity recompilations unless able to limit with param?
            }

            this.fire(name, component); // Component can be null

            return component;
        },

        /**
         * Convenience method for creating a Component within this Component's {{#crossLink "Scene"}}{{/crossLink}}.
         *
         * The method is given a component configuration, like so:
         *
         * ````javascript
         * var material = myComponent.create({
         *      type: "xeogl.PhongMaterial",
         *      diffuse: [1,0,0],
         *      specular: [1,1,0]
         * }, "myMaterial");
         * ````
         *
         * @method create
         * @param {*} [cfg] Configuration for the component instance.
         * @returns {*}
         */
        create: function (cfg) {

            var type;
            var claz;

            if (xeogl._isObject(cfg)) {
                type = cfg.type || "xeogl.Component";
                claz = xeogl[type.substring(6)];

            } else if (xeogl._isString(cfg)) {
                type = cfg;
                claz = xeogl[type.substring(6)];

            } else {
                claz = cfg;
                type = cfg.prototype.type;
                // TODO: catch unknown component class
            }

            if (!claz) {
                this.error("Component type not found: " + type);
                return;
            }

            if (!xeogl._isComponentType(type, "xeogl.Component")) {
                this.error("Expected a xeogl.Component type or subtype");
                return;
            }

            if (cfg && cfg.id && this.components[cfg.id]) {
                this.error("Component " + xeogl._inQuotes(cfg.id) + " already exists in Scene - ignoring ID, will randomly-generate instead");
                cfg.id = undefined;
                //return null;
            }

            var component = new claz(this, cfg);
            if (component) {
                this._adopt(component);
            }

            return component;
        },

        _adopt: function (component) {
            if (!this._adoptees) {
                this._adoptees = {};
            }
            if (!this._adoptees[component.id]) {
                this._adoptees[component.id] = component;
            }
            component.on("destroyed", function () {
                delete this._adoptees[component.id];
            }, this);
        },

        /**
         * Protected method, called by sub-classes to queue a call to _update().
         * @protected
         * @param {Number} [priority=1]
         */
        _needUpdate: function (priority) {
            if (!this._updateScheduled) {
                this._updateScheduled = true;
                if (priority === 0) {
                    xeogl.deferTask(this._doUpdate, this);
                } else {
                    xeogl.scheduleTask(this._doUpdate, this);
                }
            }
        },

        /**
         * @private
         */
        _doUpdate: function () {
            if (this._updateScheduled) {
                this._updateScheduled = false;
                if (this._update) {
                    this._update();
                }
            }
        },

        /**
         * Protected virtual template method, optionally implemented
         * by sub-classes to perform a scheduled task.
         *
         * @protected
         */
        _update: null,

        /**
         * Destroys this component.
         *
         * Fires a {{#crossLink "Component/destroyed:event"}}{{/crossLink}} event on this Component.
         *
         * Automatically disassociates this component from other components, causing them to fall back on any
         * defaults that this component overrode on them.
         *
         * TODO: describe effect with respect to #create
         *
         * @method destroy
         */
        destroy: function () {

            if (this.destroyed) {
                return;
            }

            // Unsubscribe from child components and destroy then

            var id;
            var attachment;
            var component;
            var subs;
            var i;
            var len;

            if (this._attachments) {
                for (id in this._attachments) {
                    if (this._attachments.hasOwnProperty(id)) {
                        attachment = this._attachments[id];
                        component = attachment.component;
                        subs = attachment.subs;
                        for (i = 0, len = subs.length; i < len; i++) {
                            component.off(subs[i]);
                        }
                        if (attachment.managingLifecycle) {
                            component.destroy();
                        }
                    }
                }
            }

            // Release components created with #create

            if (this._adoptees) {
                for (id in this._adoptees) {
                    if (this._adoptees.hasOwnProperty(id)) {
                        component = this._adoptees[id];
                        delete this._adoptees[id];
                    }
                }
            }

            // Execute subclass behaviour

            if (this._destroy) {
                this._destroy();
            }

            /**
             * Fired when this Component is destroyed.
             * @event destroyed
             */
            this.fire("destroyed", this.destroyed = true);
        },

        /**
         * Protected template method, implemented by sub-classes
         * to clean up just before the component is destroyed.
         *
         * @protected
         */
        _destroy: function () {
        }
    });
})();
;/**
 A Scene represents a 3D world.

 ## Usage

 * [Creating a Scene](#creating-a-scene)
 * [Creating entities](#creating-entities)
 * [Loading models](#loading-models)
 * [Accessing content](#accessing-content)
 * [Controlling the camera](#controlling-the-camera)
 * [Taking snapshots](#taking-snapshots)
 * [Lighting](#lighting)
 * [Clipping](#clipping)
 * [Emphasis effects](#emphasis-effects)
 * [Picking](#picking)
 * [Pick masking](#pick-masking)
 * [Getting the World-space boundary](#getting-the-world-space-boundary)
 * [Controlling the viewport](#controlling-the-viewport)
 * [Controlling rendering](#controlling-rendering)
 * [Gamma correction](#gamma-correction)

 ### Creating a Scene

 Creating a Scene with its own default canvas:

 ````javascript
 var scene = new xeogl.Scene();
 ````

 Creating a Scene with an existing canvas.

 ````javascript
 var scene2 = new xeogl.Scene({
    canvas: "myCanvas"
 });

 var scene3 = new xeogl.Scene({
    canvas: document.getElementById("myCanvas");
 });
 ````

 ### Creating entities

 Creating an {{#crossLink "Entity"}}{{/crossLink}} within a Scene:

 <a href="../../examples/#geometry_primitives_teapot"><img src="../../assets/images/screenshots/Scene/teapot.png"></img></a>

 ````javascript
 var entity = new xeogl.Entity(scene, {
    geometry: new xeogl.TeapotGeometry(scene),
    material: new xeogl.PhongMaterial(scene, {
        diffuse: [0.2, 0.2, 1.0]
    })
 });
 ````

 Creating an entity within the default Scene (which will be automatically created if not yet existing):
 ````javascript
 entity = new xeogl.Entity({
    geometry: new xeogl.TeapotGeometry(),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    })
 });

 entity.scene.camera.eye = [45, 45, 45];
 ````

 The default Scene can be got from either the Entity or the xeogl namespace:

 ````javascript
 scene = entity.scene;
 scene = xeogl.scene;
 ````

 ### Loading models

 Use {{#crossLink "GLTFModel"}}{{/crossLink}} components to load glTF models into a Scene:

 ````javascript
 var model = new xeogl.GLTFModel(scene, { // If we don't provide the Scene, will create in default Scene
    id: "gearbox",
    src: "models/gltf/gearbox/gearbox_assy.gltf"
 });
 ````

 ### Accessing content

 Find components by ID in their Scene's {{#crossLink "Scene/components:property"}}{{/crossLink}} map:

 ````javascript
 var gear1 = scene.components["gearbox#gear99"];
 gear1.visible = false;
 //...
 ````

 A Scene also has a map of component instances for each {{#crossLink "Component"}}{{/crossLink}} subtype:

 ````javascript
 var entities = scene.types["xeogl.Entity"];
 var gear = entities["gearbox#gear99"];
 gear.ghost = true;
 //...

 var glTFModels = scene.types["xeogl.GLTFModel"];
 var gearbox = glTFModels["gearbox"];
 gearbox.visible = false;
 //...
 ````
 a map containing just the {{#crossLink "Model"}}{{/crossLink}} instances:

 ````javascript
 gearbox = scene.models["gearbox"];
 ````

 and a map containing just the {{#crossLink "Entity"}}{{/crossLink}} instances:

 ````javascript
 gear = scene.entities["gearbox#gear99"];
 ````

 ### Controlling the camera

 Use the Scene's {{#crossLink "Camera"}}{{/crossLink}} to control the current viewpoint and projection:

 ````javascript
 var camera = myScene.camera;

 camera.eye = [-10,0,0];
 camera.look = [-10,0,0];
 camera.up = [0,1,0];

 camera.projection = "perspective";
 camera.perspective.fov = 45;
 //...
 ````

 ### Managing the canvas, taking snapshots

 The Scene's {{#crossLink "Canvas"}}{{/crossLink}} component provides various conveniences relevant to the WebGL canvas, such
 as getting getting snapshots, firing resize events etc:

 ````javascript
 var canvas = scene.canvas;

 canvas.on("boundary", function(boundary) {
    //...
 });

 var imageData = canvas.getSnapshot({
    width: 500,
    height: 500,
    format: "png"
 });
 ````

 ### Lighting

 The Scene's {{#crossLink "Lights"}}{{/crossLink}} component manages lighting:

 ````javascript
 var lights = scene.lights;
 lights[1].color = [0.9, 0.9, 0.9];
 //...
 ````

 ### Clipping

 The Scene's {{#crossLink "Clips"}}{{/crossLink}} component manages clipping planes for custom cross-sections:

 ````javascript
 var clips = scene.clips;
 clips.clips = [
 new xeogl.Clip({  // Clip plane on negative diagonal
        pos: [1.0, 1.0, 1.0],
        dir: [-1.0, -1.0, -1.0],
        active: true
    }),
 new xeogl.Clip({ // Clip plane on positive diagonal
        pos: [-1.0, -1.0, -1.0],
        dir: [1.0, 1.0, 1.0],
        active: true
    }),
 //...
 ];
 ````

 ### Emphasis effects

 The Scene's {{#crossLink "Scene/ghostMaterial:property"}}{{/crossLink}} provides the default {{#crossLink "EmphasisMaterial"}}{{/crossLink}}
 for controlling ghost effects:

 ````javascript
 var ghostMaterial = scene.ghostMaterial;
 ghostMaterial.edgeColor = [0.9, 0.9, 0.0];
 //...
 ````

 The Scene's {{#crossLink "Scene/highlightMaterial:property"}}{{/crossLink}} provides the default {{#crossLink "EmphasisMaterial"}}{{/crossLink}}
 for controlling highlight effects:

 ````javascript
 var highlightMaterial = scene.highlightMaterial;
 highlightMaterial.color = [0.9, 0.9, 0.0];
 //...
 ````

 The Scene's {{#crossLink "Scene/outlineMaterial:property"}}{{/crossLink}} provides the default {{#crossLink "OutlineMaterial"}}{{/crossLink}}
 for controlling outline effects:


 ````javascript
 var outlineMaterial = scene.outlineMaterial;
 outlineMaterial.edgeWidth = 6;
 ````

 ### Picking entities

 Use the Scene's {{#crossLink "Scene/pick:method"}}pick(){{/crossLink}} method to pick and raycast entities.

 For example, to pick a point on the surface of the closest entity at the given canvas coordinates:

 ````javascript
 var hit = scene.pick({
     pickSurface: true,
     canvasPos: [23, 131]
 });

 if (hit) { // Picked an Entity

      var entity = hit.entity;

      var primitive = hit.primitive; // Type of primitive that was picked, usually "triangles"
      var primIndex = hit.primIndex; // Position of triangle's first index in the picked Entity's Geometry's indices array
      var indices = hit.indices; // UInt32Array containing the triangle's vertex indices
      var localPos = hit.localPos; // Float32Array containing the picked Local-space position on the triangle
      var worldPos = hit.worldPos; // Float32Array containing the picked World-space position on the triangle
      var viewPos = hit.viewPos; // Float32Array containing the picked View-space position on the triangle
      var bary = hit.bary; // Float32Array containing the picked barycentric position within the triangle
      var normal = hit.normal; // Float32Array containing the interpolated normal vector at the picked position on the triangle
      var uv = hit.uv; // Float32Array containing the interpolated UV coordinates at the picked position on the triangle
 }
 ````

 ### Pick masking

 We can use the {{#crossLink "Scene/pick:method"}}pick(){{/crossLink}} method's ````include```` and ````exclude````
 options to mask which Entities we attempt to pick.

 This is useful for picking <em>through</em> things, to pick only the Entities of interest.

 #### Including entities

 To pick only Entities ````"gearbox#77.0"```` and ````"gearbox#79.0"````, picking through any other Entities that are
 in the way, as if they weren't there:

 ````javascript
 var hit = scene.pick({
     canvasPos: [23, 131],
     include: ["gearbox#77.0", "gearbox#79.0"]
 });

 if (hit) {
      // Entity will always be either "gearbox#77.0" or "gearbox#79.0"
      var entity = hit.entity;
 }
 ````

 #### Excluding entities

 To pick any pickable Entity, except for ````"gearbox#77.0"```` and ````"gearbox#79.0"````, picking through those
 Entities if they happen to be in the way:

 ````javascript
 var hit = scene.pick({
     canvasPos: [23, 131],
     exclude: ["gearbox#77.0", "gearbox#79.0"]
 });

 if (hit) {
      // Entity will never be "gearbox#77.0" or "gearbox#79.0"
      var entity = hit.entity;
 }
 ````

 See {{#crossLink "Scene/pick:method"}}pick(){{/crossLink}} for more info on picking.

 ### Getting the World-space boundary

 Getting a Scene's World-space boundary as an AABB:

 ````javascript
 var aabb = scene.aabb; // [xmin, ymin, zmin, xmax, ymax, zmax]
 ````

 Subscribing to updates to the World-space boundary, which occur whenever Entities are Transformed, or their Geometries have been updated.

 ````javascript
 scene.on("boundary", function() {
     var aabb = scene.aabb;
     var obb = scene.obb;
 });
 ````

 Getting the collective World-space axis-aligned boundary of the {{#crossLink "Entity"}}Entities{{/crossLink}}
 and/or {{#crossLink "Model"}}Models{{/crossLink}} with the given IDs:

 ````JavaScript
 scene.getAABB(); // Gets collective boundary of all entities in the scene
 scene.getAABB("saw"); // Gets collective boundary of all entities in saw model
 scene.getAABB(["saw", "gearbox"]); // Gets collective boundary of all entities in saw and gearbox models
 scene.getAABB("saw#0.1"); // Get boundary of an entity in the saw model
 scene.getAABB(["saw#0.1", "saw#0.2"]); // Get collective boundary of two entities in saw model
 ````

 ### Managing the viewport

 The Scene's {{#crossLink "Viewport"}}{{/crossLink}} component manages the WebGL viewport:

 ````javascript
 var viewport = scene.viewport
 viewport.boundary = [0, 0, 500, 400];;
 ````

 ### Controlling rendering

 You can configure a Scene to perform multiple "passes" (renders) per frame. This is useful when we want to render the
 scene to multiple viewports, such as for stereo effects.

 In the example, below, we'll configure the Scene to render twice on each frame, each time to different viewport. We'll do this
 with a callback that intercepts the Scene before each render and sets its {{#crossLink "Viewport"}}{{/crossLink}} to a
 different portion of the canvas. By default, the Scene will clear the canvas only before the first render, allowing the
 two views to be shown on the canvas at the same time.

 ````Javascript
 // Load glTF model
 var model = new xeogl.GLTFModel({
    src: "models/gltf/GearboxAssy/glTF-MaterialsCommon/GearboxAssy.gltf"
 });

 var scene = model.scene;
 var viewport = scene.viewport;

 // Configure Scene to render twice for each frame
 scene.passes = 2; // Default is 1
 scene.clearEachPass = false; // Default is false

 // Render to a separate viewport on each render

 var viewport = scene.viewport;
 viewport.autoBoundary = false;

 scene.on("rendering", function (e) {
     switch (e.pass) {
         case 0:
             viewport.boundary = [0, 0, 200, 200]; // xmin, ymin, width, height
             break;

         case 1:
             viewport.boundary = [200, 0, 200, 200];
             break;
     }
 });

 // We can also intercept the Scene after each render,
 // (though we're not using this for anything here)
 scene.on("rendered", function (e) {
     switch (e.pass) {
         case 0:
             break;

         case 1:
             break;
     }
 });
 ````

 ### Gamma correction

 Within its shaders, xeogl performs shading calculations in linear space.

 By default, the Scene expects color textures (ie. {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}},
 {{#crossLink "MetallicMaterial/baseColorMap:property"}}{{/crossLink}} and {{#crossLink "SpecularMaterial/diffuseMap:property"}}{{/crossLink}}) to
 be in pre-multipled gamma space, so will convert those to linear space before they are used in shaders. Other textures are
 always expected to be in linear space.

 By default, the Scene will also gamma-correct its rendered output.

 You can configure the Scene to expect all those color textures to be linear space, so that it does not gamma-correct them:

 ````javascript
 scene.gammaInput = false;
 ````

 You would still need to gamma-correct the output, though, if it's going straight to the canvas, so normally we would
 leave that enabled:

 ````javascript
 scene.gammaOutput = true;
 ````

 See {{#crossLink "Texture"}}{{/crossLink}} for more information on texture encoding and gamma.

 @class Scene
 @module xeogl
 @constructor
 @param [cfg] Scene parameters
 @param [cfg.id] {String} Optional ID, unique among all Scenes in xeogl, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Scene.
 @param [cfg.canvasId] {String} ID of existing HTML5 canvas in the DOM - creates a full-page canvas automatically if this is omitted
 @param [cfg.webgl2=true] {Boolean} Set this false when we **don't** want to use WebGL 2 for our Scene; the Scene will fall
 back on WebGL 1 if not available. This property will be deprecated when WebGL 2 is supported everywhere.
 @param [cfg.components] {Array(Object)} JSON array containing parameters for {{#crossLink "Component"}}Component{{/crossLink}} subtypes to immediately create within the Scene.
 @param [cfg.ticksPerRender=1] {Number} The number of {{#crossLink "Scene/tick:event"}}{{/crossLink}} that happen between each render or this Scene.
 @param [cfg.passes=1] {Number} The number of times this Scene renders per frame.
 @param [cfg.clearEachPass=false] {Boolean} When doing multiple passes per frame, specifies whether to clear the
 canvas before each pass (true) or just before the first pass (false).
 @param [cfg.transparent=false] {Boolean} Whether or not the canvas is transparent.
 @param [cfg.backgroundColor] {Float32Array} RGBA color for canvas background, when canvas is not transparent. Overridden by backgroundImage.
 @param [cfg.backgroundImage] {String} URL of an image to show as the canvas background, when canvas is not transparent. Overrides backgroundImage.
 @param [cfg.gammaInput=false] {Boolean} When true, expects that all textures and colors are premultiplied gamma.
 @param [cfg.gammaOutput=true] {Boolean} Whether or not to render with pre-multiplied gama.
 @param [cfg.gammaFactor=2.2] {Number} The gamma factor to use when rendering with pre-multiplied gamma.
 @extends Component
 */
(function () {

    "use strict";

    /**
     * Fired whenever a debug message logged on a component within this Scene.
     * @event log
     * @param {String} value The debug message
     */

    /**
     * Fired whenever an error is logged on a component within this Scene.
     * @event error
     * @param {String} value The error message
     */

    /**
     * Fired whenever a warning is logged on a component within this Scene.
     * @event warn
     * @param {String} value The warning message
     */
    xeogl.Scene = xeogl.Component.extend({

        type: "xeogl.Scene",

        _init: function (cfg) {

            var self = this;

            var transparent = !!cfg.transparent;

            /**
             * The number of models currently loading.
             *
             * @property loading
             * @type {Number}
             */
            this.loading = 0;

            /**
             * The epoch time (in milliseconds since 1970) when this Scene was instantiated.
             *
             * @property timeCreated
             * @type {Number}
             */
            this.startTime = (new Date()).getTime();

            /**
             * The {{#crossLink "Component"}}Component{{/crossLink}}s within
             * this Scene, mapped to their IDs.
             *
             * Will also contain the {{#crossLink "Entity"}}{{/crossLink}}s
             * contained in {{#crossLink "Entity/components:property"}}{{/crossLink}}.
             *
             * @property components
             * @type {String:xeogl.Component}
             */
            this.components = {};

            /**
             * For each {{#crossLink "Component"}}Component{{/crossLink}} type, a map of
             * IDs to instances.
             *
             * @property types
             * @type {String:{String:xeogl.Component}}
             */
            this.types = {};

            /**
             * The {{#crossLink "Entity"}}{{/crossLink}}s within
             * this Scene, mapped to their IDs.
             *
             * The {{#crossLink "Entity"}}{{/crossLink}}s in this map
             * will also be contained in {{#crossLink "Entity/components:property"}}{{/crossLink}}.
             *
             * @property entities
             * @type {String:xeogl.Entity}
             */
            this.entities = {};

            /**
             * The {{#crossLink "Model"}}{{/crossLink}}s within
             * this Scene, mapped to their IDs.
             *
             * @property entities
             * @type {String:xeogl.Model}
             */
            this.models = {};

            // Contains xeogl.Entities that need to be recompiled back into this._renderer
            this._dirtyEntities = {};

            /**
             * Manages the HTML5 canvas for this Scene.
             * @final
             * @property canvas
             * @type {Canvas}
             */
            this.canvas = new xeogl.Canvas(this, {
                canvas: cfg.canvas, // Can be canvas ID, canvas element, or null
                transparent: transparent,
                backgroundColor: cfg.backgroundColor,
                backgroundImage: cfg.backgroundImage,
                webgl2: cfg.webgl2 !== false,
                contextAttr: cfg.contextAttr || {}
            });

            // Redraw as canvas resized
            this.canvas.on("boundary",
                function () {
                    self._renderer.imageDirty();
                });

            this.canvas.on("webglContextFailed",
                function () {
                    alert("xeogl failed to find WebGL!");
                });

            this._renderer = new xeogl.renderer.Renderer(xeogl.stats, this.canvas.canvas, this.canvas.gl, {
                transparent: transparent
            });

            /**
             * Publishes input events that occur on this Scene's canvas.
             * @final
             * @property input
             * @type {Input}
             * @final
             */
            this.input = new xeogl.Input(this, {
                element: this.canvas.canvas
            });

            // Register Scene on engine
            // Do this BEFORE we add components below
            xeogl._addScene(this);

            // Add components specified as JSON

            var componentJSONs = cfg.components;

            if (componentJSONs) {
                var componentJSON;
                var type;
                var constr;
                for (var i = 0, len = componentJSONs.length; i < len; i++) {
                    componentJSON = componentJSONs[i];
                    type = componentJSON.type;
                    if (type) {
                        constr = window[type];
                        if (constr) {
                            new constr(this, componentJSON);
                        }
                    }
                }
            }

            // Init default components

            this._initDefaults();

            // Global components

            this._viewport = new xeogl.Viewport(this, {
                id: "default.viewport",
                autoBoundary: true
            });

            this._camera = new xeogl.Camera(this, {
                id: "default.camera"
            });

            this._clips = new xeogl.Clips(this, {
                id: "default.clips"
            });

            this._lights = new xeogl.Lights(this, {
                id: "default.lights",
                lights: [
                    new xeogl.DirLight(this, {
                        dir: [0.8, -0.6, -0.8],
                        color: [1.0, 1.0, 1.0],
                        intensity: 1.0,
                        space: "view"
                    }),

                    new xeogl.DirLight(this, {
                        dir: [-0.8, -0.4, -0.4],
                        color: [1.0, 1.0, 1.0],
                        intensity: 1.0,
                        space: "view"
                    }),

                    new xeogl.DirLight(this, {
                        dir: [0.2, -0.8, 0.8],
                        color: [0.6, 0.6, 0.6],
                        intensity: 1.0,
                        space: "view"
                    })
                ]
            });

            // Plug global components into renderer

            var viewport = this._viewport;
            var renderer = this._renderer;
            var camera = this._camera;
            var clips = this._clips;
            var lights = this._lights;

            renderer.viewport = viewport._state;
            renderer.projTransform = camera[camera.projection]._state;
            renderer.viewTransform = camera._state;
            renderer.lights = lights._getState();
            renderer.clips = clips._getState();

            camera.on("dirty", function () {
                renderer.projTransform = camera.project._state;
                renderer.viewTransform = camera._state;
                renderer.imageDirty();
            });

            clips.on("dirty", function () { // TODO: Buffer so we're not doing for every light
                renderer.clips = clips._getState();
                for (var entityId in self.entities) {
                    if (self.entities.hasOwnProperty(entityId)) {
                        self._entityDirty(self.entities[entityId]);
                    }
                }
            });

            lights.on("dirty", function () {
                renderer.lights = lights._getState();
                var updated = false;
                for (var entityId in self.entities) {
                    if (self.entities.hasOwnProperty(entityId)) {
                        self._entityDirty(self.entities[entityId]);
                        updated = true;
                    }
                }
                // if (!updated || self.loading > 0 || self.canvas.spinner.processes > 0) {
                //     renderer.clear({}); // TODO: multiple passes
                // }
            });

            this.ticksPerRender = cfg.ticksPerRender;
            this.passes = cfg.passes;
            this.clearEachPass = cfg.clearEachPass;
            this.gammaInput = cfg.gammaInput;
            this.gammaOutput = cfg.gammaOutput;
            this.gammaFactor = cfg.gammaFactor;
        },

        _initDefaults: function () {

            // Call this Scene's property accessors to lazy-init their properties

            var dummy; // Keeps Codacy happy

            dummy = this.geometry;
            dummy = this.material;
            dummy = this.ghostMaterial;
            dummy = this.outlineMaterial;
            dummy = this.transform;
        },

        // Called by each component that is created with this Scene as parent.
        // Registers the component within this scene.

        _addComponent: function (c) {

            if (c.id) {

                // User-supplied ID

                if (this.components[c.id]) {
                    this.error("Component " + xeogl._inQuotes(c.id) + " already exists in Scene - ignoring ID, will randomly-generate instead");
                    //        c.id = this._componentIDMap.addItem(c);
                    return;
                }
            } else {

                // Auto-generated ID

                if (window.nextID === undefined) {
                    window.nextID = 0;
                }
                //c.id = xeogl.math.createUUID();
                c.id = "_" + window.nextID++;

                while (this.components[c.id]) {
                    c.id = xeogl.math.createUUID();
                }
            }

            this.components[c.id] = c;

            // Register for class type

            var type = c.type;

            var types = this.types[c.type];

            if (!types) {
                types = this.types[type] = {};
            }

            types[c.id] = c;

            c.on("destroyed", function () {
                this._componentDestroyed(c);
            }, this);

            if (c.isType("xeogl.Entity")) {

                // Component is a xeogl.Entity or subtype

                c.on("dirty", this._entityDirty, this);

                this.entities[c.id] = c;

                // If we currently have a World-space Scene boundary, then invalidate
                // it whenever Entity's World-space boundary updates

                c.on("boundary", this._setBoundaryDirty, this);

                // Update scene statistics

                xeogl.stats.components.entities++;
            }

            if (c.isType("xeogl.Model")) {

                this.models[c.id] = c;

                // Update scene statistics

                xeogl.stats.components.models++;
            }

            //self.log("Created " + c.type + " " + xeogl._inQuotes(c.id));
        },

        // Callbacks as members to reduce GC churn

        _componentDestroyed: function (c) {

            delete this.components[c.id];

            var types = this.types[c.type];

            if (types) {

                delete types[c.id];

                if (xeogl._isEmptyObject(types)) {
                    delete this.types[c.type];
                }
            }

            if (c.isType("xeogl.Entity")) {

                // Component is a xeogl.Entity or subtype

                // Update scene statistics,
                // Unschedule any pending recompilation of
                // the Entity into the renderer

                xeogl.stats.components.entities--;
                delete this.entities[c.id];
                delete this._dirtyEntities[c.id];
                xeogl.stats.components.entities--;
            }

            if (c.isType("xeogl.Model")) {
                delete this.models[c.id];
                xeogl.stats.components.models--;
            }

            //this.log("Destroyed " + c.type + " " + xeogl._inQuotes(c.id));
        },

        _entityDirty: function (entity) {
            this._dirtyEntities[entity.id] = entity;
        },

        /**
         * Renders a single frame of this Scene.
         *
         * The Scene will periodically render itself after any updates, but you can call this method to force a render
         * if required. This method is typically used when we want to synchronously take a snapshot of the canvas and
         * need everything rendered right at that moment.
         *
         * @method render
         * @param {Boolean} [forceRender=false] Forces a render when true, otherwise only renders if something has changed in this Scene
         * since the last render.
         */
        render: (function () {

            var renderEvent = {
                sceneId: null,
                pass: null
            };

            return function (forceRender) {

                // The renderer is suspended while a model loads, and when a Scene is made to load something
                // as soon as it's instantiated, that means that its lights may not get a chance to set the
                // canvas background until the model is loaded and the renderer is unsuspended again. Therefore,
                // we have a special imageForceDirty flag that bypasses the suspension, which lights set when
                // their properties are updated.

                var imageForceDirty = this._renderer.imageForceDirty;

                if (this.loading > 0 && !forceRender && !imageForceDirty) {
                    this._compileDirtyEntities(100);
                    return;
                }

                if (this.canvas.spinner.processes > 0 && !imageForceDirty) {
                    this._compileDirtyEntities(100);
                    return;
                }

                this._compileDirtyEntities(15);

                renderEvent.sceneId = this.id;

                var passes = this._passes;
                var clearEachPass = this._clearEachPass;
                var pass;
                var clear;

                for (pass = 0; pass < passes; pass++) {

                    renderEvent.pass = pass;

                    /**
                     * Fired when about to render a frame for a Scene.
                     *
                     * @event rendering
                     * @param {String} sceneID The ID of this Scene.
                     * @param {Number} pass Index of the pass we are about to render (see {{#crossLink "Scene/passes:property"}}{{/crossLink}}).
                     */
                    this.fire("rendering", renderEvent, true);

                    clear = clearEachPass || (pass === 0);

                    this._renderer.render({pass: pass, clear: clear, force: forceRender});

                    /**
                     * Fired when we have just rendered a frame for a Scene.
                     *
                     * @event rendering
                     * @param {String} sceneID The ID of this Scene.
                     * @param {Number} pass Index of the pass we rendered (see {{#crossLink "Scene/passes:property"}}{{/crossLink}}).
                     */
                    this.fire("rendered", renderEvent, true);
                }

                this._saveAmbientColor();
            }
        })(),

        _compileDirtyEntities: function (timeBudget) {
            var time1 = (new Date()).getTime();
            var entity;
            for (var id in this._dirtyEntities) {
                if (this._dirtyEntities.hasOwnProperty(id)) {
                    entity = this._dirtyEntities[id];
                    if (entity._valid()) {
                        entity._compile();
                        delete this._dirtyEntities[id];
                    }
                    var time2 = (new Date()).getTime();
                    if (time2 - time1 > timeBudget) {
                        return;
                    }
                }
            }
        },

        _saveAmbientColor: function () {
            var canvas = this.canvas;
            if (!canvas.transparent && !canvas.backgroundImage && !canvas.backgroundColor) {
                var ambientColor = this._renderer.getAmbientColor();
                if (!this._lastAmbientColor ||
                    this._lastAmbientColor[0] !== ambientColor[0] ||
                    this._lastAmbientColor[1] !== ambientColor[1] ||
                    this._lastAmbientColor[2] !== ambientColor[2] ||
                    this._lastAmbientColor[3] !== ambientColor[3]) {
                    canvas.backgroundColor = ambientColor;
                    if (!this._lastAmbientColor) {
                        this._lastAmbientColor = xeogl.math.vec4([0, 0, 0, 1]);
                    }
                    this._lastAmbientColor.set(ambientColor);
                }
            } else {
                this._lastAmbientColor = null;
            }
        },

        _props: {

            /**
             * The number of {{#crossLink "Scene/tick:property"}}{{/crossLink}} that happen between each render or this Scene.
             *
             * @property ticksPerRender
             * @default 1
             * @type Number
             */
            ticksPerRender: {

                set: function (value) {

                    if (value === undefined || value === null) {
                        value = 1;

                    } else if (!xeogl._isNumeric(value) || value <= 0) {

                        this.error("Unsupported value for 'ticksPerRender': '" + value +
                            "' - should be an integer greater than zero.");

                        value = 1;
                    }

                    if (value === this._ticksPerRender) {
                        return;
                    }

                    this._ticksPerRender = value;
                },

                get: function () {
                    return this._ticksPerRender;
                }
            },

            /**
             * The number of times this Scene renders per frame.
             *
             * @property passes
             * @default 1
             * @type Number
             */
            passes: {

                set: function (value) {

                    if (value === undefined || value === null) {
                        value = 1;

                    } else if (!xeogl._isNumeric(value) || value <= 0) {

                        this.error("Unsupported value for 'passes': '" + value +
                            "' - should be an integer greater than zero.");

                        value = 1;
                    }

                    if (value === this._passes) {
                        return;
                    }

                    this._passes = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._passes;
                }
            },

            /**
             * When doing multiple passes per frame, specifies whether to clear the
             * canvas before each pass (true) or just before the first pass (false).
             *
             * @property clearEachPass
             * @default false
             * @type Boolean
             */
            clearEachPass: {

                set: function (value) {

                    value = !!value;

                    if (value === this._clearEachPass) {
                        return;
                    }

                    this._clearEachPass = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._clearEachPass;
                }
            },

            /**
             * When true, expects all textures and colors are premultiplied gamma.
             *
             * @property gammaInput
             * @default false
             * @type Boolean
             */
            gammaInput: {

                set: function (value) {

                    value = value !== false;

                    if (value === this._renderer.gammaInput) {
                        return;
                    }

                    this._renderer.gammaInput = value;

                    for (var entityId in this.entities) { // Needs all shaders recompiled
                        if (this.entities.hasOwnProperty(entityId)) {
                            this._entityDirty(this.entities[entityId]);
                        }
                    }
                },

                get: function () {
                    return this._renderer.gammaInput;
                }
            },

            /**
             * Whether or not to render pixels with pre-multiplied gama.
             *
             * @property gammaOutput
             * @default true
             * @type Boolean
             */
            gammaOutput: {

                set: function (value) {

                    value = value !== false;

                    if (value === this._renderer.gammaOutput) {
                        return;
                    }

                    this._renderer.gammaOutput = value;

                    for (var entityId in this.entities) { // Needs all shaders recompiled
                        if (this.entities.hasOwnProperty(entityId)) {
                            this._entityDirty(this.entities[entityId]);
                        }
                    }
                },

                get: function () {
                    return this._renderer.gammaOutput;
                }
            },

            /**
             * The gamma factor to use when {{#crossLink "Scene/property:gammaOutput"}}{{/crossLink}} is set true.
             *
             * @property gammaOutput
             * @default 1.0
             * @type Number
             */
            gammaFactor: {

                set: function (value) {

                    value = (value === undefined || value === null) ? 2.2 : value;

                    if (value === this._renderer.gammaFactor) {
                        return;
                    }

                    this._renderer.gammaFactor = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._renderer.gammaFactor;
                }
            },

            /**
             * The default modelling {{#crossLink "Transform"}}{{/crossLink}} for this Scene.
             *
             * This {{#crossLink "Transform"}}{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.transform",
             * with all other properties initialised to their default values (ie. an identity matrix).
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to
             * this {{#crossLink "Transform"}}{{/crossLink}} by default.
             *
             * @property transform
             * @final
             * @type Transform
             */
            transform: {
                get: function () {
                    return this.components["default.transform"] ||
                        new xeogl.Transform(this, {
                            id: "default.transform",
                            isDefault: true
                        });
                }
            },

            /**
             * The default geometry for this Scene, which is a {{#crossLink "BoxGeometry"}}BoxGeometry{{/crossLink}}.
             *
             * This {{#crossLink "BoxGeometry"}}BoxGeometry{{/crossLink}} has an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.geometry".
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "Geometry"}}Geometry{{/crossLink}} by default.
             * @property geometry
             * @final
             * @type BoxGeometry
             */
            geometry: {
                get: function () {
                    return this.components["default.geometry"] ||
                        new xeogl.BoxGeometry(this, {
                            id: "default.geometry",
                            isDefault: true
                        });
                }
            },

            /**
             * The default drawing material for this Scene, which is a {{#crossLink "PhongMaterial"}}PhongMaterial{{/crossLink}}.
             *
             * This {{#crossLink "PhongMaterial"}}PhongMaterial{{/crossLink}} has
             * an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.material", with all
             * other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "PhongMaterial"}}PhongMaterial{{/crossLink}} by default.
             * @property material
             * @final
             * @type PhongMaterial
             */
            material: {
                get: function () {
                    return this.components["default.material"] ||
                        new xeogl.PhongMaterial(this, {
                            id: "default.material",
                            isDefault: true,
                            emissive: [0.4, 0.4, 0.4] // Visible by default on geometry without normals
                        });
                }
            },

            /**
             * The Scene's default {{#crossLink "EmphasisMaterial"}}EmphasisMaterial{{/crossLink}} for the appearance of {{#crossLink "Entities"}}Entities{{/crossLink}} when they are ghosted.
             *
             * This {{#crossLink "EmphasisMaterial"}}EmphasisMaterial{{/crossLink}} has
             * an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.ghostMaterial", with all
             * other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "EmphasisMaterial"}}EmphasisMaterial{{/crossLink}} by default.
             * @property ghostMaterial
             * @final
             * @type EmphasisMaterial
             */
            ghostMaterial: {
                get: function () {
                    return this.components["default.ghostMaterial"] ||
                        new xeogl.EmphasisMaterial(this, {
                            id: "default.ghostMaterial",
                            preset: "sepia",
                            isDefault: true
                        });
                }
            },

            /**
             * The Scene's default {{#crossLink "EmphasisMaterial"}}EmphasisMaterial{{/crossLink}} for the appearance of {{#crossLink "Entities"}}Entities{{/crossLink}} when they are highlighted.
             *
             * This {{#crossLink "HighlightMaterial"}}HighlightMaterial{{/crossLink}} has
             * an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.highlightMaterial", with all
             * other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "HighlightMaterial"}}HighlightMaterial{{/crossLink}} by default.
             * @property highlightMaterial
             * @final
             * @type HighlightMaterial
             */
            highlightMaterial: {
                get: function () {
                    return this.components["default.highlightMaterial"] ||
                        new xeogl.EmphasisMaterial(this, {
                            id: "default.highlightMaterial",
                            preset: "yellowHighlight",
                            isDefault: true
                        });
                }
            },

            /**
             * The Scene's default {{#crossLink "EmphasisMaterial"}}EmphasisMaterial{{/crossLink}} for the appearance of {{#crossLink "Entities"}}Entities{{/crossLink}} when they are selected.
             *
             * This {{#crossLink "SelectedMaterial"}}SelectedMaterial{{/crossLink}} has
             * an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.selectedMaterial", with all
             * other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "SelectedMaterial"}}SelectedMaterial{{/crossLink}} by default.
             * @property selectedMaterial
             * @final
             * @type SelectedMaterial
             */
            selectedMaterial: {
                get: function () {
                    return this.components["default.selectedMaterial"] ||
                        new xeogl.EmphasisMaterial(this, {
                            id: "default.selectedMaterial",
                            preset: "greenSelected",
                            isDefault: true
                        });
                }
            },

            /**
             * The Scene's default {{#crossLink "OutlineMaterial"}}OutlineMaterial{{/crossLink}} for the appearance of {{#crossLink "Entities"}}Entities{{/crossLink}} when they are outlined.
             *
             * This {{#crossLink "OutlineMaterial"}}OutlineMaterial{{/crossLink}} has
             * an {{#crossLink "Component/id:property"}}id{{/crossLink}} equal to "default.outlineMaterial", with all
             * other properties initialised to their default values.
             *
             * {{#crossLink "Entity"}}Entities{{/crossLink}} within this Scene are attached to this
             * {{#crossLink "OutlineMaterial"}}OutlineMaterial{{/crossLink}} by default.
             * @property outlineMaterial
             * @final
             * @type OutlineMaterial
             */
            outlineMaterial: {
                get: function () {
                    return this.components["default.outlineMaterial"] ||
                        new xeogl.OutlineMaterial(this, {
                            id: "default.outlineMaterial",
                            isDefault: true
                        });
                }
            },

            /**
             * The {{#crossLink "Viewport"}}{{/crossLink}} belonging to this Scene.
             *
             * @property viewport
             * @final
             * @type Viewport
             */
            viewport: {
                get: function () {
                    return this._viewport;
                }
            },

            /**
             * The {{#crossLink "Lights"}}Lights{{/crossLink}} belonging to this Scene.
             *
             * @property lights
             * @final
             * @type Lights
             */
            lights: {
                get: function () {
                    return this._lights;
                }
            },

            /**
             * The {{#crossLink "Camera"}}Camera{{/crossLink}} belonging to this Scene.
             *
             * @property camera
             * @final
             * @type Camera
             */
            camera: {
                get: function () {
                    return this._camera;
                }
            },

            /**
             * The {{#crossLink "Clips"}}Clips{{/crossLink}} belonging to this Scene.
             *
             * @property clips
             * @final
             * @type Clips
             */
            clips: {
                get: function () {
                    return this._clips;
                }
            },

            /**
             * World-space 3D center of this Scene.
             *
             * @property center
             * @final
             * @type {Float32Array}
             */
            center: {

                get: function () {

                    if (this._aabbDirty) {

                        if (!this._center) {
                            this._center = xeogl.math.AABB3();
                        }

                        var aabb = this.aabb;

                        this._center[0] = (aabb[0] + aabb[3] ) / 2;
                        this._center[1] = (aabb[1] + aabb[4] ) / 2;
                        this._center[2] = (aabb[2] + aabb[5] ) / 2;
                    }

                    return this._center;
                }
            },

            /**
             * World-space axis-aligned 3D boundary (AABB) of this Scene.
             *
             * The AABB is represented by a six-element Float32Array containing the min/max extents of the
             * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
             *
             * @property aabb
             * @final
             * @type {Float32Array}
             */
            aabb: {

                get: function () {

                    if (this._aabbDirty) {

                        if (!this._aabb) {
                            this._aabb = xeogl.math.AABB3();
                        }

                        var xmin = xeogl.math.MAX_DOUBLE;
                        var ymin = xeogl.math.MAX_DOUBLE;
                        var zmin = xeogl.math.MAX_DOUBLE;
                        var xmax = -xeogl.math.MAX_DOUBLE;
                        var ymax = -xeogl.math.MAX_DOUBLE;
                        var zmax = -xeogl.math.MAX_DOUBLE;

                        var aabb;

                        var entities = this.entities;
                        var entity;

                        for (var entityId in entities) {
                            if (entities.hasOwnProperty(entityId)) {

                                entity = entities[entityId];

                                if (!entity.collidable) {
                                    continue;
                                }

                                aabb = entity.aabb;

                                if (!aabb) {
                                    this.error("internal error: entity without aabb: " + entityId);
                                    continue;
                                }

                                if (aabb[0] < xmin) {
                                    xmin = aabb[0];
                                }
                                if (aabb[1] < ymin) {
                                    ymin = aabb[1];
                                }
                                if (aabb[2] < zmin) {
                                    zmin = aabb[2];
                                }
                                if (aabb[3] > xmax) {
                                    xmax = aabb[3];
                                }
                                if (aabb[4] > ymax) {
                                    ymax = aabb[4];
                                }
                                if (aabb[5] > zmax) {
                                    zmax = aabb[5];
                                }
                            }
                        }

                        this._aabb[0] = xmin;
                        this._aabb[1] = ymin;
                        this._aabb[2] = zmin;
                        this._aabb[3] = xmax;
                        this._aabb[4] = ymax;
                        this._aabb[5] = zmax;

                        this._aabbDirty = false;
                    }

                    return this._aabb;
                }
            }
        },

        _setBoundaryDirty: function () {
            if (!this._aabbDirty) {
                this._aabbDirty = true;
                this.fire("boundary");
            }
        },

        /**
         * Attempts to pick an {{#crossLink "Entity"}}Entity{{/crossLink}} in this Scene.
         *
         * Ignores {{#crossLink "Entity"}}Entities{{/crossLink}} with {{#crossLink "Entity/pickable:property"}}pickable{{/crossLink}}
         * set *false*.
         *
         * Picking the {{#crossLink "Entity"}}{{/crossLink}} at the given canvas coordinates:
         *
         * ````javascript
         * var hit = scene.pick({
         *     canvasPos: [23, 131]
         *  });
         *
         * if (hit) { // Picked an Entity
         *     var entity = hit.entity;
         * }
         * ````
         *
         * **Usage:**
         *
         * Picking the {{#crossLink "Entity"}}{{/crossLink}} that intersects a ray cast through the canvas:
         *
         * ````javascript
         * var hit = scene.pick({
         *     pickSurface: true,
         *     canvasPos: [23, 131]
         *  });
         *
         * if (hit) { // Picked an Entity
         *
         *     var entity = hit.entity;
         *
         *     // These properties are only on the hit result when we do a ray-pick:
         *
         *     var primitive = hit.primitive; // Type of primitive that was picked, usually "triangles"
         *     var primIndex = hit.primIndex; // Position of triangle's first index in the picked Entity's Geometry's indices array
         *     var indices = hit.indices; // UInt32Array containing the triangle's vertex indices
         *     var localPos = hit.localPos; // Float32Array containing the picked Local-space position on the triangle
         *     var worldPos = hit.worldPos; // Float32Array containing the picked World-space position on the triangle
         *     var viewPos = hit.viewPos; // Float32Array containing the picked View-space position on the triangle
         *     var bary = hit.bary; // Float32Array containing the picked barycentric position within the triangle
         *     var normal = hit.normal; // Float32Array containing the interpolated normal vector at the picked position on the triangle
         *     var uv = hit.uv; // Float32Array containing the interpolated UV coordinates at the picked position on the triangle
         * }
         * ````
         *
         * Picking the {{#crossLink "Entity"}}{{/crossLink}} that intersects an arbitrarily-aligned World-space ray:
         *
         * ````javascript
         * var hit = scene.pick({
         *     pickSurface: true,       // Picking with arbitrarily-positioned ray
         *     origin: [0,0,-5],    // Ray origin
         *     direction: [0,0,1]   // Ray direction
         * });
         *
         * if (hit) { // Picked an Entity with the ray
         *
         *     var entity = hit.entity;
         *
         *     var primitive = hit.primitive; // Type of primitive that was picked, usually "triangles"
         *     var primIndex = hit.primIndex; // Position of triangle's first index in the picked Entity's Geometry's indices array
         *     var indices = hit.indices; // UInt32Array containing the triangle's vertex indices
         *     var localPos = hit.localPos; // Float32Array containing the picked Local-space position on the triangle
         *     var worldPos = hit.worldPos; // Float32Array containing the picked World-space position on the triangle
         *     var viewPos = hit.viewPos; // Float32Array containing the picked View-space position on the triangle
         *     var bary = hit.bary; // Float32Array containing the picked barycentric position within the triangle
         *     var normal = hit.normal; // Float32Array containing the interpolated normal vector at the picked position on the triangle
         *     var uv = hit.uv; // Float32Array containing the interpolated UV coordinates at the picked position on the triangle
         *     var origin = hit.origin; // Float32Array containing the World-space ray origin
         *     var direction = hit.direction; // Float32Array containing the World-space ray direction
         * }
         * ````
         * @method pick
         *
         * @param {*} params Picking parameters.
         * @param {Boolean} [params.pickSurface=false] Whether to find the picked position on the surface of the Entity.
         * @param {Float32Array} [params.canvasPos] Canvas-space coordinates. When ray-picking, this will override the
         * **origin** and ** direction** parameters and will cause the ray to be fired through the canvas at this position,
         * directly along the negative View-space Z-axis.
         * @param {Float32Array} [params.origin] World-space ray origin when ray-picking. Ignored when canvasPos given.
         * @param {Float32Array} [params.direction] World-space ray direction when ray-picking. Also indicates the length of the ray. Ignored when canvasPos given.
         * @param {Array} [params.include] IDs of {{#crossLink "Entity"}}Entities{{/crossLink}} to pick from amongst. When given, ignores {{#crossLink "Entity"}}Entities{{/crossLink}} whose IDs are not in this list.
         * @param {Array} [params.exclude] IDs of {{#crossLink "Entity"}}Entities{{/crossLink}} to ignore. When given, will pick *through* these {{#crossLink "Entity"}}Entities{{/crossLink}}, as if they were not there.
         * @returns {*} Hit record, returned when an {{#crossLink "Entity"}}{{/crossLink}} is picked, else null. See
         * method comments for description.
         */
        pick: (function () {

            // Cached vectors to avoid garbage collection

            var math = xeogl.math;

            var localRayOrigin = math.vec3();
            var localRayDir = math.vec3();

            var a = math.vec3();
            var b = math.vec3();
            var c = math.vec3();

            var triangleVertices = math.vec3();
            var position = math.vec4();
            var worldPos = math.vec3();
            var viewPos = math.vec3();
            var bary = math.vec3();

            var na = math.vec3();
            var nb = math.vec3();
            var nc = math.vec3();

            var uva = math.vec3();
            var uvb = math.vec3();
            var uvc = math.vec3();

            var tempVec4a = math.vec4();
            var tempVec4b = math.vec4();
            var tempVec4c = math.vec4();

            var tempVec3 = math.vec3();
            var tempVec3b = math.vec3();
            var tempVec3c = math.vec3();
            var tempVec3d = math.vec3();
            var tempVec3e = math.vec3();
            var tempVec3f = math.vec3();
            var tempVec3g = math.vec3();
            var tempVec3h = math.vec3();
            var tempVec3i = math.vec3();
            var tempVec3j = math.vec3();
            var tempVec3k = math.vec3();

            function entityIDsToObjectIDs(scene, entityIds) {
                var objectIds = {};
                var entityId;
                var entity;
                for (var i = 0, len = entityIds.length; i < len; i++) {
                    entityId = entityIds[i];
                    entity = scene.entities[entityId];
                    if (!entity) {
                        scene.warn("pick(): Entity not found: " + entityId);
                        continue;
                    }
                    objectIds[entity._objectId] = true;
                }
                return objectIds;
            }

            return function (params) {

                if (this.canvas.boundary[2] === 0 || this.canvas.boundary[3] === 0) {
                    this.error("Picking not allowed while canvas has zero width or height");
                    return null;
                }

                params = params || {};

                params.pickSurface = params.pickSurface || params.rayPick; // Backwards compatibility

                if (!params.canvasPos && (!params.origin || !params.direction)) {
                    this.warn("picking without canvasPos or ray origin and direction");
                }

                if (params.include) {
                    params.includeObjects = entityIDsToObjectIDs(this, params.include)
                }

                if (params.exclude) {
                    params.excludeObjects = entityIDsToObjectIDs(this, params.exclude)
                }

                var hit = this._renderer.pick(params);

                if (hit) {

                    var entity = this.entities[hit.entity];

                    hit.entity = entity; // Swap string ID for xeogl.Entity

                    if (params.pickSurface) {

                        if (hit.primIndex !== undefined && hit.primIndex > -1) {

                            var geometry = entity.geometry._state;

                            if (geometry.primitiveName === "triangles") {

                                // Triangle picked; this only happens when the
                                // Entity has a Geometry that has primitives of type "triangle"

                                hit.primitive = "triangle";

                                // Get the World-space positions of the triangle's vertices

                                var i = hit.primIndex; // Indicates the first triangle index in the indices array

                                var indices = geometry.indices; // Indices into geometry arrays, not into shared VertexBufs
                                var positions = geometry.positions;

                                var ia3;
                                var ib3;
                                var ic3;

                                if (indices) {

                                    var ia = indices[i + 0];
                                    var ib = indices[i + 1];
                                    var ic = indices[i + 2];

                                    triangleVertices[0] = ia;
                                    triangleVertices[1] = ib;
                                    triangleVertices[2] = ic;

                                    hit.indices = triangleVertices;

                                    ia3 = ia * 3;
                                    ib3 = ib * 3;
                                    ic3 = ic * 3;

                                } else {

                                    ia3 = i * 3;
                                    ib3 = ia3 + 3;
                                    ic3 = ib3 + 3;
                                }

                                a[0] = positions[ia3 + 0];
                                a[1] = positions[ia3 + 1];
                                a[2] = positions[ia3 + 2];

                                b[0] = positions[ib3 + 0];
                                b[1] = positions[ib3 + 1];
                                b[2] = positions[ib3 + 2];

                                c[0] = positions[ic3 + 0];
                                c[1] = positions[ic3 + 1];
                                c[2] = positions[ic3 + 2];

                                if (geometry.quantized) {

                                    // Decompress vertex positions

                                    var positionsDecodeMatrix = geometry.positionsDecodeMatrix;
                                    if (positionsDecodeMatrix) {
                                        math.decompressPosition(a, positionsDecodeMatrix, a);
                                        math.decompressPosition(b, positionsDecodeMatrix, b);
                                        math.decompressPosition(c, positionsDecodeMatrix, c);
                                    }
                                }

                                // Attempt to ray-pick the triangle in local space

                                var canvasPos;

                                if (params.canvasPos) {
                                    canvasPos = params.canvasPos;
                                    hit.canvasPos = params.canvasPos;
                                    math.canvasPosToLocalRay(this.camera, entity, canvasPos, localRayOrigin, localRayDir);

                                } else if (params.origin && params.direction) {
                                    math.worldRayToLocalRay(entity, params.origin, params.direction, localRayOrigin, localRayDir);
                                }

                                math.normalizeVec3(localRayDir);
                                math.rayPlaneIntersect(localRayOrigin, localRayDir, a, b, c, position);

                                // Get Local-space cartesian coordinates of the ray-triangle intersection

                                hit.localPos = position;
                                hit.position = position;

                                // Get interpolated World-space coordinates

                                // Need to transform homogeneous coords

                                tempVec4a[0] = position[0];
                                tempVec4a[1] = position[1];
                                tempVec4a[2] = position[2];
                                tempVec4a[3] = 1;

                                // Get World-space cartesian coordinates of the ray-triangle intersection

                                math.transformVec4(entity.transform.leafMatrix, tempVec4a, tempVec4b);

                                worldPos[0] = tempVec4b[0];
                                worldPos[1] = tempVec4b[1];
                                worldPos[2] = tempVec4b[2];

                                hit.worldPos = worldPos;

                                // Get View-space cartesian coordinates of the ray-triangle intersection

                                math.transformVec4(entity.scene.camera.matrix, tempVec4b, tempVec4c);

                                viewPos[0] = tempVec4c[0];
                                viewPos[1] = tempVec4c[1];
                                viewPos[2] = tempVec4c[2];

                                hit.viewPos = viewPos;

                                // Get barycentric coordinates of the ray-triangle intersection

                                math.cartesianToBarycentric(position, a, b, c, bary);

                                hit.bary = bary;

                                // Get interpolated normal vector

                                var normals = geometry.normals;

                                if (normals) {

                                    if (geometry.quantized) {

                                        // Decompress vertex normals

                                        var ia2 = ia * 2;
                                        var ib2 = ib * 2;
                                        var ic2 = ic * 2;

                                        math.octDecodeVec2(normals.subarray(ia2, ia2 + 2), na);
                                        math.octDecodeVec2(normals.subarray(ib2, ib2 + 2), nb);
                                        math.octDecodeVec2(normals.subarray(ic2, ic2 + 2), nc);

                                    } else {

                                        na[0] = normals[ia3];
                                        na[1] = normals[ia3 + 1];
                                        na[2] = normals[ia3 + 2];

                                        nb[0] = normals[ib3];
                                        nb[1] = normals[ib3 + 1];
                                        nb[2] = normals[ib3 + 2];

                                        nc[0] = normals[ic3];
                                        nc[1] = normals[ic3 + 1];
                                        nc[2] = normals[ic3 + 2];
                                    }

                                    var normal = math.addVec3(math.addVec3(
                                        math.mulVec3Scalar(na, bary[0], tempVec3),
                                        math.mulVec3Scalar(nb, bary[1], tempVec3b), tempVec3c),
                                        math.mulVec3Scalar(nc, bary[2], tempVec3d), tempVec3e);

                                    hit.normal = math.transformVec3(entity.transform.leafNormalMatrix, normal, tempVec3f);
                                }

                                // Get interpolated UV coordinates

                                var uvs = geometry.uv;

                                if (uvs) {

                                    uva[0] = uvs[(ia * 2)];
                                    uva[1] = uvs[(ia * 2) + 1];

                                    uvb[0] = uvs[(ib * 2)];
                                    uvb[1] = uvs[(ib * 2) + 1];

                                    uvc[0] = uvs[(ic * 2)];
                                    uvc[1] = uvs[(ic * 2) + 1];

                                    if (geometry.quantized) {

                                        // Decompress vertex UVs

                                        var uvDecodeMatrix = geometry.uvDecodeMatrix;
                                        if (uvDecodeMatrix) {
                                            math.decompressUV(uva, uvDecodeMatrix, uva);
                                            math.decompressUV(uvb, uvDecodeMatrix, uvb);
                                            math.decompressUV(uvc, uvDecodeMatrix, uvc);
                                        }
                                    }

                                    hit.uv = math.addVec3(
                                        math.addVec3(
                                            math.mulVec2Scalar(uva, bary[0], tempVec3g),
                                            math.mulVec2Scalar(uvb, bary[1], tempVec3h), tempVec3i),
                                        math.mulVec2Scalar(uvc, bary[2], tempVec3j), tempVec3k);
                                }
                            }
                        }
                    }

                    return hit;
                }
            };
        })(),

        /**
         Convenience method which returns the collective axis-aligned boundary of the {{#crossLink "Entity"}}Entities{{/crossLink}}
         and/or {{#crossLink "Model"}}Models{{/crossLink}} with the given IDs.

         When no arguments are given, returns the total boundary of all objects in the scene.

         Only {{#crossLink "Entity"}}Entities{{/crossLink}} with {{#crossLink "Entity/collidable:property"}}collidable{{/crossLink}}
         set ````true```` are included in the boundary.
         
         ## Usage
         
         ````JavaScript
         scene.getAABB(); // Gets collective boundary of all objects in the scene
         scene.getAABB("saw"); // Gets collective boundary of all objects in saw model
         scene.getAABB(["saw", "gearbox"]); // Gets collective boundary of all objects in saw and gearbox models
         scene.getAABB("saw#0.1"); // Get boundary of an object in the saw model
         scene.getAABB(["saw#0.1", "saw#0.2"]); // Get collective boundary of two objects in saw model
         ````

         @method getAABB
         @param {String|String[]} target IDs of models, objects and/or annotations
         @returns {[Number, Number, Number, Number, Number, Number]} An axis-aligned World-space bounding box, given as elements ````[xmin, ymin, zmin, xmax, ymax, zmax]````.
         */
        getAABB: function (target) {
            if (arguments.length === 0 || target === undefined) {
                return this.aabb;
            }
            if (xeogl._isArray(target) && (!xeogl._isString(target[0]))) {
                return target; // AABB
            }
            if (xeogl._isString(target)) {
                target = [target];
            }
            if (target.length === 0) {
                return this.aabb;
            }
            var id;
            var component;
            if (target.length === 1) {
                id = target[0];
                component = this.components[id];
                if (!component) {
                    return this.aabb;
                }
                return component.aabb || this.aabb;
            }
            // Many ids given
            var i;
            var len;
            var xmin = 100000;
            var ymin = 100000;
            var zmin = 100000;
            var xmax = -100000;
            var ymax = -100000;
            var zmax = -100000;
            var aabb;
            var valid = false;
            for (i = 0, len = target.length; i < len; i++) {
                id = target[i];
                component = this.components[id];
                if (component) {
                    aabb = component.aabb;
                    if (!aabb) {
                        continue;
                    }
                }
                if (aabb[0] < xmin) {
                    xmin = aabb[0];
                }
                if (aabb[1] < ymin) {
                    ymin = aabb[1];
                }
                if (aabb[2] < zmin) {
                    zmin = aabb[2];
                }
                if (aabb[3] > xmax) {
                    xmax = aabb[3];
                }
                if (aabb[4] > ymax) {
                    ymax = aabb[4];
                }
                if (aabb[5] > zmax) {
                    zmax = aabb[5];
                }
                valid = true;
            }
            if (valid) {
                var aabb2 = new xeogl.math.AABB3();
                aabb2[0] = xmin;
                aabb2[1] = ymin;
                aabb2[2] = zmin;
                aabb2[3] = xmax;
                aabb2[1 + 3] = ymax;
                aabb2[2 + 3] = zmax;
                return aabb2;
            } else {
                return this.aabb;
            }
        },

        /**
         Resets this Scene to its default state.

         References to any components in this Scene will become invalid.

         @method clear
         */
        clear: function () {  // FIXME: should only clear user-created components

            for (var id in this.components) {
                if (this.components.hasOwnProperty(id)) {

                    // Each component fires "destroyed" as it is destroyed,
                    // which this Scene handles by removing the component

                    this.components[id].destroy();
                }
            }

            // Reinitialise defaults

            this._initDefaults();

            this._dirtyEntities = {};
        },

        _destroy: function () {
            this.clear();
        }
    });

})();
;/**
 * Components for animating state within Scenes.
 *
 * @module xeogl
 * @submodule animation
 */;/**
 A **CameraFlightAnimation** jumps or flies the {{#crossLink "Scene"}}Scene's{{/crossLink}} {{#crossLink "Camera"}}{{/crossLink}} to look at a given target.

 <a href="../../examples/#animation_camera_flight"><img src="http://i.giphy.com/3o7TKP0jN800EQ99EQ.gif"></img></a>

 * TODO: Document behaviour for ortho projection
 * TODO: Update docs for camera refactor, where ortho and perspective components will always be present on camera

 ## Overview

 * Can be made to either fly or jump to its target.
 * While busy flying to a target, it can be stopped, or redirected to fly to a different target.

 A CameraFlightAnimation's target can be:

 * specific ````eye````, ````look```` and ````up```` positions,
 * an axis-aligned World-space bounding box (AABB), or
 * an instance or ID of any {{#crossLink "Component"}}{{/crossLink}} subtype that provides a World-space AABB.

 You can configure its {{#crossLink "CameraFlightAnimation/fit:property"}}{{/crossLink}}
 and {{#crossLink "CameraFlightAnimation/fitFOV:property"}}{{/crossLink}} properties to make it stop at the point where the target
 occupies a certain amount of the field-of-view.

 ## Examples

 * [Flying to random Entities](../../examples/#animation_camera_flight)

 ## Flying to an Entity

 Flying to an {{#crossLink "Entity"}}{{/crossLink}}:

 ````Javascript
 // Create a CameraFlightAnimation that takes one second to fly
 // the default Scene's Camera to each specified target
 var cameraFlight = new xeogl.CameraFlightAnimation({
    fit: true, // Default
    fitFOV: 45, // Default, degrees
    duration: 1 // Default, seconds
 }, function() {
           // Arrived
       });

 // Create a Entity, which gets all the default components
 var entity = new Entity();

 // Fly to the Entity's World-space AABB
 cameraFlight.flyTo(entity);
 ````
 ## Flying to a position

 Flying the CameraFlightAnimation from the previous example to specified eye, look and up positions:

 ````Javascript
 cameraFlight.flyTo({
    eye: [-5,-5,-5],
    look: [0,0,0]
    up: [0,1,0],
    duration: 1 // Default, seconds
 }, function() {
          // Arrived
      });
 ````

 ## Flying to an AABB

 Flying the CameraFlightAnimation from the previous two examples explicitly to the {{#crossLink "Boundary3D"}}Boundary3D's{{/crossLink}}
 axis-aligned bounding box:

 ````Javascript
 cameraFlight.flyTo(entity.aabb);
 ````

 @class CameraFlightAnimation
 @module xeogl
 @submodule animation
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CameraFlightAnimation.
 @param [cfg.fit=true] {Boolean} When true, will ensure that when this CameraFlightAnimation has flown or jumped to a boundary
 it will adjust the distance between the {{#crossLink "Camera"}}{{/crossLink}}'s {{#crossLink "Lookat/eye:property"}}eye{{/crossLink}}
 and {{#crossLink "Lookat/look:property"}}{{/crossLink}} position so as to ensure that the target boundary is filling the view volume.
 @param [cfg.fitFOV=45] {Number} How much field-of-view, in degrees, that a target boundary should
 fill the canvas when fitting the {{#crossLink "Camera"}}Camera{{/crossLink}} to the target boundary. Only applies when the {{#crossLink "Camera"}}Camera{{/crossLink}}'s active projection is a{{#crossLink "Perspective"}}{{/crossLink}}.
 @param [cfg.trail] {Boolean} When true, will cause this CameraFlightAnimation to point the {{#crossLink "Camera"}}{{/crossLink}} in the direction that it is travelling.
 @param [cfg.duration=1] {Number} Flight duration, in seconds, when calling {{#crossLink "CameraFlightAnimation/flyTo:method"}}{{/crossLink}}.
 @extends Component
 */
(function () {

    "use strict";

    var math = xeogl.math;

    xeogl.CameraFlightAnimation = xeogl.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "xeogl.CameraFlightAnimation",

        _init: function (cfg) {

            // Shows a wireframe box for target AABBs
            this._aabbHelper = this.create({
                type: "xeogl.Entity",
                geometry: this.create({
                    type: "xeogl.AABBGeometry"
                }),
                material: this.create({
                    type: "xeogl.PhongMaterial",
                    diffuse: [0, 0, 0],
                    ambient: [0, 0, 0],
                    specular: [0, 0, 0],
                    emissive: [0.5, 1.0, 0.5],
                    lineWidth: 2
                }),
                visible: false,
                collidable: false
            });

            // Shows a wireframe box for target AABBs
            this._obbHelper = this.create({
                type: "xeogl.Entity",
                geometry: this.create({
                    type: "xeogl.OBBGeometry",
                    material: this.create({
                        type: "xeogl.PhongMaterial",
                        diffuse: [0, 0, 0],
                        ambient: [0, 0, 0],
                        specular: [0, 0, 0],
                        emissive: [0.5, 1.0, 0.5],
                        lineWidth: 2
                    })
                }),
                visible: false,
                collidable: false // Effectively has no boundary
            });

            this._look1 = math.vec3();
            this._eye1 = math.vec3();
            this._up1 = math.vec3();

            this._look2 = math.vec3();
            this._eye2 = math.vec3();
            this._up2 = math.vec3();

            this._orthoScale1 = 1;
            this._orthoScale2 = 1;

            this._flying = false;
            this._flyEyeLookUp = false;
            this._flyingEye = false;
            this._flyingLook = false;
            this._flyingUp = false;

            this._callback = null;
            this._callbackScope = null;

            this._onTick = null;

            this._time1 = null;
            this._time2 = null;

            this.easing = cfg.easing !== false;

            this.duration = cfg.duration;
            this.fit = cfg.fit;
            this.fitFOV = cfg.fitFOV;
            this.trail = cfg.trail;
        },

        /**
         * Begins flying the {{#crossLink "Camera"}}{{/crossLink}}'s {{#crossLink "Camera"}}{{/crossLink}} to the given target.
         *
         *  * When the target is a boundary, the {{#crossLink "Camera"}}{{/crossLink}} will fly towards the target
         *    and stop when the target fills most of the canvas.
         *  * When the target is an explicit {{#crossLink "Camera"}}{{/crossLink}} position, given as ````eye````, ````look```` and ````up````
         *    vectors, then this CameraFlightAnimation will interpolate the {{#crossLink "Camera"}}{{/crossLink}} to that target and stop there.
         * @method flyTo
         * @param [params=scene]  {*|Component} Either a parameters object or a {{#crossLink "Component"}}{{/crossLink}} subtype that has an AABB.
         * @param[params.arc=0]  {Number} Factor in range [0..1] indicating how much the
         * {{#crossLink "Lookat/eye:property"}}Camera's eye{{/crossLink}} position will
         * swing away from its {{#crossLink "Lookat/eye:property"}}look{{/crossLink}} position as it flies to the target.
         * @param [params.component] {Number|String|Component} ID or instance of a component to fly to. Defaults to the entire {{#crossLink "Scene"}}{{/crossLink}}.
         * @param [params.aabb] {*}  World-space axis-aligned bounding box (AABB) target to fly to.
         * @param [params.eye] {Float32Array} Position to fly the eye position to.
         * @param [params.look] {Float32Array} Position to fly the look position to.
         * @param [params.up] {Float32Array} Position to fly the up vector to.
         * @param [params.fit=true] {Boolean} Whether to fit the target to the view volume. Overrides {{#crossLink "CameraFlightAnimation/fit:property"}}{{/crossLink}}.
         * @param [params.fitFOV] {Number} How much of field-of-view, in degrees, that a target {{#crossLink "Entity"}}{{/crossLink}} or its AABB should
         * fill the canvas on arrival. Overrides {{#crossLink "CameraFlightAnimation/fitFOV:property"}}{{/crossLink}}.
         * @param [params.duration] {Number} Flight duration in seconds.  Overrides {{#crossLink "CameraFlightAnimation/duration:property"}}{{/crossLink}}.
         * @param [params.orthoScale] {Number} TODO: document this
         * @param [callback] {Function} Callback fired on arrival
         * @param [scope] {Object} Optional scope for callback
         */
        flyTo: (function () {

            var tempVec3 = math.vec3();

            return function (params, callback, scope) {

                params = params || this.scene;

                if (this._flying) {
                    this.stop();
                }

                this._flying = false;

                this._callback = callback;
                this._callbackScope = scope;

                var camera = this.scene.camera;

                this._eye1[0] = camera.eye[0];
                this._eye1[1] = camera.eye[1];
                this._eye1[2] = camera.eye[2];

                this._look1[0] = camera.look[0];
                this._look1[1] = camera.look[1];
                this._look1[2] = camera.look[2];

                this._up1[0] = camera.up[0];
                this._up1[1] = camera.up[1];
                this._up1[2] = camera.up[2];

                this._orthoScale1 = camera.ortho.scale;
                this._orthoScale2 = params.orthoScale || this._orthoScale1;

                var aabb;
                var eye;
                var look;
                var up;
                var componentId;

                if (params.aabb) {
                    aabb = params.aabb;

                } else if (params.length === 6) {
                    aabb = params;

                } else if ((params.eye && params.look) || params.up) {
                    eye = params.eye;
                    look = params.look;
                    up = params.up;

                } else if (params.eye) {
                    eye = params.eye;

                } else if (params.look) {
                    look = params.look;

                } else {

                    // Argument must be an instance or ID of a Component (subtype)

                    var component = params;

                    if (xeogl._isNumeric(component) || xeogl._isString(component)) {

                        componentId = component;

                        component = this.scene.components[componentId];

                        if (!component) {
                            this.error("Component not found: " + xeogl._inQuotes(componentId));
                            if (callback) {
                                if (scope) {
                                    callback.call(scope);
                                } else {
                                    callback();
                                }
                            }
                            return;
                        }
                    }

                    aabb = component.aabb || this.scene.aabb;
                }

                var offset = params.offset;

                if (aabb) {

                    if (aabb[3] < aabb[0] || aabb[4] < aabb[1] || aabb[5] < aabb[2]) {

                        // Don't fly to an inverted boundary
                        return;
                    }

                    if (aabb[3] === aabb[0] && aabb[4] === aabb[1] && aabb[5] === aabb[2]) {

                        // Don't fly to an empty boundary
                        return;
                    }


                    // Show boundary

                    if (params.showAABB !== false) {
                        this._aabbHelper.geometry.targetAABB = aabb;
                        this._aabbHelper.visible = true;
                    }

                    var aabbCenter = math.getAABB3Center(aabb);

                    this._look2 = params.look || aabbCenter;

                    if (offset) {
                        this._look2[0] += offset[0];
                        this._look2[1] += offset[1];
                        this._look2[2] += offset[2];
                    }

                    var eyeLookVec = math.subVec3(this._eye1, this._look1, tempVec3);
                    var eyeLookVecNorm = math.normalizeVec3(eyeLookVec);
                    var diag = (params.look && false) ? math.getAABB3DiagPoint(aabb, params.look) : math.getAABB3Diag(aabb);
                    var fitFOV = params.fitFOV || this._fitFOV;
                    var sca = Math.abs(diag / Math.tan(fitFOV * xeogl.math.DEGTORAD));

                    this._orthoScale2 = diag * 1.1;

                    this._eye2[0] = this._look2[0] + (eyeLookVecNorm[0] * sca);
                    this._eye2[1] = this._look2[1] + (eyeLookVecNorm[1] * sca);
                    this._eye2[2] = this._look2[2] + (eyeLookVecNorm[2] * sca);

                    this._up2[0] = this._up1[0];
                    this._up2[1] = this._up1[1];
                    this._up2[2] = this._up1[2];

                    this._flyEyeLookUp = false;

                } else if (eye || look || up) {

                    this._flyEyeLookUp = !!eye && !!look && !!up;
                    this._flyingEye = !!eye && !look;
                    this._flyingLook = !!look && !eye;

                    if (look) {
                        this._look2[0] = look[0];
                        this._look2[1] = look[1];
                        this._look2[2] = look[2];
                    }

                    if (eye) {
                        this._eye2[0] = eye[0];
                        this._eye2[1] = eye[1];
                        this._eye2[2] = eye[2];
                    }

                    if (up) {
                        this._up2[0] = up[0];
                        this._up2[1] = up[1];
                        this._up2[2] = up[2];
                    }
                }

                this.fire("started", params, true);

                this._time1 = Date.now();
                this._time2 = this._time1 + (params.duration ? params.duration * 1000 : this._duration);

                this._flying = true; // False as soon as we stop

                xeogl.scheduleTask(this._update, this);
            };
        })(),

        /**
         * Jumps the {{#crossLink "Camera"}}{{/crossLink}}'s {{#crossLink "Camera"}}{{/crossLink}} to the given target.
         *
         *  * When the target is a boundary, this CameraFlightAnimation will position the {{#crossLink "Camera"}}{{/crossLink}}
         *  at where the target fills most of the canvas.
         *  * When the target is an explicit {{#crossLink "Camera"}}{{/crossLink}} position, given as ````eye````, ````look```` and ````up````
         *  vectors, then this CameraFlightAnimation will jump the {{#crossLink "Camera"}}{{/crossLink}} to that target.
         *
         * @method flyTo
         * @param params  {*|Component} Either a parameters object or a {{#crossLink "Component"}}{{/crossLink}} subtype that has a World-space AABB.
         * @param[params.arc=0]  {Number} Factor in range [0..1] indicating how much the
         * {{#crossLink "Camera/eye:property"}}Camera's eye{{/crossLink}} position will
         * swing away from its {{#crossLink "Camera/eye:property"}}look{{/crossLink}} position as it flies to the target.
         * @param [params.component] {Number|String|Component} ID or instance of a component to fly to.
         * @param [params.aabb] {*}  World-space axis-aligned bounding box (AABB) target to fly to.
         * @param [params.eye] {Float32Array} Position to fly the eye position to.
         * @param [params.look] {Float32Array} Position to fly the look position to.
         * @param [params.up] {Float32Array} Position to fly the up vector to.
         * @param [params.fitFOV] {Number} How much of field-of-view, in degrees, that a target {{#crossLink "Entity"}}{{/crossLink}} or its AABB should
         * fill the canvas on arrival. Overrides {{#crossLink "CameraFlightAnimation/fitFOV:property"}}{{/crossLink}}.
         * @param [params.fit] {Boolean} Whether to fit the target to the view volume. Overrides {{#crossLink "CameraFlightAnimation/fit:property"}}{{/crossLink}}.
         */
        jumpTo: function (params) {
            var self = this;
            //           xeogl.scheduleTask(function () {  // Ensures that required asynch boundaries are built first
            self._jumpTo(params);
            //         });
        },

        _jumpTo: (function () {

            var newEye = math.vec3();
            var newLook = math.vec3();
            var newUp = math.vec3();
            var newLookEyeVec = math.vec3();
            var tempVec3e = math.vec3();

            return function (params) {

                if (this._flying) {
                    this.stop();
                }

                var camera = this.scene.camera;

                var aabb;
                var componentId;

                if (params.aabb) { // Boundary3D

                    aabb = params.aabb;

                } else if (params.length === 6) { // AABB

                    aabb = params;

                } else if (params.eye || params.look || params.up) { // Camera pose

                    newEye = params.eye;
                    newLook = params.look;
                    newUp = params.up;

                } else {

                    // Argument must be an instance or ID of a Component (subtype)

                    var component = params;

                    if (xeogl._isNumeric(component) || xeogl._isString(component)) {

                        componentId = component;

                        component = this.scene.components[componentId];

                        if (!component) {
                            this.error("Component not found: " + xeogl._inQuotes(componentId));
                            return;
                        }
                    }

                    aabb = component.aabb || this.scene.aabb;
                }

                var offset = params.offset;

                if (aabb) {

                    var diag;

                    if (aabb[3] <= aabb[0] || aabb[4] <= aabb[1] || aabb[5] <= aabb[2]) {

                        // Don't fly to an empty boundary
                        return;
                    }

                    diag = math.getAABB3Diag(aabb);
                    math.getAABB3Center(aabb, newLook);

                    if (this._trail) {
                        math.subVec3(camera.look, newLook, newLookEyeVec);
                    } else {
                        math.subVec3(camera.eye, camera.look, newLookEyeVec);
                    }

                    math.normalizeVec3(newLookEyeVec);

                    var dist;

                    var fit = (params.fit !== undefined) ? params.fit : this._fit;
                    if (fit) {
                        dist = Math.abs((diag) / Math.tan((params.fitFOV || this._fitFOV) * xeogl.math.DEGTORAD));

                    } else {
                        dist = math.lenVec3(math.subVec3(camera.eye, camera.look, tempVec3e));
                    }

                    math.mulVec3Scalar(newLookEyeVec, dist);

                    camera.eye = math.addVec3(newLook, newLookEyeVec, newEye);
                    camera.look = newLook;

                } else if (newEye || newLook || newUp) {

                    if (newEye) {
                        camera.eye = newEye;
                    }

                    if (newLook) {
                        camera.look = newLook;
                    }

                    if (newUp) {
                        camera.up = newUp;
                    }
                }
            };
        })(),

        _update: (function () {

            var newLookEyeVec = math.vec3();
            var newEye = math.vec3();
            var newLook = math.vec3();
            var newUp = math.vec3();
            var lookEyeVec = math.vec3();

            return function () {

                if (!this._flying) {
                    return;
                }

                var time = Date.now();

                var t = (time - this._time1) / (this._time2 - this._time1);

                var stopping = (t >= 1);

                if (t > 1) {
                    t = 1;
                }

                t = this.easing ? this._ease(t, 0, 1, 1) : t;

                var camera = this.scene.camera;


                if (this._flyingEye || this._flyingLook) {

                    if (this._flyingEye) {
                        math.subVec3(camera.eye, camera.look, newLookEyeVec);
                        camera.eye = math.lerpVec3(t, 0, 1, this._eye1, this._eye2, newEye);
                        camera.look = math.subVec3(newEye, newLookEyeVec, newLook);

                    } else if (this._flyingLook) {
                        camera.look = math.lerpVec3(t, 0, 1, this._look1, this._look2, newLook);
                    //    camera.eye = math.addVec3(newLook, newLookEyeVec, newEye);
                        camera.up = math.lerpVec3(t, 0, 1, this._up1, this._up2, newUp);
                    }

                } else if (this._flyEyeLookUp) {

                    camera.eye = math.lerpVec3(t, 0, 1, this._eye1, this._eye2, newEye);
                    camera.look = math.lerpVec3(t, 0, 1, this._look1, this._look2, newLook);
                    camera.up = math.lerpVec3(t, 0, 1, this._up1, this._up2, newUp);
                } else {

                    math.lerpVec3(t, 0, 1, this._look1, this._look2, newLook);

                    var dist;

                    if (this._trail) {
                        math.subVec3(newLook, camera.look, newLookEyeVec);

                    } else {
                        math.subVec3(camera.eye, camera.look, newLookEyeVec);
                    }

                    math.normalizeVec3(newLookEyeVec);
                    math.lerpVec3(t, 0, 1, this._eye1, this._eye2, newEye);
                    math.subVec3(newEye, newLook, lookEyeVec);
                    dist = math.lenVec3(lookEyeVec);
                    math.mulVec3Scalar(newLookEyeVec, dist);

                    camera.eye = math.addVec3(newLook, newLookEyeVec, newEye);
                    camera.look = newLook;
                }

                this.scene.camera.ortho.scale = this._orthoScale1 + (t * (this._orthoScale2 - this._orthoScale1));

                if (stopping) {
                    this.stop();
                    return;
                }

                xeogl.scheduleTask(this._update, this); // Keep flying
            };
        })(),

        // Quadratic easing out - decelerating to zero velocity
        // http://gizma.com/easing

        _ease: function (t, b, c, d) {
            t /= d;
            return -c * t * (t - 2) + b;
        },

        /**
         * Stops an earlier flyTo, fires arrival callback.
         * @method stop
         */
        stop: function () {

            if (!this._flying) {
                return;
            }

            this._aabbHelper.visible = false;

            this._flying = false;

            this._time1 = null;
            this._time2 = null;

            var callback = this._callback;

            if (callback) {

                this._callback = null;

                if (this._callbackScope) {
                    callback.call(this._callbackScope);
                } else {
                    callback();
                }
            }

            this.fire("stopped", true, true);
        },

        /**
         * Cancels an earlier flyTo without calling the arrival callback.
         * @method cancel
         */
        cancel: function () {

            if (!this._flying) {
                return;
            }

            this._aabbHelper.visible = false;

            this._flying = false;

            this._time1 = null;
            this._time2 = null;

            if (this._callback) {
                this._callback = null;
            }

            this.fire("canceled", true, true);
        },

        _props: {

            /**
             * Flight duration, in seconds, when calling {{#crossLink "CameraFlightAnimation/flyTo:method"}}{{/crossLink}}.
             *
             * Stops any flight currently in progress.
             *
             * @property duration
             * @default 0.5
             * @type Number
             */
            duration: {

                set: function (value) {
                    this._duration = value ? (value * 1000.0) : 500;

                    this.stop();
                },

                get: function () {
                    return this._duration / 1000.0;
                }
            },

            /**
             * When true, will ensure that this CameraFlightAnimation is flying to a boundary it will always adjust the distance between the
             * {{#crossLink "CameraFlightAnimation/camera:property"}}camera{{/crossLink}}'s {{#crossLink "Lookat/eye:property"}}eye{{/crossLink}}
             * and {{#crossLink "Lookat/look:property"}}{{/crossLink}}
             * so as to ensure that the target boundary is always filling the view volume.
             *
             * When false, the eye will remain at its current distance from the look position.
             *
             * @property fit
             * @type Boolean
             * @default true
             */
            fit: {

                set: function (value) {
                    this._fit = value !== false;
                },

                get: function () {
                    return this._fit;
                }
            },


            /**
             * How much of the perspective field-of-view, in degrees, that a target {{#crossLink "Entity"}}{{/crossLink}} or its AABB should
             * fill the canvas when calling {{#crossLink "CameraFlightAnimation/flyTo:method"}}{{/crossLink}} or {{#crossLink "CameraFlightAnimation/jumpTo:method"}}{{/crossLink}}.
             *
             * @property fitFOV
             * @default 45
             * @type Number
             */
            fitFOV: {

                set: function (value) {
                    this._fitFOV = value || 45;
                },

                get: function () {
                    return this._fitFOV;
                }
            },

            /**
             * When true, will cause this CameraFlightAnimation to point the {{#crossLink "CameraFlightAnimation/camera:property"}}{{/crossLink}}
             * in the direction that it is travelling.
             *
             * @property trail
             * @type Boolean
             * @default false
             */
            trail: {

                set: function (value) {
                    this._trail = !!value;
                },

                get: function () {
                    return this._trail;
                }
            }
        },

        _destroy: function () {
            this.stop();
        }
    });

})();
;/**
 A **Canvas** manages a {{#crossLink "Scene"}}Scene{{/crossLink}}'s HTML canvas and its WebGL context.

 ## Overview

 * Each {{#crossLink "Scene"}}Scene{{/crossLink}} provides a Canvas as a read-only property on itself.
 * When a {{#crossLink "Scene"}}Scene{{/crossLink}} is configured with the ID of
 an existing <a href="http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">HTMLCanvasElement</a>, then
 the Canvas will bind to that, otherwise the Canvas will automatically create its own.
 * A Canvas will fire a {{#crossLink "Canvas/boundary:event"}}{{/crossLink}} event whenever
 the <a href="http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">HTMLCanvasElement</a> resizes.
 * A Canvas is responsible for obtaining a WebGL context from
 the <a href="http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">HTMLCanvasElement</a>.
 * A Canvas also fires a {{#crossLink "Canvas/webglContextLost:event"}}{{/crossLink}} event when the WebGL context is
 lost, and a {{#crossLink "Canvas/webglContextRestored:event"}}{{/crossLink}} when it is restored again.
 * The various components within the parent {{#crossLink "Scene"}}Scene{{/crossLink}} will transparently recover on
 the {{#crossLink "Canvas/webglContextRestored:event"}}{{/crossLink}} event.

 <img src="../../../assets/images/Canvas.png"></img>

 A Canvas also has

 * a {{#crossLink "Progress"}}{{/crossLink}}, which shows a busy progress when a {{#crossLink "Model"}}{{/crossLink}}
 is loading, or when directed by application logic, and

 ## Examples

 * [Multiple canvases/scenes in a page](../../examples/#scenes_multipleScenes)
 * [Taking canvas snapshots](../../examples/#canvas_snapshot)
 * [Transparent canvas with background image](../../examples/#canvas_transparent)
 * [Canvas with multiple viewports](../../examples/#canvas_multipleViewports)

 ## Usage

 In the example below, we're creating a {{#crossLink "Scene"}}Scene{{/crossLink}} without specifying an HTML canvas element
 for it. This causes the {{#crossLink "Scene"}}Scene{{/crossLink}}'s Canvas component to create its own default element
 within the page. Then we subscribe to various events fired by that Canvas component.

 ```` javascript
 var scene = new xeogl.Scene();

 // Get the Canvas off the Scene
 // Since we did not configure the Scene with the ID of a DOM canvas element,
 // the Canvas will create its own canvas element in the DOM
 var canvas = scene.canvas;

 // Get the WebGL context off the Canvas
 var gl = canvas.gl;

 // Subscribe to Canvas size updates
 canvas.on("boundary", function(boundary) {
    //...
 });

 // Subscribe to WebGL context loss events on the Canvas
 canvas.on("webglContextLost", function() {
        //...
     });

 // Subscribe to WebGL context restored events on the Canvas
 canvas.on("webglContextRestored", function(gl) {
        var newContext = gl;
        //...
     });
 ````

 When we want to bind the Canvas to an existing HTML canvas element, configure the
 {{#crossLink "Scene"}}{{/crossLink}} with the ID of the element, like this:

 ```` javascript
 // Create a Scene, this time configuring it with the
 // ID of an existing DOM canvas element
 var scene = new xeogl.Scene({
          canvasId: "myCanvas"
     });

 // ..and the rest of this example can be the same as the previous example.

 ````

 The {{#crossLink "Scene"}}{{/crossLink}} will attempt to get use WebGL 2, or fall back on WebGL 1
 if that's absent. If you just want WebGL 1, disable WebGL 2 like so:

 ```` javascript
 var scene = new xeogl.Scene({
          canvasId: "myCanvas",
          webgl2 : true
     });

 // ..and the rest of this example can be the same as the previous examples.

 ````


 @class Canvas
 @module xeogl
 @submodule canvas
 @static
 @param {Scene} scene Parent scene
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Canvas = xeogl.Component.extend({

        type: "xeogl.Canvas",

        serializable: false,

        // Names of recognised WebGL contexts
        _WEBGL_CONTEXT_NAMES: [
            "webgl",
            "experimental-webgl",
            "webkit-3d",
            "moz-webgl",
            "moz-glweb20"
        ],

        _init: function (cfg) {

            /**
             * The HTML canvas. When the {{#crossLink "Viewer"}}{{/crossLink}} was configured with the ID of an existing canvas within the DOM,
             * then this property will be that element, otherwise it will be a full-page canvas that this Canvas has
             * created by default, with a z-index of -10000.
             *
             * @property canvas
             * @type {HTMLCanvasElement}
             * @final
             */
            this.canvas = null;

            /**
             * The WebGL rendering context.
             *
             * @property gl
             * @type {WebGLRenderingContext}
             * @final
             */
            this.gl = null;

            /**
             * True when WebGL 2 support is enabled.
             *
             * @property webgl2
             * @type {Boolean}
             * @final
             */
            this.webgl2 = false; // Will set true in _initWebGL if WebGL is requested and we succeed in getting it.

            /**
             * Indicates whether this Canvas is transparent.
             *
             * @property transparent
             * @type {Boolean}
             * @default {false}
             * @final
             */
            this.transparent = !!cfg.transparent;

            /**
             * Attributes for the WebGL context
             *
             * @type {{}|*}
             */
            this.contextAttr = cfg.contextAttr || {};
            this.contextAttr.alpha = this.transparent;

            if (this.contextAttr.preserveDrawingBuffer === undefined || this.contextAttr.preserveDrawingBuffer === null) {
                this.contextAttr.preserveDrawingBuffer = false;
            }

            this.contextAttr.stencil = false;
            this.contextAttr.antialias = true;
            this.contextAttr.premultipliedAlpha = this.contextAttr.premultipliedAlpha !== false;
            this.contextAttr.antialias = this.contextAttr.antialias !== false;

            if (!cfg.canvas) {

                // Canvas not supplied, create one automatically

                this._createCanvas();

            } else {

                // Canvas supplied

                if (xeogl._isString(cfg.canvas)) {

                    // Canvas ID supplied - find the canvas

                    this.canvas = document.getElementById(cfg.canvas);

                    if (!this.canvas) {

                        // Canvas not found - create one automatically

                        this.error("Canvas element not found: " + xeogl._inQuotes(cfg.canvas)
                            + " - creating default canvas instead.");

                        this._createCanvas();
                    }

                } else {

                    this.canvas = cfg.canvas;
                }
            }

            if (!this.canvas) {

                this.error("Faied to create canvas");

                return;
            }

            // If the canvas uses css styles to specify the sizes make sure the basic
            // width and height attributes match or the WebGL context will use 300 x 150

            this.canvas.width = this.canvas.clientWidth;
            this.canvas.height = this.canvas.clientHeight;

            /**
             * Boundary of the Canvas in absolute browser window coordinates.
             *
             * ### Usage:
             *
             * ````javascript
             * var boundary = myScene.canvas.boundary;
             *
             * var xmin = boundary[0];
             * var ymin = boundary[1];
             * var width = boundary[2];
             * var height = boundary[3];
             * ````
             *
             * @property boundary
             * @type {{Array of Number}}
             * @final
             */
            this.boundary = [
                this.canvas.offsetLeft, this.canvas.offsetTop,
                this.canvas.clientWidth, this.canvas.clientHeight
            ];

            this._createBackground();

            // Get WebGL context

            this._initWebGL(cfg);

            // Bind context loss and recovery handlers

            var self = this;

            this.canvas.addEventListener("webglcontextlost",
                function () {

                    /**
                     * Fired whenever the WebGL context has been lost
                     * @event webglContextLost
                     */
                    self.fire("webglContextLost");
                },
                false);

            this.canvas.addEventListener("webglcontextrestored",
                function () {
                    self._initWebGL();
                    if (self.gl) {

                        /**
                         * Fired whenever the WebGL context has been restored again after having previously being lost
                         * @event webglContextRestored
                         * @param value The WebGL context object
                         */
                        self.fire("webglContextRestored", self.gl);
                    }
                },
                false);

            // Publish canvas size and position changes on each scene tick

            var lastWindowWidth = null;
            var lastWindowHeight = null;

            var lastCanvasWidth = null;
            var lastCanvasHeight = null;

            var lastCanvasOffsetLeft = null;
            var lastCanvasOffsetTop = null;

            var lastParent = null;

            this._tick = this.scene.on("tick", function () {

                var canvas = self.canvas;

                var newWindowSize = (window.innerWidth !== lastWindowWidth || window.innerHeight !== lastWindowHeight);
                var newCanvasSize = (canvas.clientWidth !== lastCanvasWidth || canvas.clientHeight !== lastCanvasHeight);
                var newCanvasPos = (canvas.offsetLeft !== lastCanvasOffsetLeft || canvas.offsetTop !== lastCanvasOffsetTop);

                var parent = canvas.parentElement;
                var newParent = (parent !== lastParent);

                if (newWindowSize || newCanvasSize || newCanvasPos || newParent) {

                    self._spinner._adjustPosition();

                    if (newCanvasSize || newCanvasPos) {

                        var newWidth = canvas.clientWidth;
                        var newHeight = canvas.clientHeight;

                        // TODO: Wasteful to re-count pixel size of each canvas on each canvas' resize
                        if (newCanvasSize) {
                            var countPixels = 0;
                            var scene;
                            for (var sceneId in xeogl.scenes) {
                                if (xeogl.scenes.hasOwnProperty(sceneId)) {
                                    scene = xeogl.scenes[sceneId];
                                    countPixels += scene.canvas.canvas.clientWidth * scene.canvas.canvas.clientHeight;
                                }
                            }
                            xeogl.stats.memory.pixels = countPixels;

                            canvas.width = canvas.clientWidth;
                            canvas.height = canvas.clientHeight;
                        }

                        var boundary = self.boundary;

                        boundary[0] = canvas.offsetLeft;
                        boundary[1] = canvas.offsetTop;
                        boundary[2] = newWidth;
                        boundary[3] = newHeight;

                        /**
                         * Fired whenever this Canvas's {{#crossLink "Canvas/boundary:property"}}{{/crossLink}} property changes.
                         *
                         * @event boundary
                         * @param value The property's new value
                         */
                        self.fire("boundary", boundary);

                        lastCanvasWidth = newWidth;
                        lastCanvasHeight = newHeight;
                    }

                    if (newWindowSize) {
                        lastWindowWidth = window.innerWidth;
                        lastWindowHeight = window.innerHeight;
                    }

                    if (newCanvasPos) {
                        lastCanvasOffsetLeft = canvas.offsetLeft;
                        lastCanvasOffsetTop = canvas.offsetTop;
                    }

                    lastParent = parent;
                }
            });

            this.canvas.oncontextmenu = function (e) {
                e.preventDefault();
            };

            this._spinner = new xeogl.Spinner(this.scene, {
                canvas: this.canvas
            });

            // Set property, see definition further down
            this.backgroundColor = cfg.backgroundColor;
            this.backgroundImage = cfg.backgroundImage;
        },

        /**
         * Creates a default canvas in the DOM.
         * @private
         */
        _createCanvas: function () {

            var canvasId = "xeogl-canvas-" + xeogl.math.createUUID();
            var body = document.getElementsByTagName("body")[0];
            var div = document.createElement('div');

            var style = div.style;
            style.height = "100%";
            style.width = "100%";
            style.padding = "0";
            style.margin = "0";
            style.background = "rgba(0,0,0,0);";
            style.float = "left";
            style.left = "0";
            style.top = "0";
            style.position = "absolute";
            style.opacity = "1.0";
            style["z-index"] = "-10000";

            div.innerHTML += '<canvas id="' + canvasId + '" style="width: 100%; height: 100%; float: left; margin: 0; padding: 0;"></canvas>';

            body.appendChild(div);

            this.canvas = document.getElementById(canvasId);
        },

        /**
         * Creates a image element behind the canvas, for purpose of showing a custom background.
         * @private
         */
        _createBackground: function () {

            var div = document.createElement('div');
            var style = div.style;
            style.padding = "0";
            style.margin = "0";
            style.background = null;
            style.backgroundImage = null;
            style.float = "left";
            style.left = "0";
            style.top = "0";
            style.width = "100%";
            style.height = "100%";
            style.position = "absolute";
            style.opacity = 1;
            style["z-index"] = "-20000";

            this.canvas.parentElement.appendChild(div);

            this._backgroundElement = div;
        },

        _getElementXY: function (e) {
            var x = 0, y = 0;
            while (e) {
                x += (e.offsetLeft - e.scrollLeft);
                y += (e.offsetTop - e.scrollTop);
                e = e.offsetParent;
            }
            return {x: x, y: y};
        },

        /**
         * Initialises the WebGL context
         * @private
         */
        _initWebGL: function (cfg) {

            // Default context attribute values

            if (false && cfg.webgl2) {
                try {
                    this.gl = this.canvas.getContext("webgl2", this.contextAttr);
                } catch (e) { // Try with next context name
                }
                if (!this.gl) {
                    this.warn('Failed to get a WebGL 2 context - defaulting to WebGL 1.');
                } else {
                    this.webgl2 = true;
                }
            }

            if (!this.gl) {
                for (var i = 0; !this.gl && i < this._WEBGL_CONTEXT_NAMES.length; i++) {
                    try {
                        this.gl = this.canvas.getContext(this._WEBGL_CONTEXT_NAMES[i], this.contextAttr);
                    } catch (e) { // Try with next context name
                    }
                }
            }

            if (!this.gl) {

                this.error('Failed to get a WebGL context');

                /**
                 * Fired whenever the canvas failed to get a WebGL context, which probably means that WebGL
                 * is either unsupported or has been disabled.
                 * @event webglContextFailed
                 */
                this.fire("webglContextFailed", true, true);
            }

            if (this.gl) {
                if (xeogl.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_standard_derivatives"]) { // For normal mapping
                    this.gl.getExtension("OES_standard_derivatives");
                    this.gl.hint(this.gl.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, this.gl.FASTEST)
                }
            }
        },

        /**
         Returns a snapshot of this Canvas as a Base64-encoded image.

         When a callback is given, this method will capture the snapshot asynchronously, on the next animation frame,
         and return it via the callback.

         When no callback is given, this method captures and returns the snapshot immediately. Note that is only
         possible when you have configured the Canvas's {{#crossLink "Scene"}}Scene{{/crossLink}} to preserve the
         WebGL drawing buffer, which has a performance overhead.

         #### Usage:

         ````javascript
         // Get snapshot asynchronously
         myScene.canvas.getSnapshot({
             width: 500, // Defaults to size of canvas
             height: 500,
             format: "png" // Options are "jpeg" (default), "png" and "bmp"
         }, function(imageDataURL) {
             imageElement.src = imageDataURL;
         });

         // Get snapshot synchronously, requires that Scene be
         // configured with preserveDrawingBuffer; true
         imageElement.src = myScene.canvas.getSnapshot({
             width: 500,
             height: 500,
             format: "png"
         });
         ````
         @method getSnapshot
         @param {*} [params] Capture options.
         @param {Number} [params.width] Desired width of result in pixels - defaults to width of canvas.
         @param {Number} [params.height] Desired height of result in pixels - defaults to height of canvas.
         @param {String} [params.format="jpeg"] Desired format; "jpeg", "png" or "bmp".
         @param {Function} [ok] Callback to return the image data when taking a snapshot asynchronously.
         @returns {String} String-encoded image data when taking the snapshot synchronously. Returns null when the ````ok```` callback is given.
         */
        getSnapshot: function (params, ok) {

            if (!this.canvas) {
                this.error("Can't get snapshot - no canvas.");
                ok(null);
                return;
            }

            if (ok) { // Asynchronous
                var self = this;
                requestAnimationFrame(function () {
                    self.scene.render(true); // Force-render a frame
                    ok(self._getSnapshot(params));
                });
            } else {
                return this._getSnapshot(params);
            }
        },

        _getSnapshot: function (params) {
            params = params || {};
            var width = params.width || this.canvas.width;
            var height = params.height || this.canvas.height;
            var format = params.format || "jpeg";
            var image;
            switch (format) {
                case "jpeg":
                    image = Canvas2Image.saveAsJPEG(this.canvas, false, width, height);
                    break;
                case "png":
                    image = Canvas2Image.saveAsPNG(this.canvas, true, width, height);
                    break;
                case "bmp":
                    image = Canvas2Image.saveAsBMP(this.canvas, true, width, height);
                    break;
                default:
                    this.error("Unsupported snapshot format: '" + format
                        + "' - supported types are 'jpeg', 'bmp' and 'png' - defaulting to 'jpeg'");
                    image = Canvas2Image.saveAsJPEG(this.canvas, true, width, height);
            }
            return image.src;
        },

        /**
         Reads colors of pixels from the last rendered frame.

         <p>Call this method like this:</p>

         ````JavaScript

         // Ignore transparent pixels (default is false)
         var opaqueOnly = true;

         var colors = new Float32Array(8);

         myCanvas.readPixels([ 100, 22, 12, 33 ], colors, 2, opaqueOnly);
         ````

         Then the r,g,b components of the colors will be set to the colors at those pixels.

         @param {Float32Array} pixels
         @param {Float32Array} colors
         @param {Number} size
         @param {Boolean} opaqueOnly
         */
        readPixels: function (pixels, colors, size, opaqueOnly) {
            return this.scene._renderer.readPixels(pixels, colors, size, opaqueOnly);
        },

        _props: {

            /**
             A background color for the canvas. This is overridden by {{#crossLink "Canvas/backgroundImage:property"}}{{/crossLink}}.

             You can set this to a new color at any time.

             @property backgroundColor
             @type Float32Array
             @default null
             */
            backgroundColor: {

                set: function (value) {

                    if (!value) {

                        this._backgroundColor = null;

                    } else {

                        (this._backgroundColor = this._backgroundColor || new xeogl.math.vec4()).set(value || [0, 0, 0, 1]);

                        if (!this._backgroundImageSrc) {
                            var rgb = "rgb(" + Math.round(this._backgroundColor[0] * 255) + ", " + Math.round(this._backgroundColor[1] * 255) + "," + Math.round(this._backgroundColor[2] * 255) + ")";
                            this._backgroundElement.style.background = rgb;
                        }
                    }
                },

                get: function () {
                    return this._backgroundColor;
                }
            },

            /**
             URL of a background image for the canvas. This is overrided by {{#crossLink "Canvas/backgroundColor/property"}}{{/crossLink}}.

             You can set this to a new file path at any time.

             @property backgroundImage
             @type String
             */
            backgroundImage: {

                set: function (value) {

                    if (!value) {
                        return;
                    }

                    if (!xeogl._isString(value)) {
                        this.error("Value for 'backgroundImage' should be a string");
                        return;
                    }

                    if (value === this._backgroundImageSrc) { // Already loaded this image
                        return;
                    }

                    this._backgroundElement.style.backgroundImage = "url('" + value + "')";
                    this._backgroundImageSrc = value;

                    if (!this._backgroundImageSrc) {
                        var rgb = "rgb(" + Math.round(this._backgroundColor[0] * 255) + ", " + Math.round(this._backgroundColor[1] * 255) + "," + Math.round(this._backgroundColor[2] * 255) + ")";
                        this._backgroundElement.style.background = rgb;
                    }
                },

                get: function () {
                    return this._backgroundImageSrc;
                }
            },

            /**
             The busy {{#crossLink "Spinner"}}{{/crossLink}} for this Canvas.

             @property spinner
             @type Spinner
             @final
             */
            spinner: {

                get: function () {
                    return this._spinner;
                }
            }
        },

        _destroy: function () {
            this.scene.off(this._tick);
        }
    });

})();
;/**
 A Progress displays a progress animation at the center of its {{#crossLink "Canvas"}}{{/crossLink}} while things are loading or otherwise busy.

 ## Overview

 * Spinners are normally shown by {{#crossLink "Model"}}Models{{/crossLink}} while they are loading, however they may also
 be shown by any application code that wants to indicate busyness.
 * By default, they are also shown by components that load assets, such as {{#crossLink "Texture"}}{{/crossLink}}. You
 can disable that by flipping the Spinner's {{#crossLink "Spinner/textures:property"}}{{/crossLink}} property.
 * A Spinner component has a {{#crossLink "Spinner/processes:property"}}{{/crossLink}} count that indicates how many
 active processes it currently represents. As a process starts, a process would increment {{#crossLink "Spinner/processes:property"}}{{/crossLink}}, then as it
 completes (or fails), would decrement it again.
 * A Spinner is only visible while {{#crossLink "Spinner/processes:property"}}{{/crossLink}} is greater than zero.

 ## Examples

 * [Loading glTF model with spinner](../../examples/#importing_gltf_GearboxAssy)

 ## Usage

 ````javascript
 var spinner = myScene.canvas.spinner;

 // Increment count of busy processes represented by the spinner;
 // assuming the count was zero, this now shows the spinner
 spinner.processes++;

 // Increment the count again, by some other process;
 // spinner already visible, now requires two decrements
 // before it becomes invisible again
 spinner.processes++;

 // Decrement the count; count still greater
 // than zero, so spinner remains visible
 spinner.process--;

 // Decrement the count; count now zero,
 // so spinner becomes invisible
 spinner.process--;
````

 By default, a Spinner shows while resources are loading for components like
 {{#crossLink "Texture"}}{{/crossLink}}. We can disable that like this:

 ````javascript
 // Don't show while resources are loading for Textures etc.
 spinner.textures = false;
 ````

 @class Spinner
 @module xeogl
 @submodule canvas
 @extends Component
 */
(function () {

    "use strict";

    // Ensures lazy-injected CSS only injected once  
    var spinnerCSSInjected = false;

    xeogl.Spinner = xeogl.Component.extend({

        type: "xeogl.Spinner",

        serializable: false,

        _init: function (cfg) {

            this._canvas = cfg.canvas;

            this._injectSpinnerCSS();

            // Create spinner elements

            var div = document.createElement('div');
            var style = div.style;

            style["z-index"] = "9000";
            style.position = "absolute";

            div.innerHTML = '<div class="sk-fading-circle">\
                <div class="sk-circle1 sk-circle"></div>\
                <div class="sk-circle2 sk-circle"></div>\
                <div class="sk-circle3 sk-circle"></div>\
                <div class="sk-circle4 sk-circle"></div>\
                <div class="sk-circle5 sk-circle"></div>\
                <div class="sk-circle6 sk-circle"></div>\
                <div class="sk-circle7 sk-circle"></div>\
                <div class="sk-circle8 sk-circle"></div>\
                <div class="sk-circle9 sk-circle"></div>\
                <div class="sk-circle10 sk-circle"></div>\
                <div class="sk-circle11 sk-circle"></div>\
                <div class="sk-circle12 sk-circle"></div>\
                </div>';

            this._canvas.parentElement.appendChild(div);
            this._element = div;

            this._adjustPosition();

            this.processes = 0;

            this.textures = cfg.textures;
        },

        _props: {

            /**
             * Whether Spinner shows while images are loading for components like {{#crossLink "Texture"}}{{/crossLink}}.
             *
             * @property textures
             * @default true
             * @type Boolean
             */
            textures: {

                set: function (value) {

                    value = value !== false;

                    this._textures = value;
                },

                get: function () {
                    return this._textures;
                }
            },

            /**
             The number of processes this Spinner represents.

             The Spinner is visible while this property is greater than zero.

             Increment this property whenever you commence some process during which you want
             the Spinner to be visible, then decrement it again when the process is complete.

             Clamps to zero if you attempt to set to to a negative value.

             Fires a {{#crossLink "Spinner/processes:event"}}{{/crossLink}} event on change.

             @property processes
             @default 0
             @type Number
             */
            processes: {

                set: function (value) {

                    value = value || 0;

                    if (this._processes === value) {
                        return;
                    }

                    if (value < 0) {
                        return;
                    }

                    this._processes = value;

                    this._element.style["visibility"] = (this._processes > 0) ? "visible" : "hidden";

                    /**
                     Fired whenever this Spinner's {{#crossLink "Spinner/visible:property"}}{{/crossLink}} property changes.

                     @event processes
                     @param value The property's new value
                     */
                    this.fire("processes", this._processes);
                },

                get: function () {
                    return this._processes;
                }
            }
        },

        // (Re)positions spinner DIV over the center of the canvas
        _adjustPosition: function () {

            if (!this._canvas || !this._element) {
                return;
            }

            var canvas = this._canvas;
            var spinner = this._element;
            var spinnerStyle = spinner.style;

            spinnerStyle["left"] = (canvas.offsetLeft + (canvas.clientWidth * 0.5) - (spinner.clientWidth * 0.5)) + "px";
            spinnerStyle["top"] = (canvas.offsetTop + (canvas.clientHeight * 0.5) - (spinner.clientHeight * 0.5)) + "px";
        },

        _injectSpinnerCSS: function () {
            if (spinnerCSSInjected) {
                return;
            }
            var node = document.createElement('style');
            node.innerHTML = this._spinnerCSS;
            document.body.appendChild(node);
            spinnerCSSInjected = true;
        },

        _spinnerCSS: ".sk-fading-circle {\
        margin: 100px auto;\
        width: 100px;\
        height:100px;\
        position: relative;\
        }\
        .sk-fading-circle .sk-circle {\
        width: 120%;\
        height: 120%;\
        position: absolute;\
        left: 0;\
        top: 0;\
        }\
        .sk-fading-circle .sk-circle:before {\
        content: '';\
        display: block;\
        margin: 0 auto;\
        width: 15%;\
        height: 15%;\
        background-color: #ff8800;\
        border-radius: 100%;\
        -webkit-animation: sk-circleFadeDelay 1.2s infinite ease-in-out both;\
        animation: sk-circleFadeDelay 1.2s infinite ease-in-out both;\
        }\
        .sk-fading-circle .sk-circle2 {\
        -webkit-transform: rotate(30deg);\
        -ms-transform: rotate(30deg);\
        transform: rotate(30deg);\
    }\
    .sk-fading-circle .sk-circle3 {\
        -webkit-transform: rotate(60deg);\
        -ms-transform: rotate(60deg);\
        transform: rotate(60deg);\
    }\
    .sk-fading-circle .sk-circle4 {\
        -webkit-transform: rotate(90deg);\
        -ms-transform: rotate(90deg);\
        transform: rotate(90deg);\
    }\
    .sk-fading-circle .sk-circle5 {\
        -webkit-transform: rotate(120deg);\
        -ms-transform: rotate(120deg);\
        transform: rotate(120deg);\
    }\
    .sk-fading-circle .sk-circle6 {\
        -webkit-transform: rotate(150deg);\
        -ms-transform: rotate(150deg);\
        transform: rotate(150deg);\
    }\
    .sk-fading-circle .sk-circle7 {\
        -webkit-transform: rotate(180deg);\
        -ms-transform: rotate(180deg);\
        transform: rotate(180deg);\
    }\
    .sk-fading-circle .sk-circle8 {\
        -webkit-transform: rotate(210deg);\
        -ms-transform: rotate(210deg);\
        transform: rotate(210deg);\
    }\
    .sk-fading-circle .sk-circle9 {\
        -webkit-transform: rotate(240deg);\
        -ms-transform: rotate(240deg);\
        transform: rotate(240deg);\
    }\
    .sk-fading-circle .sk-circle10 {\
        -webkit-transform: rotate(270deg);\
        -ms-transform: rotate(270deg);\
        transform: rotate(270deg);\
    }\
    .sk-fading-circle .sk-circle11 {\
        -webkit-transform: rotate(300deg);\
        -ms-transform: rotate(300deg);\
        transform: rotate(300deg);\
    }\
    .sk-fading-circle .sk-circle12 {\
        -webkit-transform: rotate(330deg);\
        -ms-transform: rotate(330deg);\
        transform: rotate(330deg);\
    }\
    .sk-fading-circle .sk-circle2:before {\
        -webkit-animation-delay: -1.1s;\
        animation-delay: -1.1s;\
    }\
    .sk-fading-circle .sk-circle3:before {\
        -webkit-animation-delay: -1s;\
        animation-delay: -1s;\
    }\
    .sk-fading-circle .sk-circle4:before {\
        -webkit-animation-delay: -0.9s;\
        animation-delay: -0.9s;\
    }\
    .sk-fading-circle .sk-circle5:before {\
        -webkit-animation-delay: -0.8s;\
        animation-delay: -0.8s;\
    }\
    .sk-fading-circle .sk-circle6:before {\
        -webkit-animation-delay: -0.7s;\
        animation-delay: -0.7s;\
    }\
    .sk-fading-circle .sk-circle7:before {\
        -webkit-animation-delay: -0.6s;\
        animation-delay: -0.6s;\
    }\
    .sk-fading-circle .sk-circle8:before {\
        -webkit-animation-delay: -0.5s;\
        animation-delay: -0.5s;\
    }\
    .sk-fading-circle .sk-circle9:before {\
        -webkit-animation-delay: -0.4s;\
        animation-delay: -0.4s;\
    }\
    .sk-fading-circle .sk-circle10:before {\
        -webkit-animation-delay: -0.3s;\
        animation-delay: -0.3s;\
    }\
    .sk-fading-circle .sk-circle11:before {\
        -webkit-animation-delay: -0.2s;\
        animation-delay: -0.2s;\
    }\
    .sk-fading-circle .sk-circle12:before {\
        -webkit-animation-delay: -0.1s;\
        animation-delay: -0.1s;\
    }\
    @-webkit-keyframes sk-circleFadeDelay {\
        0%, 39%, 100% { opacity: 0; }\
        40% { opacity: 1; }\
    }\
    @keyframes sk-circleFadeDelay {\
        0%, 39%, 100% { opacity: 0; }\
        40% { opacity: 1; }\
    }"
    });
})();
;/**
 * Components for cross-section views of Entities.
 *
 * @module xeogl
 * @submodule clipping
 */;/**
 A **Clip** is an arbitrarily-aligned World-space clipping plane.

 <a href="../../examples/#effects_clipping"><img src="../../../assets/images/screenshots/Clips.png"></img></a>

 ## Overview

 * Used to slice portions off objects, to create cross-section views or reveal interiors.
 * Is contained within a {{#crossLink "Clips"}}{{/crossLink}} belonging to its {{#crossLink "Scene"}}{{/crossLink}}.
 * Has a World-space position in {{#crossLink "Clip/pos:property"}}{{/crossLink}} and orientation in {{#crossLink "Clip/dir:property"}}{{/crossLink}}.
 * Discards elements from the half-space in the direction of {{#crossLink "Clip/dir:property"}}{{/crossLink}}.
 * Can be be enabled or disabled via its {{#crossLink "Clip/active:property"}}{{/crossLink}} property.

 ## Usage

 In the example below, we have an {{#crossLink "Entity"}}{{/crossLink}} that's attached by a {{#crossLink "Clips"}}{{/crossLink}}
 that contains two {{#crossLink "Clip"}}{{/crossLink}} components.  The first {{#crossLink "Clip"}}{{/crossLink}} is on the
 positive diagonal, while the second is on the negative diagonal. The {{#crossLink "Entity"}}Entity's{{/crossLink}} {{#crossLink "Geometry"}}{{/crossLink}}
 is a box, which will get two of its corners clipped off.

 ````javascript
 // Create a set of Clip planes in the default Scene
 scene.clips.clips = [

     // Clip plane on negative diagonal
     new xeogl.Clip({
         pos: [1.0, 1.0, 1.0],
         dir: [-1.0, -1.0, -1.0],
         active: true
     }),

     // Clip plane on positive diagonal
     new xeogl.Clip({
         pos: [-1.0, -1.0, -1.0],
         dir: [1.0, 1.0, 1.0],
         active: true
     })
 ];

 // Create an Entity in the default Scene, that will be clipped by our Clip planes
 var entity = new xeogl.Entity({
     geometry: new xeogl.SphereGeometry(),
     clippable: true // Enable clipping (default)
 });
 ````

 ### Switching clipping on and off for an Entity

 An {{#crossLink "Entity"}}{{/crossLink}}'s {{#crossLink "Entity/clippable:property"}}{{/crossLink}} property indicates
 whether or not it is affected by Clip components.

 You can switch it at any time, like this:

 ```` javascript
 // Disable clipping for the Entity
 entity.clippable = false;

 // Enable clipping for the Entity
 entity.clippable = true;
 ````

 @class Clip
 @module xeogl
 @submodule clipping
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Clip in the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Clip configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 You only need to supply an ID if you need to be able to find the Clip by ID within the {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Clip.
 @param [cfg.active=true] {Boolean} Indicates whether or not this Clip is active.
 @param [cfg.pos=[0,0,0]] {Array of Number} World-space position of the clipping plane.
 @param [cfg.dir=[0,0 -1]] {Array of Number} Vector perpendicular to the plane surface, indicating its orientation.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Clip = xeogl.Component.extend({

        type: "xeogl.Clip",

        _init: function (cfg) {

            this._state = {
                active: true,
                pos: new Float32Array(3),
                dir: new Float32Array(3)
            };

            this.active = cfg.active;
            this.pos = cfg.pos;
            this.dir = cfg.dir;
        },

        _props: {

            /**
             Indicates whether this Clip is active or not.

             Fires a {{#crossLink "Clip/active:event"}}{{/crossLink}} event on change.

             @property active
             @default true
             @type Boolean
             */
            active: {

                set: function (value) {

                    this._state.active = value !== false;

                    /**
                     Fired whenever this Clip's {{#crossLink "Clip/active:property"}}{{/crossLink}} property changes.

                     @event active
                     @param value {Boolean} The property's new value
                     */
                    this.fire("active", this._state.active);
                },

                get: function () {
                    return this._state.active;
                }
            },

            /**
             The World-space position of this Clip's plane.

             Fires a {{#crossLink "Clip/pos:event"}}{{/crossLink}} event on change.

             @property pos
             @default [0, 0, 0]
             @type Float32Array
             */
            pos: {

                set: function (value) {

                    this._state.pos.set(value || [0, 0, 0]);

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this Clip's {{#crossLink "Clip/pos:property"}}{{/crossLink}} property changes.

                     @event pos
                     @param value Float32Array The property's new value
                     */
                    this.fire("pos", this._state.pos);
                },

                get: function () {
                    return this._state.pos;
                }
            },

            /**
             Vector indicating the orientation of this Clip plane.

             The vector originates at {{#crossLink "Clip/pos:property"}}{{/crossLink}}. Elements on the
             same side of the vector are clipped.

             Fires a {{#crossLink "Clip/dir:event"}}{{/crossLink}} event on change.

             @property dir
             @default [0, 0, -1]
             @type Float32Array
             */
            dir: {

                set: function (value) {

                    this._state.dir.set(value || [0, 0, -1]);

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this Clip's {{#crossLink "Clip/dir:property"}}{{/crossLink}} property changes.

                     @event dir
                     @param value {Float32Array} The property's new value
                     */
                    this.fire("dir", this._state.dir);
                },

                get: function () {
                    return this._state.dir;
                }
            }
        }
    });
})();
;/**
 A **Clips** applies a set of {{#crossLink "Clip"}}{{/crossLink}} planes to the
 clippable {{#crossLink "Entity"}}Entities{{/crossLink}} within its {{#crossLink "Scene"}}{{/crossLink}}.

 See {{#crossLink "Clip"}}{{/crossLink}} for more info.

 @class Clips
 @module xeogl
 @submodule clipping
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Clips in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Clips.
 @param [cfg.clips] {Array(String)|Array(xeogl.Clip)} Array containing either IDs or instances of
 {{#crossLink "Clip"}}Clip{{/crossLink}} components within the parent {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Clips = xeogl.Component.extend({

        type: "xeogl.Clips",

        _init: function (cfg) {

            this._state = new xeogl.renderer.Clips({
                clips: [],
                hash: ""
            });

            this._dirty = true;
            this._clips = [];
            this._dirtySubs = [];
            this._destroyedSubs = [];

            this.clips = cfg.clips;
        },

        _props: {

            /**
             * The clipping planes contained within this Clips.
             *
             * Fires a {{#crossLink "Clips/clips:event"}}{{/crossLink}} event on change.
             *
             * @property clips
             * @default []
             * @type Array(xeogl.Clip)
             */
            clips: {

                set: function (value) {

                    value = value || [];

                    var clip;
                    var i;
                    var len;
                    var id;

                    // Unsubscribe from events on old clips
                    for (i = 0, len = this._clips.length; i < len; i++) {

                        clip = this._clips[i];

                        clip.off(this._dirtySubs[i]);
                        clip.off(this._destroyedSubs[i]);
                    }

                    this._clips = [];

                    this._dirtySubs = [];
                    this._destroyedSubs = [];

                    var self = this;

                    function clipDirty() {
                        self.fire("dirty", true);
                    }

                    function clipDestroyed() {

                        var id = this.id; // Clip ID

                        for (var i = 0, len = self._clips.length; i < len; i++) {

                            if (self._clips[i].id === id) {

                                self._clips = self._clips.slice(i, i + 1);

                                self._dirtySubs = self._dirtySubs.slice(i, i + 1);
                                self._destroyedSubs = self._destroyedSubs.slice(i, i + 1);

                                self._dirty = true;

                                self.fire("dirty", true);
                                self.fire("clips", self._clips);

                                return;
                            }
                        }
                    }

                    for (i = 0, len = value.length; i < len; i++) {

                        clip = value[i];

                        if (xeogl._isString(clip)) {

                            // ID given for clip - find the clip component

                            id = clip;

                            clip = this.components[id];

                            if (!clip) {
                                this.error("Component not found: " + xeogl._inQuotes(id));
                                continue;
                            }
                        }

                        if (clip.type !== "xeogl.Clip") {
                            this.error("Component " + xeogl._inQuotes(id) + " is not a xeogl.Clip");
                            continue;
                        }

                        this._clips.push(clip);

                        this._dirtySubs.push(clip.on("dirty", clipDirty));

                        this._destroyedSubs.push(clip.on("destroyed", clipDestroyed, clip));
                    }

                    this._dirty = true;

                    /**
                     Fired whenever this Clips' {{#crossLink "Clips/clips:property"}}{{/crossLink}} property changes.
                     @event clips
                     @param value {Array of xeogl.Clip} The property's new value
                     */
                    this.fire("dirty", true);
                    this.fire("clips", this._clips);
                },

                get: function () {
                    return this._clips.slice(0, this._clips.length);
                }
            }
        },

        _getState: function () {
            var state = this._state;
            if (this._dirty) {
                state.clips = [];
                for (var i = 0, len = this._clips.length; i < len; i++) {
                    state.clips.push(this._clips[i]._state);
                }
                this._makeHash();
                this._dirty = false;
            }
            return state;
        },

        _makeHash: function () {
            var clips = this._state.clips;
            if (clips.length === 0) {
                this._state.hash = ";";
                return;
            }
            var clip;
            var hash = [];
            for (var i = 0, len = clips.length; i < len; i++) {
                clip = clips[i];
                hash.push("cp");
            }
            hash.push(";");
            this._state.hash = hash.join("");
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 * Components for controlling things with user input.
 *
 * @module xeogl
 * @submodule controls
 */;/**
 * Rotates, pans and zooms the {{#crossLink "Scene"}}{{/crossLink}}'s {{#crossLink "Camera"}}{{/crossLink}} with keyboard, mouse and touch input.

 CameraControl fires these events:

 * "hover" - Hover enters a new object
 * "hoverSurface" - Hover continues over an object surface - fired continuously as mouse moves over an object
 * "hoverLeave"  - Hover has left the last object we were hovering over
 * "hoverOff" - Hover continues over empty space - fired continuously as mouse moves over nothing
 * "picked" - Clicked or tapped object
 * "pickedSurface" -  Clicked or tapped object, with event containing surface intersection details
 * "doublePicked" - Double-clicked or double-tapped object
 * "doublePickedSurface" - Double-clicked or double-tapped object, with event containing surface intersection details
 * "pickedNothing" - Clicked or tapped, but not on any objects
 * "doublePickedNothing" - Double-clicked or double-tapped, but not on any objects

 CameraControl only fires "hover" events when the mouse is up.

 For efficiency, CameraControl only does surface intersection picking when you subscribe to "doublePicked" and
 "doublePickedSurface" events. Therefore, only subscribe to those when you're OK with the overhead incurred by the
 surface intersection tests.

 ## Panning

 ## Rotating

 ## Zooming

 ## Events

 ## Activating and deactivating

 ## Inertia

 ## First person

 ## Keyboard layout

 # Fly-to


 @class CameraControl
 @module xeogl
 @submodule controls
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}{{/crossLink}}.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CameraControl.
 @param [cfg.firstPerson=false] {Boolean} Whether or not this CameraControl is in "first person" mode.
 @param [cfg.walking=false] {Boolean} Whether or not this CameraControl is in "walking" mode.
 @param [cfg.keyboardLayout="qwerty"] {String} Keyboard layout.
 @param [cfg.doublePickFlyTo=true] {Boolean} Whether to fly the camera to each {{#crossLink "Entity"}}{{/crossLink}} that's double-clicked.
 @param [cfg.active=true] {Boolean} Indicates whether or not this CameraControl is active.
 @param [cfg.inertia=0.5] {Number} A factor in range [0..1] indicating how much the camera keeps moving after you finish panning or rotating it.
 @extends Component
 */
(function () {

    "use strict";


    xeogl.CameraControl = xeogl.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "xeogl.CameraControl",

        _init: function (cfg) {

            this._boundaryHelper = new xeogl.Entity(this, {
                geometry: new xeogl.AABBGeometry(this),
                material: new xeogl.PhongMaterial(this, {
                    diffuse: [0, 0, 0],
                    ambient: [0, 0, 0],
                    specular: [0, 0, 0],
                    emissive: [1.0, 1.0, 0.6],
                    lineWidth: 4
                }),
                visible: false,
                collidable: false
            });

            this._cameraFlight = new xeogl.CameraFlightAnimation(this, {
                duration: 0.5
            });

            this.firstPerson = cfg.firstPerson;
            this.walking = cfg.walking;
            this.keyboardLayout = cfg.keyboardLayout;
            this.doublePickFlyTo = cfg.doublePickFlyTo;
            this.active = cfg.active;
            this.inertia = cfg.inertia;

            this._initEvents(); // Set up all the mouse/touch/kb handlers
        },

        _props: {

            /**
             Indicates whether this CameraControl is active or not.

             Fires a {{#crossLink "CameraControl/active:event"}}{{/crossLink}} event on change.

             @property active
             @default true
             @type Boolean
             */
            active: {

                set: function (value) {

                    this._active = value !== false;

                    /**
                     Fired whenever this CameraControl's {{#crossLink "CameraControl/active:property"}}{{/crossLink}} property changes.

                     @event active
                     @param value {Boolean} The property's new value
                     */
                    this.fire("active", this._active);
                },

                get: function () {
                    return this._active;
                }
            },

            /**
             * Flag which indicates whether this CameraControl is in "first person" mode.
             *
             * In "first person" mode (disabled by default) the look position rotates about the eye position. Otherwise,
             * the eye rotates about the look.
             *
             * Fires a {{#crossLink "KeyboardRotateCamera/firstPerson:event"}}{{/crossLink}} event on change.
             *
             * @property firstPerson
             * @default false
             * @type Boolean
             */
            firstPerson: {

                set: function (value) {

                    value = !!value;

                    this._firstPerson = value;

                    /**
                     * Fired whenever this CameraControl's {{#crossLink "CameraControl/firstPerson:property"}}{{/crossLink}} property changes.
                     * @event firstPerson
                     * @param value The property's new value
                     */
                    this.fire('firstPerson', this._firstPerson);
                },

                get: function () {
                    return this._firstPerson;
                }
            },

            /**
             * Flag which indicates whether this CameraControl is in "walking" mode.
             *
             * When set true, this constrains eye movement to the horizontal X-Z plane. When doing a walkthrough,
             * this is useful to allow us to look upwards or downwards as we move, while keeping us moving in the
             * horizontal plane.
             *
             * This only has an effect when also in "first person" mode.
             *
             * Fires a {{#crossLink "KeyboardRotateCamera/walking:event"}}{{/crossLink}} event on change.
             *
             * @property walking
             * @default false
             * @type Boolean
             */
            walking: {

                set: function (value) {

                    value = !!value;

                    this._walking = value;

                    /**
                     * Fired whenever this CameraControl's {{#crossLink "CameraControl/walking:property"}}{{/crossLink}} property changes.
                     * @event walking
                     * @param value The property's new value
                     */
                    this.fire('walking', this._walking);
                },

                get: function () {
                    return this._walking;
                }
            },

            /**
             * TODO
             * Fires a {{#crossLink "KeyboardRotateCamera/doublePickFlyTo:event"}}{{/crossLink}} event on change.
             *
             * @property doublePickFlyTo
             * @default true
             * @type Boolean
             */
            doublePickFlyTo: {

                set: function (value) {

                    this._doublePickFlyTo = value !== false;

                    // ..

                    /**
                     * Fired whenever this CameraControl's {{#crossLink "CameraControl/doublePickFlyTo:property"}}{{/crossLink}} property changes.
                     * @event doublePickFlyTo
                     * @param value The property's new value
                     */
                    this.fire('doublePickFlyTo', this._doublePickFlyTo);
                },

                get: function () {
                    return this._doublePickFlyTo;
                }
            },


            /**
             * A fact in range [0..1] indicating how much the camera keeps moving after you finish
             * panning or rotating it.
             *
             * A value of 0.0 causes it to immediately stop, 0.5 causes its movement to decay 50% on each tick,
             * while 1.0 causes no decay, allowing it continue moving, by the current rate of pan or rotation.
             *
             * You may choose an inertia of zero when you want be able to precisely position or rotate the camera,
             * without interference from inertia. ero inertia can also mean that less frames are rendered while
             * you are positioning the camera.
             *
             * Fires a {{#crossLink "KeyboardRotateCamera/inertia:event"}}{{/crossLink}} event on change.
             *
             * @property inertia
             * @default 0.5
             * @type Number
             */
            inertia: {

                set: function (value) {

                    this._inertia = value === undefined ? 0.5 : value;

                    /**
                     * Fired whenever this CameraControl's {{#crossLink "CameraControl/inertia:property"}}{{/crossLink}} property changes.
                     * @event inertia
                     * @param value The property's new value
                     */
                    this.fire('inertia', this._inertia);
                },

                get: function () {
                    return this._inertia;
                }
            },

            /**
             * TODO
             * Fires a {{#crossLink "KeyboardRotateCamera/keyboardLayout:event"}}{{/crossLink}} event on change.
             *
             * @property keyboardLayout
             * @default "qwerty"
             * @type String
             */
            keyboardLayout: {

                set: function (value) {

                    this._keyboardLayout = value || "qwerty";

                    // ..

                    /**
                     * Fired whenever this CameraControl's {{#crossLink "CameraControl/keyboardLayout:property"}}{{/crossLink}} property changes.
                     * @event keyboardLayout
                     * @param value The property's new value
                     */
                    this.fire('keyboardLayout', this._keyboardLayout);
                },

                get: function () {
                    return this._keyboardLayout;
                }
            }
        },

        _destroy: function () {
            this.active = false;
        },

        _initEvents: function () {

            var self = this;
            var scene = this.scene;
            var input = scene.input;
            var camera = scene.camera;
            var math = xeogl.math;
            var canvas = this.scene.canvas.canvas;
            var over = false;
            var mouseHoverDelay = 500;
            var mouseOrbitRate = 0.4;
            var mousePanRate = 0.4;
            var mouseZoomRate = 0.8;
            var mouseWheelPanRate = 0.4;
            var keyboardOrbitRate = .02;
            var keyboardPanRate = .02;
            var keyboardZoomRate = .02;
            var touchRotateRate = 0.3;
            var touchPanRate = 0.2;
            var touchZoomRate = 0.05;

            canvas.oncontextmenu = function (e) {
                e.preventDefault();
            };

            var getCanvasPosFromEvent = function (event, canvasPos) {
                if (!event) {
                    event = window.event;
                    canvasPos[0] = event.x;
                    canvasPos[1] = event.y;
                } else {
                    var element = event.target;
                    var totalOffsetLeft = 0;
                    var totalOffsetTop = 0;
                    while (element.offsetParent) {
                        totalOffsetLeft += element.offsetLeft;
                        totalOffsetTop += element.offsetTop;
                        element = element.offsetParent;
                    }
                    canvasPos[0] = event.pageX - totalOffsetLeft;
                    canvasPos[1] = event.pageY - totalOffsetTop;
                }
                return canvasPos;
            };

            //------------------------------------------------------------------------------------
            // Mouse, touch and keyboard camera control
            //------------------------------------------------------------------------------------

            (function () {

                var rotateVx = 0;
                var rotateVy = 0;
                var panVx = 0;
                var panVy = 0;
                var panVz = 0;
                var vZoom = 0;
                var mousePos = math.vec2();
                var panToMouse = false;

                var ctrlDown = false;
                var altDown = false;
                var shiftDown = false;
                var keyDown = {};

                var EPSILON = 0.001;

                var getEyeLookDist = (function () {
                    var vec = new Float32Array(3);
                    return function () {
                        return math.lenVec3(math.subVec3(camera.look, camera.eye, vec));
                    };
                })();

                var getInverseProjectMat = (function () {
                    var projMatDirty = true;
                    camera.on("projMatrix", function () {
                        projMatDirty = true;
                    });
                    var inverseProjectMat = math.mat4();
                    return function () {
                        if (projMatDirty) {
                            math.inverseMat4(camera.projMatrix, inverseProjectMat);
                        }
                        return inverseProjectMat;
                    }
                })();

                var getTransposedProjectMat = (function () {
                    var projMatDirty = true;
                    camera.on("projMatrix", function () {
                        projMatDirty = true;
                    });
                    var transposedProjectMat = math.mat4();
                    return function () {
                        if (projMatDirty) {
                            math.transposeMat4(camera.projMatrix, transposedProjectMat);
                        }
                        return transposedProjectMat;
                    }
                })();

                var getInverseViewMat = (function () {
                    var viewMatDirty = true;
                    camera.on("viewMatrix", function () {
                        viewMatDirty = true;
                    });
                    var inverseViewMat = math.mat4();
                    return function () {
                        if (viewMatDirty) {
                            math.inverseMat4(camera.viewMatrix, inverseViewMat);
                        }
                        return inverseViewMat;
                    }
                })();

                var getSceneDiagSize = (function () {
                    var sceneSizeDirty = true;
                    var diag = 1; // Just in case
                    scene.on("boundary", function () {
                        sceneSizeDirty = true;
                    });
                    return function () {
                        if (sceneSizeDirty) {
                            diag = math.getAABB3Diag(scene.aabb);
                        }
                        return diag;
                    };
                })();

                var panToMousePos = (function () {

                    var cp = math.vec4();
                    var viewPos = math.vec4();
                    var worldPos = math.vec4();
                    var eyeCursorVec = math.vec3();

                    var unproject = function (inverseProjMat, inverseViewMat, mousePos, z,  viewPos, worldPos) {
                        var canvas = scene.canvas.canvas;
                        var halfCanvasWidth = canvas.offsetWidth / 2.0;
                        var halfCanvasHeight = canvas.offsetHeight / 2.0;
                        cp[0] = (mousePos[0] - halfCanvasWidth) / halfCanvasWidth;
                        cp[1] = (mousePos[1] - halfCanvasHeight) / halfCanvasHeight;
                        cp[2] = z;
                        cp[3] = 1.0;
                        math.mulMat4v4(inverseProjMat, cp, viewPos);
                        math.mulVec3Scalar(viewPos, 1.0 / viewPos[3]); // Normalize homogeneous coord
                        viewPos[3] = 1.0;
                        viewPos[1] *= -1; // TODO: Why is this reversed?
                        math.mulMat4v4(inverseViewMat, viewPos, worldPos);
                    };

                    return function (mousePos, factor) {

                        console.log(mousePos);

                        var lastHoverDistance = 0;
                        var inverseProjMat = getInverseProjectMat();
                        var inverseViewMat = getInverseViewMat();

                        // Get last two columns of projection matrix
                        var transposedProjectMat = getTransposedProjectMat();
                        var Pt3 = transposedProjectMat.subarray(8, 12);
                        var Pt4 = transposedProjectMat.subarray(12);
                        var D = [0, 0, -(lastHoverDistance || getSceneDiagSize()), 1];
                        var Z = math.dotVec4(D, Pt3) / math.dotVec4(D, Pt4);

                        unproject(inverseProjMat, inverseViewMat, mousePos, Z, viewPos, worldPos);

                        math.subVec3(worldPos, camera.eye, eyeCursorVec);
                        math.normalizeVec3(eyeCursorVec);

                        var px = eyeCursorVec[0] * factor;
                        var py = eyeCursorVec[1] * factor;
                        var pz = eyeCursorVec[2] * factor;

                        var eye = camera.eye;
                        var look = camera.look;

                        camera.eye = [eye[0] + px, eye[1] + py, eye[2] + pz];
                        camera.look = [look[0] + px, look[1] + py, look[2] + pz];
                    };
                })();

                scene.on("tick", function () {

                    var cameraInertia = self._inertia;

                    if (Math.abs(rotateVx) < EPSILON) {
                        rotateVx = 0;
                    }

                    if (Math.abs(rotateVy) < EPSILON) {
                        rotateVy = 0;
                    }

                    if (rotateVx !== 0) {
                        if (self._firstPerson) {
                            camera.pitch(-rotateVx);
                        } else {
                            camera.orbitPitch(rotateVx);
                        }
                    }

                    if (rotateVy !== 0) {
                        if (self._firstPerson) {
                            camera.yaw(rotateVy);
                        } else {
                            camera.orbitYaw(rotateVy);
                        }
                    }

                    rotateVx *= cameraInertia;
                    rotateVy *= cameraInertia;

                    if (Math.abs(panVx) < EPSILON) {
                        panVx = 0;
                    }

                    if (Math.abs(panVy) < EPSILON) {
                        panVy = 0;
                    }

                    if (Math.abs(panVz) < EPSILON) {
                        panVz = 0;
                    }

                    if (panVx !== 0 || panVy !== 0 || panVz !== 0) {
                        var f = getEyeLookDist() / 80;
                        if (self._walking) {
                            var y = camera.eye[1];
                            camera.pan([panVx * f, panVy * f, panVz * f]);
                            var eye = camera.eye;
                            eye[1] = y;
                            camera.eye = eye;
                        } else {
                            camera.pan([panVx * f, panVy * f, panVz * f]);
                        }
                    }

                    panVx *= cameraInertia;
                    panVy *= cameraInertia;
                    panVz *= cameraInertia;

                    if (Math.abs(vZoom) < EPSILON) {
                        vZoom = 0;
                    }

                    if (vZoom !== 0) {
                        if (self._firstPerson) {
                            var y;
                            if (self._walking) {
                                y = camera.eye[1];
                            }
                            if (panToMouse) { // Using mouse input
                                panToMousePos(mousePos, -vZoom * 2);
                            } else {
                                camera.pan([0, 0, vZoom]); // Touchscreen input with no cursor
                            }
                            if (self._walking) {
                                var eye = camera.eye;
                                eye[1] = y;
                                camera.eye = eye;
                            }
                        } else {
                            // Do both zoom and ortho scale so that we can switch projections without weird scale jumps
                            camera.zoom(vZoom);
                            camera.ortho.scale = camera.ortho.scale + vZoom;
                        }
                        vZoom *= cameraInertia;
                    }
                });

                function getZoomRate() {
                    var aabb = scene.aabb;
                    var xsize = aabb[3] - aabb[0];
                    var ysize = aabb[4] - aabb[1];
                    var zsize = aabb[5] - aabb[2];
                    var max = (xsize > ysize ? xsize : ysize);
                    max = (zsize > max ? zsize : max);
                    return max / 30;
                }

                document.addEventListener("keyDown", function (e) {
                    if (!self._active) {
                        return;
                    }
                    if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {
                        ctrlDown = e.ctrlKey || e.keyCode === 17 || e.metaKey; // !important, treat Windows or Mac Command Key as ctrl
                        altDown = e.altKey || e.keyCode === 18;
                        shiftDown = e.keyCode === 16;
                        keyDown[e.keyCode] = true;
                    }
                }, true);

                document.addEventListener("keyup", function (e) {
                    if (!self._active) {
                        return;
                    }
                    if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {
                        if (e.ctrlKey || e.keyCode === 17) {
                            ctrlDown = false;
                        }
                        if (e.altKey || e.keyCode === 18) {
                            altDown = false;
                        }
                        if (e.keyCode === 16) {
                            shiftDown = false;
                        }
                        keyDown[e.keyCode] = false;
                    }
                });

                // Mouse camera rotate, pan and zoom

                (function () {

                    var lastX;
                    var lastY;
                    var xDelta = 0;
                    var yDelta = 0;
                    var down = false;

                    var mouseDownLeft;
                    var mouseDownMiddle;
                    var mouseDownRight;

                    canvas.addEventListener("mousedown", function (e) {
                        if (!self._active) {
                            return;
                        }
                        if (!over) {
                            return;
                        }
                        switch (e.which) {
                            case 1: // Left button
                                mouseDownLeft = true;
                                down = true;
                                xDelta = 0;
                                yDelta = 0;
                                getCanvasPosFromEvent(e, mousePos);
                                lastX = mousePos[0];
                                lastY = mousePos[1];
                                break;
                            case 2: // Middle/both buttons
                                mouseDownMiddle = true;
                                break;
                            case 3: // Right button
                                mouseDownRight = true;
                                down = true;
                                xDelta = 0;
                                yDelta = 0;
                                getCanvasPosFromEvent(e, mousePos);
                                lastX = mousePos[0];
                                lastY = mousePos[1];
                                break;
                                break;
                            default:
                                break;
                        }
                    });

                    canvas.addEventListener("mouseup", function (e) {
                        if (!self._active) {
                            return;
                        }
                        switch (e.which) {
                            case 1: // Left button
                                mouseDownLeft = false;
                                break;
                            case 2: // Middle/both buttons
                                mouseDownMiddle = false;
                                break;
                            case 3: // Right button
                                mouseDownRight = false;
                                break;
                            default:
                                break;
                        }
                        down = false;
                        xDelta = 0;
                        yDelta = 0;
                    });

                    canvas.addEventListener("mouseenter", function () {
                        if (!self._active) {
                            return;
                        }
                        over = true;
                        xDelta = 0;
                        yDelta = 0;
                    });

                    canvas.addEventListener("mouseleave", function () {
                        if (!self._active) {
                            return;
                        }
                        over = false;
                        xDelta = 0;
                        yDelta = 0;
                    });

                    canvas.addEventListener("mousemove", function (e) {
                        if (!self._active) {
                            return;
                        }
                        if (!over) {
                            return;
                        }
                        getCanvasPosFromEvent(e, mousePos);
                        panToMouse = true;
                        if (!down) {
                            return;
                        }
                        var x = mousePos[0];
                        var y = mousePos[1];
                        xDelta += (x - lastX) * mouseOrbitRate;
                        yDelta += (y - lastY) * mouseOrbitRate;
                        lastX = x;
                        lastY = y;
                    });

                    scene.on("tick", function () {
                        if (!self._active) {
                            return;
                        }
                        if (Math.abs(xDelta) === 0 && Math.abs(yDelta) === 0) {
                            return;
                        }

                        var panning = shiftDown || mouseDownRight;

                        if (panning) {

                            // Panning

                            panVx = xDelta * mousePanRate;
                            panVy = yDelta * mousePanRate;

                        } else {

                            // Orbiting

                            rotateVy = -xDelta * mouseOrbitRate;
                            rotateVx = yDelta * mouseOrbitRate;
                        }

                        xDelta = 0;
                        yDelta = 0;
                    });

                    // Mouse wheel zoom

                    canvas.addEventListener("wheel", function (e) {
                        if (!self._active) {
                            return;
                        }
                        var delta = Math.max(-1, Math.min(1, -e.deltaY * 40));
                        if (delta === 0) {
                            return;
                        }
                        var d = delta / Math.abs(delta);
                        vZoom = -d * getZoomRate() * mouseZoomRate;
                        e.preventDefault();
                    });

                    // Keyboard zoom

                    scene.on("tick", function (e) {
                        if (!self._active) {
                            return;
                        }
                        if (!over) {
                            return;
                        }
                        var elapsed = e.deltaTime;
                        if (!self.ctrlDown && !self.altDown) {
                            var wkey = input.keyDown[input.KEY_ADD];
                            var skey = input.keyDown[input.KEY_SUBTRACT];
                            if (wkey || skey) {
                                if (skey) {
                                    vZoom = elapsed * getZoomRate() * keyboardZoomRate;
                                } else if (wkey) {
                                    vZoom = -elapsed * getZoomRate() * keyboardZoomRate;
                                }
                            }
                        }
                    });

                    // Keyboard panning

                    (function () {

                        scene.on("tick", function (e) {
                            if (!self._active) {
                                return;
                            }
                            if (!over) {
                                return;
                            }

                            var elapsed = e.deltaTime;

                            // if (!self.ctrlDown && !self.altDown) {
                            var front, back, left, right, up, down;
                            if (self._keyboardLayout == 'azerty') {
                                front = input.keyDown[input.KEY_Z];
                                back = input.keyDown[input.KEY_S];
                                left = input.keyDown[input.KEY_Q];
                                right = input.keyDown[input.KEY_D];
                                up = input.keyDown[input.KEY_W];
                                down = input.keyDown[input.KEY_X];
                            } else {
                                front = input.keyDown[input.KEY_W];
                                back = input.keyDown[input.KEY_S];
                                left = input.keyDown[input.KEY_A];
                                right = input.keyDown[input.KEY_D];
                                up = input.keyDown[input.KEY_Z];
                                down = input.keyDown[input.KEY_X];
                            }
                            if (front || back || left || right || up || down) {
                                if (down) {
                                    panVy += elapsed * keyboardPanRate;
                                } else if (up) {
                                    panVy -= -elapsed * keyboardPanRate;
                                }
                                if (right) {
                                    panVx += -elapsed * keyboardPanRate;
                                } else if (left) {
                                    panVx = elapsed * keyboardPanRate;
                                }
                                if (back) {
                                    panVz = elapsed * keyboardPanRate;
                                } else if (front) {
                                    panVz = -elapsed * keyboardPanRate;
                                }
                            }
                            //          }
                        });
                    })();
                })();

                // Touch camera rotate, pan and zoom

                (function () {

                    var touchStartTime;
                    var tapStartPos = new Float32Array(2);
                    var tapStartTime = -1;

                    var lastTouches = [];
                    var numTouches = 0;

                    var touch0Vec = new Float32Array(2);
                    var touch1Vec = new Float32Array(2);

                    var MODE_CHANGE_TIMEOUT = 50;
                    var MODE_NONE = 0;
                    var MODE_ROTATE = 1;
                    var MODE_PAN = 1 << 1;
                    var MODE_ZOOM = 1 << 2;
                    var currentMode = MODE_NONE;
                    var transitionTime = Date.now();

                    function checkMode(mode) {
                        var currentTime = Date.now();
                        if (currentMode === MODE_NONE) {
                            currentMode = mode;
                            return true;
                        }
                        if (currentMode === mode) {
                            return currentTime - transitionTime > MODE_CHANGE_TIMEOUT;
                        }
                        currentMode = mode;
                        transitionTime = currentTime;
                        return false;
                    }

                    canvas.addEventListener("touchstart", function (event) {
                        if (!self._active) {
                            return;
                        }
                        var touches = event.touches;
                        var changedTouches = event.changedTouches;

                        touchStartTime = Date.now();

                        if (touches.length === 1 && changedTouches.length === 1) {
                            tapStartTime = touchStartTime;
                            tapStartPos[0] = touches[0].pageX;
                            tapStartPos[1] = touches[0].pageY;
                        } else {
                            tapStartTime = -1;
                        }

                        while (lastTouches.length < touches.length) {
                            lastTouches.push(new Float32Array(2));
                        }

                        for (var i = 0, len = touches.length; i < len; ++i) {
                            lastTouches[i][0] = touches[i].pageX;
                            lastTouches[i][1] = touches[i].pageY;
                        }

                        currentMode = MODE_NONE;
                        numTouches = touches.length;

                        event.stopPropagation();
                    }, {passive: true});

                    canvas.addEventListener("touchmove", function (event) {
                        if (!self._active) {
                            return;
                        }
                        var touches = event.touches;

                        if (numTouches === 1) {

                            var touch0 = touches[0];

                            if (checkMode(MODE_ROTATE)) {
                                var deltaX = touch0.pageX - lastTouches[0][0];
                                var deltaY = touch0.pageY - lastTouches[0][1];
                                var rotateX = deltaX * touchRotateRate;
                                var rotateY = deltaY * touchRotateRate;
                                rotateVx = rotateY;
                                rotateVy = -rotateX;
                            }

                        } else if (numTouches === 2) {

                            var touch0 = touches[0];
                            var touch1 = touches[1];

                            math.subVec2([touch0.pageX, touch0.pageY], lastTouches[0], touch0Vec);
                            math.subVec2([touch1.pageX, touch1.pageY], lastTouches[1], touch1Vec);

                            var panning = math.dotVec2(touch0Vec, touch1Vec) > 0;

                            if (panning && checkMode(MODE_PAN)) {
                                math.subVec2([touch0.pageX, touch0.pageY], lastTouches[0], touch0Vec);
                                panVx = touch0Vec[0] * touchPanRate;
                                panVy = touch0Vec[1] * touchPanRate;
                            }

                            if (!panning && checkMode(MODE_ZOOM)) {
                                var d1 = math.distVec2([touch0.pageX, touch0.pageY], [touch1.pageX, touch1.pageY]);
                                var d2 = math.distVec2(lastTouches[0], lastTouches[1]);
                                vZoom = (d2 - d1) * getZoomRate() * touchZoomRate;
                            }
                        }

                        for (var i = 0; i < numTouches; ++i) {
                            lastTouches[i][0] = touches[i].pageX;
                            lastTouches[i][1] = touches[i].pageY;
                        }

                        event.stopPropagation();
                    }, {passive: true});

                })();

                // Keyboard rotation

                (function () {

                    scene.on("tick", function (e) {
                        if (!self._active) {
                            return;
                        }
                        if (!over) {
                            return;
                        }
                        var elapsed = e.deltaTime;
                        var left = input.keyDown[input.KEY_LEFT_ARROW];
                        var right = input.keyDown[input.KEY_RIGHT_ARROW];
                        var up = input.keyDown[input.KEY_UP_ARROW];
                        var down = input.keyDown[input.KEY_DOWN_ARROW];
                        if (left || right || up || down) {
                            if (right) {
                                rotateVy += -elapsed * keyboardOrbitRate;

                            } else if (left) {
                                rotateVy += elapsed * keyboardOrbitRate;
                            }
                            if (down) {
                                rotateVx += elapsed * keyboardOrbitRate;

                            } else if (up) {
                                rotateVx += -elapsed * keyboardOrbitRate;
                            }
                        }
                    });
                })();

                // First-person rotation about vertical axis with A and E keys for AZERTY layout

                (function () {

                    scene.on("tick", function (e) {
                        if (!self._active) {
                            return;
                        }
                        if (!over) {
                            return;
                        }
                        var elapsed = e.deltaTime;
                        var rotateLeft;
                        var rotateRight;
                        if (self._keyboardLayout == 'azerty') {
                            rotateLeft = input.keyDown[input.KEY_A];
                            rotateRight = input.keyDown[input.KEY_E];
                        } else {
                            rotateLeft = input.keyDown[input.KEY_Q];
                            rotateRight = input.keyDown[input.KEY_E];
                        }
                        if (rotateRight || rotateLeft) {
                            if (rotateLeft) {
                                rotateVy += elapsed * keyboardOrbitRate;
                            } else if (rotateRight) {
                                rotateVy += -elapsed * keyboardOrbitRate;
                            }
                        }
                    });

                })();
            })();

            //------------------------------------------------------------------------------------
            // Mouse and touch picking
            //------------------------------------------------------------------------------------

            (function () {

                var pickCursorPos = [0, 0];
                var needPickEntity = false;
                var needPickSurface = false;
                var lastPickedEntityId;
                var hit;
                var picked = false;
                var pickedSurface = false;

                function updatePick() {
                    if (!needPickEntity && !needPickSurface) {
                        return;
                    }
                    picked = false;
                    pickedSurface = false;
                    if (needPickSurface || self.hasSubs("hoverSurface")) {
                        hit = scene.pick({
                            pickSurface: true,
                            canvasPos: pickCursorPos
                        });
                    } else { // needPickEntity == true
                        hit = scene.pick({
                            canvasPos: pickCursorPos
                        });
                    }
                    if (hit) {
                        picked = true;
                        var pickedEntityId = hit.entity.id;
                        if (lastPickedEntityId !== pickedEntityId) {
                            if (lastPickedEntityId !== undefined) {

                                /**
                                 * Fired whenever the pointer no longer hovers over an {{#crossLink "Entity"}}{{/crossLink}}.
                                 * @event hoverOut
                                 * @param entity The Entity
                                 */
                                self.fire("hoverOut", {
                                    entity: scene.entities[lastPickedEntityId]
                                });
                            }

                            /**
                             * Fired when the pointer is over a new {{#crossLink "Entity"}}{{/crossLink}}.
                             * @event hoverEnter
                             * @param hit A pick hit result containing the ID of the Entity - see {{#crossLink "Scene/pick:method"}}{{/crossLink}}.
                             */
                            self.fire("hoverEnter", hit);
                            lastPickedEntityId = pickedEntityId;
                        }
                        /**
                         * Fired continuously while the pointer is moving while hovering over an {{#crossLink "Entity"}}{{/crossLink}}.
                         * @event hover
                         * @param hit A pick hit result containing the ID of the Entity - see {{#crossLink "Scene/pick:method"}}{{/crossLink}}.
                         */
                        self.fire("hover", hit);
                        if (hit.worldPos) {
                            pickedSurface = true;

                            /**
                             * Fired while the pointer hovers over the surface of an {{#crossLink "Entity"}}{{/crossLink}}.
                             *
                             * This event provides 3D information about the point on the surface that the pointer is
                             * hovering over.
                             *
                             * @event hoverSurface
                             * @param hit A surface pick hit result, containing the ID of the Entity and 3D info on the
                             * surface possition - see {{#crossLink "Scene/pick:method"}}{{/crossLink}}.
                             */
                            self.fire("hoverSurface", hit);
                        }
                    } else {
                        if (lastPickedEntityId !== undefined) {
                            /**
                             * Fired whenever the pointer no longer hovers over an {{#crossLink "Entity"}}{{/crossLink}}.
                             * @event hoverOut
                             * @param entity The Entity
                             */
                            self.fire("hoverOut", {
                                entity: scene.entities[lastPickedEntityId]
                            });
                            lastPickedEntityId = undefined;
                        }
                        /**
                         * Fired continuously while the pointer is moving but not hovering over anything.
                         *
                         * @event hoverOff
                         */
                        self.fire("hoverOff", {
                            canvasPos: pickCursorPos
                        });
                    }
                    needPickEntity = false;
                    needPickSurface = false;
                }

                scene.on("tick", updatePick);

                // Mouse picking

                (function () {

                    canvas.addEventListener("mousemove", function (e) {

                        if (!self._active) {
                            return;
                        }

                        //if (down) {
                        //    return;
                        //}

                        getCanvasPosFromEvent(e, pickCursorPos);

                        if (self.hasSubs("hover") || self.hasSubs("hoverOut") || self.hasSubs("hoverOff") || self.hasSubs("hoverSurface")) {
                            needPickEntity = true;
                        }
                    });

                    var downX;
                    var downY;
                    var downCursorX;
                    var downCursorY;

                    canvas.addEventListener('mousedown', function (e) {
                        if (!self._active) {
                            return;
                        }
                        downX = e.clientX;
                        downY = e.clientY;
                        downCursorX = pickCursorPos[0];
                        downCursorY = pickCursorPos[1];
                    });

                    canvas.addEventListener('mouseup', (function (e) {
                        var clicks = 0;
                        var timeout;
                        return function (e) {
                            if (!self._active) {
                                return;
                            }
                            if (Math.abs(e.clientX - downX) > 3 || Math.abs(e.clientY - downY) > 3) {
                                return;
                            }

                            if (!self._doublePickFlyTo && !self.hasSubs("doublePicked") && !self.hasSubs("doublePickedSurface") && !self.hasSubs("doublePickedNothing")) {

                                //  Avoid the single/double click differentiation timeout

                                needPickSurface = !!self.hasSubs("pickedSurface");

                                updatePick();

                                if (hit) {

                                    /**
                                     * Fired whenever the pointer has picked (ie. clicked or tapped) an {{#crossLink "Entity"}}{{/crossLink}}.
                                     *
                                     * @event picked
                                     * @param hit A surface pick hit result containing the ID of the Entity - see {{#crossLink "Scene/pick:method"}}{{/crossLink}}.
                                     */
                                    self.fire("picked", hit);
                                    if (pickedSurface) {

                                        /**
                                         * Fired when the pointer has picked (ie. clicked or tapped) the surface of an {{#crossLink "Entity"}}{{/crossLink}}.
                                         *
                                         * This event provides 3D information about the point on the surface that the pointer has picked.
                                         *
                                         * @event pickedSurface
                                         * @param hit A surface pick hit result, containing the ID of the Entity and 3D info on the
                                         * surface possition - see {{#crossLink "Scene/pick:method"}}{{/crossLink}}.
                                         */
                                        self.fire("pickedSurface", hit);
                                    }
                                } else {

                                    /**
                                     * Fired when the pointer attempted a pick (ie. clicked or tapped), but has hit nothing.
                                     *
                                     * @event pickedNothing
                                     */
                                    self.fire("pickedNothing");
                                }

                                return;
                            }

                            clicks++;

                            if (clicks == 1) {
                                timeout = setTimeout(function () {

                                    needPickEntity = self._doublePickFlyTo;
                                    needPickSurface = needPickEntity || !!self.hasSubs("pickedSurface");
                                    pickCursorPos[0] = downCursorX;
                                    pickCursorPos[1] = downCursorY;

                                    updatePick();

                                    if (hit) {
                                        self.fire("picked", hit);
                                        if (pickedSurface) {
                                            self.fire("pickedSurface", hit);
                                        }
                                    } else {
                                        self.fire("pickedNothing");
                                    }

                                    clicks = 0;
                                }, 250);  // FIXME: Too short for track pads

                            } else {

                                clearTimeout(timeout);

                                needPickEntity = self._doublePickFlyTo;
                                needPickSurface = needPickEntity && !!self.hasSubs("doublePickedSurface");

                                updatePick();

                                if (hit) {
                                    /**
                                     * Fired whenever the pointer has double-picked (ie. double-clicked or double-tapped) an {{#crossLink "Entity"}}{{/crossLink}}.
                                     *
                                     * @event picked
                                     * @param hit A surface pick hit result containing the ID of the Entity - see {{#crossLink "Scene/pick:method"}}{{/crossLink}}.
                                     */
                                    self.fire("doublePicked", hit);
                                    if (pickedSurface) {
                                        /**
                                         * Fired when the pointer has double-picked (ie. double-clicked or double-tapped) the surface of an {{#crossLink "Entity"}}{{/crossLink}}.
                                         *
                                         * This event provides 3D information about the point on the surface that the pointer has picked.
                                         *
                                         * @event doublePickedSurface
                                         * @param hit A surface pick hit result, containing the ID of the Entity and 3D info on the
                                         * surface possition - see {{#crossLink "Scene/pick:method"}}{{/crossLink}}.
                                         */
                                        self.fire("doublePickedSurface", hit);
                                    }
                                    if (self._doublePickFlyTo) {
                                        self._flyTo(hit);
                                    }
                                } else {

                                    /**
                                     * Fired when the pointer attempted a double-pick (ie. double-clicked or double-tapped), but has hit nothing.
                                     *
                                     * @event doublePickedNothing
                                     */
                                    self.fire("doublePickedNothing");
                                    if (self._doublePickFlyTo) {
                                        self._flyTo();
                                    }
                                }
                                clicks = 0;
                            }
                        };
                    })(), false);

                })();

                // Touch picking

                (function () {

                    var TAP_INTERVAL = 150;
                    var DBL_TAP_INTERVAL = 325;
                    var TAP_DISTANCE_THRESHOLD = 4;

                    var touchStartTime;
                    var activeTouches = [];
                    var tapStartPos = new Float32Array(2);
                    var tapStartTime = -1;
                    var lastTapTime = -1;

                    canvas.addEventListener("touchstart", function (event) {

                        if (!self._active) {
                            return;
                        }

                        var touches = event.touches;
                        var changedTouches = event.changedTouches;

                        touchStartTime = Date.now();

                        if (touches.length === 1 && changedTouches.length === 1) {
                            tapStartTime = touchStartTime;
                            tapStartPos[0] = touches[0].pageX;
                            tapStartPos[1] = touches[0].pageY;
                        } else {
                            tapStartTime = -1;
                        }

                        while (activeTouches.length < touches.length) {
                            activeTouches.push(new Float32Array(2))
                        }

                        for (var i = 0, len = touches.length; i < len; ++i) {
                            activeTouches[i][0] = touches[i].pageX;
                            activeTouches[i][1] = touches[i].pageY;
                        }

                        activeTouches.length = touches.length;

                        event.stopPropagation();
                    }, {passive: true});

                    //canvas.addEventListener("touchmove", function (event) {
                    //    event.preventDefault();
                    //    event.stopPropagation();
                    //});

                    canvas.addEventListener("touchend", function (event) {

                        if (!self._active) {
                            return;
                        }

                        var currentTime = Date.now();
                        var touches = event.touches;
                        var changedTouches = event.changedTouches;

                        // process tap

                        if (touches.length === 0 && changedTouches.length === 1) {

                            if (tapStartTime > -1 && currentTime - tapStartTime < TAP_INTERVAL) {

                                if (lastTapTime > -1 && tapStartTime - lastTapTime < DBL_TAP_INTERVAL) {

                                    // Double-tap

                                    pickCursorPos[0] = Math.round(changedTouches[0].clientX);
                                    pickCursorPos[1] = Math.round(changedTouches[0].clientY);
                                    needPickEntity = true;
                                    needPickSurface = !!self.hasSubs("pickedSurface");

                                    updatePick();

                                    if (hit) {
                                        self.fire("doublePicked", hit);
                                        if (pickedSurface) {
                                            self.fire("doublePickedSurface", hit);
                                        }
                                        if (self._doublePickFlyTo) {
                                            self._flyTo(hit);
                                        }
                                    } else {
                                        self.fire("doublePickedNothing");
                                        if (self._doublePickFlyTo) {
                                            self._flyTo();
                                        }
                                    }

                                    lastTapTime = -1;

                                } else if (xeogl.math.distVec2(activeTouches[0], tapStartPos) < TAP_DISTANCE_THRESHOLD) {

                                    // Single-tap

                                    pickCursorPos[0] = Math.round(changedTouches[0].clientX);
                                    pickCursorPos[1] = Math.round(changedTouches[0].clientY);
                                    needPickEntity = true;
                                    needPickSurface = !!self.hasSubs("pickedSurface");

                                    updatePick();

                                    if (hit) {
                                        self.fire("picked", hit);
                                        if (pickedSurface) {
                                            self.fire("pickedSurface", hit);
                                        }
                                    } else {
                                        self.fire("pickedNothing");
                                    }

                                    lastTapTime = currentTime;
                                }

                                tapStartTime = -1
                            }
                        }

                        activeTouches.length = touches.length;

                        for (var i = 0, len = touches.length; i < len; ++i) {
                            activeTouches[i][0] = touches[i].pageX;
                            activeTouches[i][1] = touches[i].pageY;
                        }

                        event.stopPropagation();
                    }, {passive: true});
                })();
            })();

            //------------------------------------------------------------------------------------
            // Keyboard camera axis views
            //------------------------------------------------------------------------------------

            (function () {

                var KEY_NUM_1 = 49;
                var KEY_NUM_2 = 50;
                var KEY_NUM_3 = 51;
                var KEY_NUM_4 = 52;
                var KEY_NUM_5 = 53;
                var KEY_NUM_6 = 54;

                var center = new math.vec3();
                var tempVec3a = new math.vec3();
                var tempVec3b = new math.vec3();
                var tempVec3c = new math.vec3();

                var cameraTarget = {
                    eye: new Float32Array(3),
                    look: new Float32Array(3),
                    up: new Float32Array(3)
                };

                document.addEventListener("keydown", function (e) {

                    if (!self._active) {
                        return;
                    }

                    if (!over) {
                        return;
                    }

                    var keyCode = e.keyCode;

                    if (keyCode !== KEY_NUM_1 &&
                        keyCode !== KEY_NUM_2 &&
                        keyCode !== KEY_NUM_3 &&
                        keyCode !== KEY_NUM_4 &&
                        keyCode !== KEY_NUM_5 &&
                        keyCode !== KEY_NUM_6) {
                        return;
                    }

                    var aabb = scene.aabb;
                    var diag = math.getAABB3Diag(aabb);
                    center[0] = aabb[0] + aabb[3] / 2.0;
                    center[1] = aabb[1] + aabb[4] / 2.0;
                    center[2] = aabb[2] + aabb[5] / 2.0;
                    var dist = Math.abs((diag) / Math.tan(self._cameraFlight.fitFOV / 2));

                    switch (keyCode) {

                        case KEY_NUM_1: // Right

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldRight, dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(camera.worldUp);

                            break;

                        case KEY_NUM_2: // Back

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldForward, dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(camera.worldUp);

                            break;

                        case KEY_NUM_3: // Left

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldRight, -dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(camera.worldUp);

                            break;

                        case KEY_NUM_4: // Front

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldForward, -dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(camera.worldUp);

                            break;

                        case KEY_NUM_5: // Top

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldUp, dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(camera.worldForward, 1, tempVec3b), tempVec3c));

                            break;

                        case KEY_NUM_6: // Bottom

                            cameraTarget.eye.set(math.mulVec3Scalar(camera.worldUp, -dist, tempVec3a));
                            cameraTarget.look.set(center);
                            cameraTarget.up.set(math.normalizeVec3(math.mulVec3Scalar(camera.worldForward, -1, tempVec3b)));

                            break;

                        default:
                            return;
                    }

                    if (self._cameraFlight.duration > 0) {
                        self._cameraFlight.flyTo(cameraTarget);
                    } else {
                        self._cameraFlight.jumpTo(cameraTarget);
                    }
                });

            })();
        },

        _flyTo: function (hit) {

            var pos;

            if (hit && hit.worldPos) {
                pos = hit.worldPos
            }

            var aabb = hit ? hit.entity.aabb : this.scene.aabb;

            this._boundaryHelper.geometry.targetAABB = aabb;
            //    this._boundaryHelper.visible = true;

            if (pos) {

                // Fly to look at point, don't change eye->look dist

                var camera = this.scene.camera;
                var diff = xeogl.math.subVec3(camera.eye, camera.look, []);

                this._cameraFlight.flyTo({
                        // look: pos,
                        // eye: xeogl.math.addVec3(pos, diff, []),
                        // up: camera.up,
                        aabb: aabb
                    },
                    this._hideBoundary, this);

                // TODO: Option to back off to fit AABB in view

            } else {

                // Fly to fit target boundary in view

                this._cameraFlight.flyTo({
                        aabb: aabb
                    },
                    this._hideBoundary, this);
            }
        },

        _hideBoundary: function () {
            //    this._boundaryHelper.visible = false;
        }
    });

})();
;/**
 * Components for defining geometry.
 *
 * @module xeogl
 * @submodule geometry
 */;/**
 A **Geometry** defines a mesh for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Usage

 * [Geometry compression](#geometry-compression)
 * [Geometry batching](#geometry-batching)

 ### Geometry compression

 Geometries are automatically quantized to reduce memory and GPU bus usage. Usually, geometry attributes such as positions
 and normals are stored as 32-bit floating-point numbers. Quantization compresses those attributes to 16-bit integers
 represented on a scale between the minimum and maximum values. Decompression is then done on the GPU, via a simple
 matrix multiplication in the vertex shader.

 #### Disabling

 Since each normal vector is oct-encoded into two 8-bit unsigned integers, this can cause them to lose precision, which
 may affect the accuracy of any operations that rely on them being perfectly perpendicular to their surfaces. In such
 cases, you may need to disable compression for your geometries and models:

 ````javascript
 // Disable geometry compression when loading a Model
 var model = new xeogl.GLTFModel({
    src: "models/gltf/modern_office/scene.gltf",
    quantizeGeometry: false // Default is true
});

 // Disable compression when creating a Geometry
 var entity = new xeogl.Entity({
    geometry: new xeogl.TeapotGeometry({
        quantized: false // Default is true
    }),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    })
 });
 ````

 ### Geometry batching

 Geometries are automatically combined into the same vertex buffer objects (VBOs) so that we reduce the number of VBO
 binds done by WebGL on each frame. VBO binds are expensive, so this really makes a difference when we have large numbers
 of Entities that share similar Materials (as is often the case in CAD rendering).

 #### Disabling

 Since combined VBOs need to be rebuilt whenever we destroy a Geometry, we can disable this optimization for individual
 Models and Geometries when we know that we'll be continually creating and destroying them.

 ````javascript
 // Disable VBO combination for a GLTFModel
 var model = new xeogl.GLTFModel({
    src: "models/gltf/modern_office/scene.gltf",
    combinedGeometry: false // Default is true
});

 // Disable VBO combination for an individual Geometry
 var entity = new xeogl.Entity({
    geometry: new xeogl.TeapotGeometry({
        combined: false // Default is true
    }),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    })
 });
 ````

 @class Geometry
 @module xeogl
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Geometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Geometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.
 @param [cfg.positions] {Array of Number} Positions array.
 @param [cfg.normals] {Array of Number} Vertex normal vectors array.
 @param [cfg.uv] {Array of Number} UVs array.
 @param [cfg.colors] {Array of Number} Vertex colors.
 @param [cfg.indices] {Array of Number} Indices array.
 @param [cfg.autoVertexNormals=false] {Boolean} Set true to automatically generate normal vectors from the positions and
 indices, if those are supplied.
 @param [cfg.quantized=true] {Boolean} Stores positions, colors, normals and UVs in quantized and oct-encoded formats
 for reduced memory footprint and GPU bus usage.
 @param [cfg.combined=false] {Boolean} Combines positions, colors, normals and UVs into the same WebGL vertex buffers
 with other Geometries, in order to reduce the number of buffer binds performed per frame.
 @param [cfg.ghostEdgeThreshold=2] {Number} When a {{#crossLink "Entity"}}{{/crossLink}} renders this Geometry as wireframe,
 this indicates the threshold angle (in degrees) between the face normals of adjacent triangles below which the edge is discarded.
 @extends Component
 */
(function () {

    "use strict";

    var memoryStats = xeogl.stats.memory;
    var bigIndicesSupported = xeogl.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"];
    var IndexArrayType = bigIndicesSupported ? Uint32Array : Uint16Array;
    var nullVertexBufs = new xeogl.renderer.VertexBufs({});

    var SceneVertexBufs = function (scene,
                                    hasPositions,
                                    hasNormals,
                                    hasColors,
                                    hasUVs,
                                    quantized) {

        const CHUNK_LEN = bigIndicesSupported ? (Number.MAX_SAFE_INTEGER / 6) : (64000 * 4); // RGBA is largest item

        var gl = scene.canvas.gl;
        var geometries = {};
        var geometryIndicesOffsets = {};
        var newGeometries = [];
        var geometryVertexBufs = {};
        var needRebuild = false;
        var needAppend = false;
        var positions = [];
        var normals = [];
        var colors = [];
        var uv = [];
        var vertexBufs = null;

        scene.canvas.on("webglContextRestored", build);

        this.addGeometry = function (geometry) {
            if (!geometry.positions || !geometry.indices) {
                scene.warn("Ignoring geometry with no positions or indices: " + geometry.id);
                return;
            }
            geometries[geometry.id] = geometry;
            geometryIndicesOffsets[geometry.id] = 0; // Will initialize below
            newGeometries.push(geometry);
            needAppend = true;
        };

        this.getIndicesOffset = function (geometry) {
            if (needRebuild || needAppend) {
                build();
            }
            return geometryIndicesOffsets[geometry.id];
        };

        this.getVertexBufs = function (geometry) {
            if (!geometries[geometry.id]) {
                return nullVertexBufs;
            }
            if (needRebuild || needAppend) {
                build();
            }
            return geometryVertexBufs[geometry.id];
        };

        this.setPositions = function (geometry) {
            var vertexBufs = geometryVertexBufs[geometry.id];
            if (!vertexBufs) {
                return;
            }
            if (!geometry.positions) {
                return;
            }
            var positionsBuf = vertexBufs.positionsBuf;
            if (!positionsBuf) {
                return;
            }
            positionsBuf.setData(geometry.positions, geometryIndicesOffsets[geometry.id] * 3);
        };

        this.setNormals = function (geometry) {
            var vertexBufs = geometryVertexBufs[geometry.id];
            if (!vertexBufs) {
                return;
            }
            if (!geometry.normals) {
                return;
            }
            var normalsBuf = vertexBufs.normalsBuf;
            if (!normalsBuf) {
                return;
            }
            normalsBuf.setData(geometry.normals, geometryIndicesOffsets[geometry.id] * 3);
        };

        this.setUVs = function (geometry) {
            var vertexBufs = geometryVertexBufs[geometry.id];
            if (!vertexBufs) {
                return;
            }
            if (!geometry.uv) {
                return;
            }
            var uvBuf = vertexBufs.uvBuf;
            if (!uvBuf) {
                return;
            }
            uvBuf.setData(geometry.uv, geometryIndicesOffsets[geometry.id] * 2);
        };

        this.setColors = function (geometry) {
            var vertexBufs = geometryVertexBufs[geometry.id];
            if (!vertexBufs) {
                return;
            }
            if (!geometry.color) {
                return;
            }
            var colorsBuf = vertexBufs.colorsBuf;
            if (!colorsBuf) {
                return;
            }
            colorsBuf.setData(geometry.colors, geometryIndicesOffsets[geometry.id] * 4);
        };

        this.removeGeometry = function (geometry) {
            var id = geometry.id;
            if (!geometries[id]) {
                return;
            }
            delete geometries[id];
            delete geometryIndicesOffsets[id];
            needRebuild = true;
        };

        function build() {

            geometryVertexBufs = {};

            var id;
            var geometry;
            var indicesOffset = 0;

            vertexBufs = null;

            for (id in geometries) {
                if (geometries.hasOwnProperty(id)) {

                    geometry = geometries[id];

                    var needNew = (!vertexBufs) || (positions.length + geometry.positions.length > CHUNK_LEN);

                    if (needNew) {
                        if (vertexBufs) {
                            createBufs(vertexBufs);
                        }
                        vertexBufs = new xeogl.renderer.VertexBufs({
                            positionsBuf: null,
                            normalsBuf: null,
                            uvBuf: null,
                            colorsBuf: null,
                            quantized: quantized
                        });
                        indicesOffset = 0;
                    }

                    geometryVertexBufs[id] = vertexBufs;

                    if (hasPositions) {
                        for (var i = 0, len = geometry.positions.length; i < len; i++) {
                            positions.push(geometry.positions[i]);
                        }
                    }

                    if (hasNormals) {
                        for (var i = 0, len = geometry.normals.length; i < len; i++) {
                            normals.push(geometry.normals[i]);
                        }
                    }

                    if (hasColors) {
                        for (var i = 0, len = geometry.colors.length; i < len; i++) {
                            colors.push(geometry.colors[i]);
                        }
                    }

                    if (hasUVs) {
                        for (var i = 0, len = geometry.uv.length; i < len; i++) {
                            uv.push(geometry.uv[i]);
                        }
                    }

                    // Adjust geometry indices

                    geometryIndicesOffsets[id] = indicesOffset;

                    var indices;

                    if (indicesOffset) {
                        indices = new (bigIndicesSupported ? Uint32Array : Uint16Array)(geometry.indices);
                        for (var i = 0, len = indices.length; i < len; i++) {
                            indices[i] += indicesOffset;
                            if (indices[i] > (CHUNK_LEN / 3)) {
                                console.error("out of range: " + indices[i])
                            }
                        }
                    } else {
                        indices = geometry.indices;
                    }

                    // Update indices buffer, lazy-create first if necessary

                    if (!geometry.indicesBufCombined) {
                        geometry.indicesBufCombined = new xeogl.renderer.ArrayBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, indices, indices.length, 1, gl.STATIC_DRAW);
                    } else {
                        geometry.indicesBufCombined.setData(indices);
                    }

                    indicesOffset += geometry.positions.length / 3;
                }
            }

            if (vertexBufs) {
                createBufs(vertexBufs);
            }

            needRebuild = false;
            needAppend = false;
        }

        function createBufs(vertexBufs) {
            var gl = scene.canvas.gl;
            var array;
            if (hasPositions) {
                array = quantized ? new Uint16Array(positions) : new Float32Array(positions);
                vertexBufs.positionsBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, array, array.length, 3, gl.STATIC_DRAW);
                memoryStats.positions += vertexBufs.positionsBuf.numItems;
                positions = [];
            }
            if (hasNormals) {
                array = quantized ? new Int8Array(normals) : new Float32Array(normals);
                vertexBufs.normalsBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, array, array.length, 3, gl.STATIC_DRAW);
                memoryStats.normals += vertexBufs.normalsBuf.numItems;
                normals = [];
            }
            if (hasColors) {
                array = new Float32Array(colors);
                vertexBufs.colorsBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, array, array.length, 4, gl.STATIC_DRAW);
                memoryStats.colors += vertexBufs.colorsBuf.numItems;
                colors = [];
            }
            if (hasUVs) {
                array = quantized ? new Uint16Array(uv) : new Float32Array(uv);
                vertexBufs.uvBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, array, array.length, 2, gl.STATIC_DRAW);
                memoryStats.uvs += vertexBufs.uvBuf.numItems;
                uv = [];
            }
        }
    };

    function getSceneVertexBufs(scene, geometry) {
        var hasPositions = !!geometry.positions;
        var quantized = !!geometry.quantized;
        var hasNormals = !!geometry.normals;
        var hasColors = !!geometry.colors;
        var hasUVs = !!geometry.uv;
        var hash = ([
            hasPositions ? "p" : "",
            quantized ? "c" : "",
            hasNormals ? "n" : "",
            hasColors ? "c" : "",
            hasUVs ? "u" : ""
        ]).join(";");
        if (!scene._sceneVertexBufs) {
            scene._sceneVertexBufs = {};
        }
        var sceneVertexBufs = scene._sceneVertexBufs[hash];
        if (!sceneVertexBufs) {
            sceneVertexBufs = new SceneVertexBufs(
                scene,
                hasPositions,
                hasNormals,
                hasColors,
                hasUVs,
                quantized);
            scene._sceneVertexBufs[hash] = sceneVertexBufs;
        }
        return sceneVertexBufs;
    }

    xeogl.Geometry = xeogl.Component.extend({

        type: "xeogl.Geometry",

        _init: function (cfg) {

            var self = this;

            this._state = new xeogl.renderer.Geometry({

                combined: !!cfg.combined,
                quantized: !!cfg.quantized,
                autoVertexNormals: !!cfg.autoVertexNormals,

                primitive: null, // WebGL enum
                primitiveName: null, // String

                positions: null,    // Uint16Array when quantized == true, else Float32Array
                normals: null,      // Uint8Array when quantized == true, else Float32Array
                colors: null,
                uv: null,           // Uint8Array when quantized == true, else Float32Array
                indices: null,

                positionsDecodeMatrix: null, // Set when quantized == true
                uvDecodeMatrix: null, // Set when quantized == true

                positionsBuf: null,
                normalsBuf: null,
                colorsbuf: null,
                uvBuf: null,
                indicesBuf: null,
                indicesBufCombined: null, // Indices into a shared VertexBufs, set when combined == true

                hash: "",

                getGhostEdgesIndices: function () {
                    if (!self._edgesIndicesBuf) {
                        self._buildGhostEdgesIndices();
                    }
                    return self._edgesIndicesBuf;
                },

                getPickTrianglePositions: function () {
                    if (!self._pickTrianglePositionsBuf) {
                        self._buildPickTriangleVBOs();
                    }
                    return self._pickTrianglePositionsBuf;
                },

                getPickTriangleColors: function () {
                    if (!self._pickTriangleColorsBuf) {
                        self._buildPickTriangleVBOs();
                    }
                    return self._pickTriangleColorsBuf;
                },

                getPickVertexPositions: function () {
                    if (!self._pickVertexPositionsBuf) {
                        self._buildPickTriangleVBOs();
                    }
                    return self._pickVertexPositionsBuf;
                },

                getPickVertexColors: function () {
                    if (!self._pickVertexColorsBuf) {
                        self._buildPickTriangleVBOs();
                    }
                    return self._pickVertexColorsBuf;
                }
            });

            this._ghostEdgeThreshold = cfg.ghostEdgeThreshold || 2.0;

            // Lazy-generated VBOs

            this._edgesIndicesBuf = null;
            this._pickTrianglePositionsBuf = null;
            this._pickTriangleColorsBuf = null;

            // Local-space Boundary3D

            this._localBoundary = null;
            this._boundaryDirty = true;

            this._aabb = null;
            this._aabbDirty = true;

            this._obb = null;
            this._obbDirty = true;

            var state = this._state;
            var gl = this.scene.canvas.gl;

            // Primitive type

            cfg.primitive = cfg.primitive || "triangles";
            switch (cfg.primitive) {
                case "points":
                    state.primitive = gl.POINTS;
                    state.primitiveName = cfg.primitive;
                    break;
                case "lines":
                    state.primitive = gl.LINES;
                    state.primitiveName = cfg.primitive;
                    break;
                case "line-loop":
                    state.primitive = gl.LINE_LOOP;
                    state.primitiveName = cfg.primitive;
                    break;
                case "line-strip":
                    state.primitive = gl.LINE_STRIP;
                    state.primitiveName = cfg.primitive;
                    break;
                case "triangles":
                    state.primitive = gl.TRIANGLES;
                    state.primitiveName = cfg.primitive;
                    break;
                case "triangle-strip":
                    state.primitive = gl.TRIANGLE_STRIP;
                    state.primitiveName = cfg.primitive;
                    break;
                case "triangle-fan":
                    state.primitive = gl.TRIANGLE_FAN;
                    state.primitiveName = cfg.primitive;
                    break;
                default:
                    this.error("Unsupported value for 'primitive': '" + cfg.primitive +
                        "' - supported values are 'points', 'lines', 'line-loop', 'line-strip', 'triangles', " +
                        "'triangle-strip' and 'triangle-fan'. Defaulting to 'triangles'.");
                    state.primitive = gl.TRIANGLES;
                    state.primitiveName = cfg.primitive;
            }

            if (cfg.positions) {
                if (this._state.quantized) {
                    var bounds = getBounds(cfg.positions, 3);
                    var quantized = quantizeVec3(cfg.positions, bounds.min, bounds.max);
                    state.positions = quantized.quantized;
                    state.positionsDecodeMatrix = quantized.decode;
                } else {
                    state.positions = cfg.positions.constructor === Float32Array ? cfg.positions : new Float32Array(cfg.positions);
                }
            }
            if (cfg.colors) {
                state.colors = cfg.colors.constructor === Float32Array ? cfg.colors : new Float32Array(cfg.colors);
            }
            if (cfg.uv) {
                if (this._state.quantized) {
                    var bounds = getBounds(cfg.uv, 2);
                    var quantized = quantizeVec2(cfg.uv, bounds.min, bounds.max);
                    state.uv = quantized.quantized;
                    state.uvDecodeMatrix = quantized.decode;
                } else {
                    state.uv = cfg.uv.constructor === Float32Array ? cfg.uv : new Float32Array(cfg.uv);
                }
            }
            if (cfg.normals) {
                if (this._state.quantized) {
                    state.normals = octEncode(cfg.normals);
                } else {
                    state.normals = cfg.normals.constructor === Float32Array ? cfg.normals : new Float32Array(cfg.normals);
                }
            }
            if (cfg.indices) {
                if (!bigIndicesSupported && cfg.indices.constructor === Uint32Array) {
                    this.error("This WebGL implementation does not support Uint32Array");
                    return;
                }
                state.indices = (cfg.indices.constructor === Uint32Array || cfg.indices.constructor === Uint16Array) ? cfg.indices : new IndexArrayType(cfg.indices);
            }

            if (state.indices) {
                state.indicesBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, state.indices, state.indices.length, 1, gl.STATIC_DRAW);
                memoryStats.indices += state.indicesBuf.numItems;
            }

            this._buildVBOs();

            this._buildHash();

            this._webglContextRestored = this.scene.canvas.on("webglContextRestored", this._buildVBOs, this);

            memoryStats.meshes++;

            if (this._state.combined) {
                this._sceneVertexBufs = getSceneVertexBufs(this.scene, this._state);
                this._sceneVertexBufs.addGeometry(this._state);
            }

            self.fire("created", this.created = true);
        },

        _buildVBOs: function () {
            var state = this._state;
            var gl = this.scene.canvas.gl;
            if (state.indices) {
                state.indicesBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, state.indices, state.indices.length, 1, gl.STATIC_DRAW);
                memoryStats.indices += state.indicesBuf.numItems;
            }
            if (state.combined) {
                if (state.indices) {
                    // indicesBufCombined is created when VertexBufs are built for this Geometry
                }
            } else {
                if (state.positions) {
                    state.positionsBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, state.positions, state.positions.length, 3, gl.STATIC_DRAW);
                    memoryStats.positions += state.positionsBuf.numItems;
                }
                if (state.normals) {
                    state.normalsBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, state.normals, state.normals.length, 3, gl.STATIC_DRAW);
                    memoryStats.normals += state.normalsBuf.numItems;
                }
                if (state.colors) {
                    state.colorsBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, state.colors, state.colors.length, 4, gl.STATIC_DRAW);
                    memoryStats.colors += state.colorsBuf.numItems;
                }
                if (state.uv) {
                    state.uvBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, state.uv, state.uv.length, 2, gl.STATIC_DRAW);
                    memoryStats.uvs += state.uvBuf.numItems;
                }
            }
        },

        _buildHash: function () {
            var state = this._state;
            var hash = ["/g"];
            hash.push("/" + state.primitive + ";");
            if (state.positions) {
                hash.push("p");
            }
            if (state.colors) {
                hash.push("c");
            }
            if (state.normals || state.autoVertexNormals) {
                hash.push("n");
            }
            if (state.uv) {
                hash.push("u");
            }
            if (state.quantized) {
                hash.push("cp");
            }
            hash.push(";");
            state.hash = hash.join("");
        },

        _buildGhostEdgesIndices: function () {
            var state = this._state;
            if (!state.positions || !state.indices) {
                return;
            }
            var gl = this.scene.canvas.gl;
            var indicesOffset = state.combined ? this._sceneVertexBufs.getIndicesOffset(state) : 0;
            var edgesIndices = buildEdgesIndices(state.positions, state.indices, state.positionsDecodeMatrix, indicesOffset, this._ghostEdgeThreshold);
            this._edgesIndicesBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, edgesIndices, edgesIndices.length, 1, gl.STATIC_DRAW);
            memoryStats.indices += this._edgesIndicesBuf.numItems;
        },

        _buildPickTriangleVBOs: function () { // Builds positions and indices arrays that allow each triangle to have a unique color
            var state = this._state;
            if (!state.positions || !state.indices) {
                return;
            }
            var gl = this.scene.canvas.gl;
            var arrays = xeogl.math.buildPickTriangles(state.positions, state.indices, state.quantized);
            var pickTrianglePositions = arrays.positions;
            var pickColors = arrays.colors;
            this._pickTrianglePositionsBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickTrianglePositions, pickTrianglePositions.length, 3, gl.STATIC_DRAW);
            this._pickTriangleColorsBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickColors, pickColors.length, 4, gl.STATIC_DRAW, true);
            memoryStats.positions += this._pickTrianglePositionsBuf.numItems;
            memoryStats.colors += this._pickTriangleColorsBuf.numItems;
        },

        _buildPickVertexVBOs: function () {
            // var state = this._state;
            // if (!state.positions || !state.indices) {
            //     return;
            // }
            // var gl = this.scene.canvas.gl;
            // var arrays = xeogl.math.buildPickVertices(state.positions, state.indices, state.quantized);
            // var pickVertexPositions = arrays.positions;
            // var pickColors = arrays.colors;
            // this._pickVertexPositionsBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickVertexPositions, pickVertexPositions.length, 3, gl.STATIC_DRAW);
            // this._pickVertexColorsBuf = new xeogl.renderer.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickColors, pickColors.length, 4, gl.STATIC_DRAW, true);
            // memoryStats.positions += this._pickVertexPositionsBuf.numItems;
            // memoryStats.colors += this._pickVertexColorsBuf.numItems;
        },


        _props: {

            /**
             The Geometry's primitive type.

             Valid types are: 'points', 'lines', 'line-loop', 'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'.

             @property primitive
             @default "triangles"
             @type String
             */
            primitive: {

                get: function () {
                    return this._state.primitiveName;
                }
            },

            /**
             Indicates if this Geometry is quantized.

             Compression is an internally-performed optimization which stores positions, colors, normals and UVs
             in quantized and oct-encoded formats for reduced memory footprint and GPU bus usage.

             Quantized geometry may not be updated.

             @property quantized
             @default false
             @type Boolean
             @final
             */
            quantized: {

                get: function () {
                    return this._state.quantized;
                }
            },

            /**
             Indicates if this Geometry is combined.

             Combination is an internally-performed optimization which combines positions, colors, normals and UVs into
             the same WebGL vertex buffers with other Geometries, in order to reduce the number of buffer binds
             performed per frame.

             @property combined
             @default false
             @type Boolean
             @final
             */
            combined: {

                get: function () {
                    return this._state.combined;
                }
            },


            /**
             The Geometry's vertex positions.

             @property positions
             @default null
             @type Float32Array
             */
            positions: {

                get: function () {
                    if (!this._state.positions) {
                        return;
                    }
                    if (!this._state.quantized) {
                        return this._state.positions;
                    }
                    if (!this._decompressedPositions) {
                        this._decompressedPositions = new Float32Array(this._state.positions.length);
                        xeogl.math.decompressPositions(this._state.positions, this._state.positionsDecodeMatrix, this._decompressedPositions);
                    }
                    return this._decompressedPositions;
                },

                set: function (newPositions) {
                    if (this._state.quantized) {
                        this.error("can't update geometry positions - quantized geometry is immutable"); // But will be eventually
                        return;
                    }
                    var state = this._state;
                    var positions = state.positions;
                    if (!positions) {
                        this.error("can't update geometry positions - geometry has no positions");
                        return;
                    }
                    if (positions.length !== newPositions.length) {
                        this.error("can't update geometry positions - new positions are wrong length");
                        return;
                    }
                    positions.set(newPositions);
                    if (state.positionsBuf) {
                        state.positionsBuf.setData(positions);
                    }
                    if (this._state.combined) {
                        this._sceneVertexBufs.setPositions(state);
                    }
                    this._setBoundaryDirty();
                    this._renderer.imageDirty();
                }
            },

            /**
             The Geometry's vertex normals.

             @property normals
             @default null
             @type Float32Array
             */
            normals: {

                get: function () {
                    if (!this._state.normals) {
                        return;
                    }
                    if (!this._state.quantized) {
                        return this._state.normals;
                    }
                    if (!this._decompressedNormals) {
                        var lenCompressed = this._state.normals.length;
                        var lenDecompressed = lenCompressed + (lenCompressed / 2); // 2 -> 3
                        this._decompressedNormals = new Float32Array(lenDecompressed);
                        xeogl.math.octDecodeVec2s(this._state.normals, this._decompressedNormals);
                    }
                    return this._decompressedNormals;
                },

                set: function (newNormals) {
                    if (this._state.quantized) {
                        this.error("can't update geometry normals - quantized geometry is immutable"); // But will be eventually
                        return;
                    }
                    var state = this._state;
                    var normals = state.normals;
                    if (!normals) {
                        this.error("can't update geometry normals - geometry has no normals");
                        return;
                    }
                    if (normals.length !== newNormals.length) {
                        this.error("can't update geometry normals - new normals are wrong length");
                        return;
                    }
                    normals.set(newNormals);
                    if (state.normalsBuf) {
                        state.normalsBuf.setData(normals);
                    }
                    if (this._state.combined) {
                        this._sceneVertexBufs.setNormals(state);
                    }
                    this._renderer.imageDirty();
                }
            },

            /**
             The Geometry's UV coordinates.

             @property uv
             @default null
             @type Float32Array
             */
            uv: {

                get: function () {
                    if (!this._state.uv) {
                        return;
                    }
                    if (!this._state.quantized) {
                        return this._state.uv;
                    }
                    if (!this._decompressedUV) {
                        this._decompressedUV = new Float32Array(this._state.uv.length);
                        xeogl.math.decompressUVs(this._state.uv, this._state.uvDecodeMatrix, this._decompressedUV);
                    }
                    return this._decompressedUV;
                },

                set: function (newUV) {
                    if (this._state.quantized) {
                        this.error("can't update geometry UVs - quantized geometry is immutable"); // But will be eventually
                        return;
                    }
                    var state = this._state;
                    var uv = state.uv;
                    if (!uv) {
                        this.error("can't update geometry UVs - geometry has no UVs");
                        return;
                    }
                    if (uv.length !== newUV.length) {
                        this.error("can't update geometry UVs - new UVs are wrong length");
                        return;
                    }
                    uv.set(newUV);
                    if (state.uvBuf) {
                        state.uvBuf.setData(uv);
                    }
                    if (this._state.combined) {
                        this._sceneVertexBufs.setUVs(state);
                    }
                    this._renderer.imageDirty();
                }
            },

            /**
             The Geometry's vertex colors.

             @property colors
             @default null
             @type Float32Array
             */
            colors: {

                get: function () {
                    return this._state.colors;
                },

                set: function (newColors) {
                    if (this._state.quantized) {
                        this.error("can't update geometry colors - quantized geometry is immutable"); // But will be eventually
                        return;
                    }
                    var state = this._state;
                    var colors = state.colors;
                    if (!colors) {
                        this.error("can't update geometry colors - geometry has no colors");
                        return;
                    }
                    if (colors.length !== newColors.length) {
                        this.error("can't update geometry colors - new colors are wrong length");
                        return;
                    }
                    colors.set(newColors);
                    if (state.colorsBuf) {
                        state.colorsBuf.setData(colors);
                    }
                    if (this._state.combined) {
                        this._sceneVertexBufs.setColors(state);
                    }
                    this._renderer.imageDirty();
                }
            },

            /**
             The Geometry's indices.

             If ````xeogl.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"]```` is true, then this can be
             a ````Uint32Array````, otherwise it needs to be a ````Uint16Array````.

             @property indices
             @default null
             @type Uint16Array | Uint32Array
             @final
             */
            indices: {
                get: function () {
                    return this._state.indices;
                }
            },

            /**
             * Local-space axis-aligned 3D boundary (AABB) of this geometry.
             *
             * The AABB is represented by a six-element Float32Array containing the min/max extents of the
             * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
             *
             * @property aabb
             * @final
             * @type {Float32Array}
             */
            aabb: {
                get: function () {
                    if (this._aabbDirty) {
                        if (!this._aabb) {
                            this._aabb = xeogl.math.AABB3();
                        }
                        xeogl.math.positions3ToAABB3(this._state.positions, this._aabb, this._state.positionsDecodeMatrix);
                        this._aabbDirty = false;
                    }
                    return this._aabb;
                }
            },

            /**
             * Local-space oriented 3D boundary (OBB) of this geometry.
             *
             * The OBB is represented by a 32-element Float32Array containing the eight vertices of the box,
             * where each vertex is a homogeneous coordinate having [x,y,z,w] elements.
             *
             * @property obb
             * @final
             * @type {Float32Array}
             */
            obb: {
                get: (function () {
                    var aabb = xeogl.math.AABB3();
                    return function () {
                        if (this._obbDirty) {
                            if (!this._obb) {
                                this._obb = xeogl.math.OBB3();
                            }
                            xeogl.math.positions3ToAABB3(this._state.positions, aabb, this._state.positionsDecodeMatrix);
                            xeogl.math.AABB3ToOBB3(aabb, this._obb);
                            this._obbDirty = false;
                        }
                        return this._obb;
                    };
                })()
            },

            kdtree: {
                get: function () {
                    var state = this._state;
                    if (!state.indices || !state.positions) {
                        this.error("Can't provide a KD-tree: no indices/positions");
                        return;
                    }
                    if (!this._kdtree) {
                        this._kdtree = xeogl.math.buildKDTree(state.indices, state.positions, this._state.positionsDecodeMatrix);
                    }
                    return this._kdtree;
                }
            }
        },

        _setBoundaryDirty: function () {
            if (this._boundaryDirty) {
                return;
            }
            this._boundaryDirty = true;
            this._aabbDirty = true;
            this._obbDirty = true;
            if (this._localBoundary) {
                this._localBoundary.fire("updated", true);
            }

            /**
             Fired whenever this Geometry's boundary changes.

             Get the latest boundary from the Geometry's {{#crossLink "Geometry/aabb:property"}}{{/crossLink}}
             and {{#crossLink "Geometry/obb:property"}}{{/crossLink}} properties.

             @event boundary

             */
            this.fire("boundary");
        },

        _getState: function () {
            return this._state;
        },

        _getVertexBufs: function () {
            return this._state && this._state.combined ? this._sceneVertexBufs.getVertexBufs(this._state) : nullVertexBufs;
        },

        _destroy: function () {

            this.scene.canvas.off(this._webglContextRestored);
            var state = this._state;

            if (state.indicesBuf) {
                state.indicesBuf.destroy();
            }

            if (this._edgesIndicesBuf) {
                this._edgesIndicesBuf.destroy();
            }

            if (state.indicesBufCombined) {
                state.indicesBufCombined.destroy();
            }

            if (this._pickTrianglePositionsBuf) {
                this._pickTrianglePositionsBuf.destroy();
            }

            if (this._pickTriangleColorsBuf) {
                this._pickTriangleColorsBuf.destroy();
            }

            if (this._pickVertexPositionsBuf) {
                this._pickVertexPositionsBuf.destroy();
            }

            if (this._pickVertexColorsBuf) {
                this._pickVertexColorsBuf.destroy();
            }

            if (this._localBoundary) {
                this._localBoundary.destroy();
            }

            if (this._state.combined) {
                this._sceneVertexBufs.removeGeometry(state);
            }

            state.destroy();

            memoryStats.meshes--;
        }
    });

    function getBounds(array, stride) {
        var min = new Float32Array(stride);
        var max = new Float32Array(stride);
        var i, j;
        for (i = 0; i < stride; i++) {
            min[i] = Number.MAX_VALUE;
            max[i] = -Number.MAX_VALUE;
        }
        for (i = 0; i < array.length; i += stride) {
            for (j = 0; j < stride; j++) {
                min[j] = Math.min(min[j], array[i + j]);
                max[j] = Math.max(max[j], array[i + j]);
            }
        }
        return {
            min: min,
            max: max
        };
    }

    var quantizeVec3 = (function () {
        var math = xeogl.math;
        var translate = math.mat4();
        var scale = math.mat4();
        return function (array, min, max) {
            var quantized = new Uint16Array(array.length);
            var multiplier = new Float32Array([
                65535 / (max[0] - min[0]),
                65535 / (max[1] - min[1]),
                65535 / (max[2] - min[2])
            ]);
            var i;
            for (i = 0; i < array.length; i += 3) {
                quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
                quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
                quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);
            }
            math.identityMat4(translate);
            math.translationMat4v(min, translate);
            math.identityMat4(scale);
            math.scalingMat4v([
                (max[0] - min[0]) / 65535,
                (max[1] - min[1]) / 65535,
                (max[2] - min[2]) / 65535
            ], scale);
            var decodeMat = math.mulMat4(translate, scale, math.identityMat4());
            return {
                quantized: quantized,
                decode: decodeMat
            };
        }
    })();

    var quantizeVec2 = (function () {
        var math = xeogl.math;
        var translate = math.mat3();
        var scale = math.mat3();
        return function (array, min, max) {
            var quantized = new Uint16Array(array.length);
            var multiplier = new Float32Array([
                65535 / (max[0] - min[0]),
                65535 / (max[1] - min[1])
            ]);
            var i;
            for (i = 0; i < array.length; i += 2) {
                quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);
                quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);
            }
            math.identityMat3(translate);
            math.translationMat3v(min, translate);
            math.identityMat3(scale);
            math.scalingMat3v([
                (max[0] - min[0]) / 65535,
                (max[1] - min[1]) / 65535
            ], scale);
            var decodeMat = math.mulMat3(translate, scale, math.identityMat3());
            return {
                quantized: quantized,
                decode: decodeMat
            };
        };
    })();

    function octEncode(array) {
        var encoded = new Int8Array(array.length * 2 / 3);
        var oct, dec, best, currentCos, bestCos;
        var i, ei;
        for (i = 0, ei = 0; i < array.length; i += 3, ei += 2) {
            // Test various combinations of ceil and floor
            // to minimize rounding errors
            best = oct = octEncodeVec3(array, i, "floor", "floor");
            dec = octDecodeVec2(oct);
            currentCos = bestCos = dot(array, i, dec);
            oct = octEncodeVec3(array, i, "ceil", "floor");
            dec = octDecodeVec2(oct);
            currentCos = dot(array, i, dec);
            if (currentCos > bestCos) {
                best = oct;
                bestCos = currentCos;
            }
            oct = octEncodeVec3(array, i, "floor", "ceil");
            dec = octDecodeVec2(oct);
            currentCos = dot(array, i, dec);
            if (currentCos > bestCos) {
                best = oct;
                bestCos = currentCos;
            }
            oct = octEncodeVec3(array, i, "ceil", "ceil");
            dec = octDecodeVec2(oct);
            currentCos = dot(array, i, dec);
            if (currentCos > bestCos) {
                best = oct;
                bestCos = currentCos;
            }
            encoded[ei] = best[0];
            encoded[ei + 1] = best[1];
        }
        return encoded;
    }

    // Oct-encode single normal vector in 2 bytes
    function octEncodeVec3(array, i, xfunc, yfunc) {
        var x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
        var y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));
        if (array[i + 2] < 0) {
            var tempx = x;
            var tempy = y;
            tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
            tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
            x = tempx;
            y = tempy;
        }
        return new Int8Array([
            Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)),
            Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))
        ]);
    }

    // Decode an oct-encoded normal
    function octDecodeVec2(oct) {
        var x = oct[0];
        var y = oct[1];
        x /= x < 0 ? 127 : 128;
        y /= y < 0 ? 127 : 128;
        var z = 1 - Math.abs(x) - Math.abs(y);
        if (z < 0) {
            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        }
        var length = Math.sqrt(x * x + y * y + z * z);
        return [
            x / length,
            y / length,
            z / length
        ];
    }

    // Dot product of a normal in an array against a candidate decoding
    function dot(array, i, vec3) {
        return array[i] * vec3[0] + array[i + 1] * vec3[1] + array[i + 2] * vec3[2];
    }

    /*
     * Checks for duplicate vertices with hashmap.
     * Duplicated vertices are removed
     * and faces' vertices are updated.
     */

    // Should return { positions:  newPositions, indices: newIndices };
    var mergeVertices = function (positions, indices) {

        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var unique = [], changes = [];

        var v, key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow(10, precisionPoints);
        var i, il, face;
        var indices, j, jl;

        for (i = 0, il = this.vertices.length; i < il; i++) {

            v = this.vertices[i];
            key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

            if (verticesMap[key] === undefined) {

                verticesMap[key] = i;
                unique.push(this.vertices[i]);
                changes[i] = unique.length - 1;

            } else {

                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                changes[i] = changes[verticesMap[key]];
            }
        }

        // if faces are completely degenerate after merging vertices, we
        // have to remove them from the geometry.
        var faceIndicesToRemove = [];

        for (i = 0, il = this.faces.length; i < il; i++) {

            face = this.faces[i];

            face.a = changes[face.a];
            face.b = changes[face.b];
            face.c = changes[face.c];

            indices = [face.a, face.b, face.c];

            // if any duplicate vertices are found in a Face3
            // we have to remove the face as nothing can be saved
            for (var n = 0; n < 3; n++) {
                if (indices[n] === indices[( n + 1 ) % 3]) {
                    faceIndicesToRemove.push(i);
                    break;
                }
            }
        }

        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
            var idx = faceIndicesToRemove[i];
            this.faces.splice(idx, 1);
            for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                this.faceVertexUvs[j].splice(idx, 1);
            }
        }

        // Use unique set of vertices

        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
    };


    var buildEdgesIndices = (function () {

        var math = xeogl.math;

        var faces = [];
        var numFaces = 0;
        var compa = new Uint16Array(3);
        var compb = new Uint16Array(3);
        var compc = new Uint16Array(3);
        var a = math.vec3();
        var b = math.vec3();
        var c = math.vec3();
        var cb = math.vec3();
        var ab = math.vec3();
        var cross = math.vec3();
        var normal = math.vec3();

        function buildFaces(positions, indices, positionsDecodeMatrix) {

            numFaces = 0;

            for (var i = 0, len = indices.length; i < len; i += 3) {

                var ia = ((indices[i + 0]) * 3);
                var ib = ((indices[i + 1]) * 3);
                var ic = ((indices[i + 2]) * 3);

                if (positionsDecodeMatrix) {

                    compa[0] = positions[ia];
                    compa[1] = positions[ia + 1];
                    compa[2] = positions[ia + 2];

                    compb[0] = positions[ib];
                    compb[1] = positions[ib + 1];
                    compb[2] = positions[ib + 2];

                    compc[0] = positions[ic];
                    compc[1] = positions[ic + 1];
                    compc[2] = positions[ic + 2];

                    // Decode

                    math.decompressPosition(compa, positionsDecodeMatrix, a);
                    math.decompressPosition(compb, positionsDecodeMatrix, b);
                    math.decompressPosition(compc, positionsDecodeMatrix, c);

                } else {

                    a[0] = positions[ia];
                    a[1] = positions[ia + 1];
                    a[2] = positions[ia + 2];

                    b[0] = positions[ib];
                    b[1] = positions[ib + 1];
                    b[2] = positions[ib + 2];

                    c[0] = positions[ic];
                    c[1] = positions[ic + 1];
                    c[2] = positions[ic + 2];
                }

                math.subVec3(c, b, cb);
                math.subVec3(a, b, ab);
                math.cross3Vec3(cb, ab, cross);
                math.normalizeVec3(cross, normal);

                var face = faces[numFaces] || (faces[numFaces] = {normal: math.vec3()});

                face.normal[0] = normal[0];
                face.normal[1] = normal[1];
                face.normal[2] = normal[2];

                numFaces++;
            }
        }

        return function (positions, indices, positionsDecodeMatrix, indicesOffset, ghostEdgeThreshold) {

            var math = xeogl.math;

            buildFaces(positions, indices, positionsDecodeMatrix);

            var edgeIndices = [];
            var thresholdDot = Math.cos(xeogl.math.DEGTORAD * ghostEdgeThreshold);
            var edges = {};
            var edge1;
            var edge2;
            var index1;
            var index2;
            var key;

            var a = math.vec3();
            var b = math.vec3();

            for (var i = 0, len = indices.length; i < len; i += 3) {

                var faceIndex = i / 3;

                for (var j = 0; j < 3; j++) {

                    edge1 = indices[i + j];
                    edge2 = indices[i + ((j + 1) % 3)];

                    index1 = Math.min(edge1, edge2);
                    index2 = Math.max(edge1, edge2);

                    key = index1 + "," + index2;

                    if (edges[key] === undefined) {
                        edges[key] = {
                            index1: index1,
                            index2: index2,
                            face1: faceIndex,
                            face2: undefined
                        };
                    } else {
                        edges[key].face2 = faceIndex;
                    }
                }
            }

            var largeIndex = false;

            for (key in edges) {

                var e = edges[key];

                // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

                if (e.face2 !== undefined) {

                    var normal1 = faces[e.face1].normal;
                    var normal2 = faces[e.face2].normal;

                    var dot = math.dotVec3(normal1, normal2);

                    if (dot > thresholdDot) {
                        continue;
                    }
                }

                var ia = e.index1 + indicesOffset;
                var ib = e.index2 + indicesOffset;

                if (!largeIndex && ia > 65535 || ib > 65535) {
                    largeIndex = true;
                }

                edgeIndices.push(ia);
                edgeIndices.push(ib);
            }

            return largeIndex ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);
        }
    })();
})();;/**
 A **BoxGeometry** is a parameterized {{#crossLink "Geometry"}}{{/crossLink}} that defines a box-shaped mesh for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 <a href="../../examples/#geometry_primitives_box"><img src="../../assets/images/screenshots/BoxGeometry.png"></img></a>

 ## Overview

 * Dynamically modify a BoxGeometry's dimensions at any time by updating its {{#crossLink "BoxGeometry/center:property"}}{{/crossLink}}, {{#crossLink "BoxGeometry/xSize:property"}}{{/crossLink}}, {{#crossLink "BoxGeometry/ySize:property"}}{{/crossLink}} and {{#crossLink "BoxGeometry/zSize:property"}}{{/crossLink}} properties.
 * Dynamically switch its primitive type between ````"points"````, ````"lines"```` and ````"triangles"```` at any time by
 updating its {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} property.

 ## Examples

 * [Textured BoxGeometry](../../examples/#geometry_primitives_box)

 ## Usage

 An {{#crossLink "Entity"}}{{/crossLink}} with a BoxGeometry and a {{#crossLink "PhongMaterial"}}{{/crossLink}} with
 diffuse {{#crossLink "Texture"}}{{/crossLink}}:

 ````javascript
 new xeogl.Entity({

     geometry: new xeogl.BoxGeometry({
        center: [0,0,0],
        xSize: 1,  // Half-size on each axis; BoxGeometry is actually two units big on each side.
        ySize: 1,
        zSize: 1
     }),

     material: new xeogl.PhongMaterial({
        diffuseMap: new xeogl.Texture({
            src: "textures/diffuse/uvGrid2.jpg"
        })
     })
 });
 ````

 @class BoxGeometry
 @module xeogl
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this BoxGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this BoxGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values for a BoxGeometry are 'points', 'lines' and 'triangles'.
 @param [cfg.center] {Float32Array} 3D point indicating the center position.
 @param [cfg.xSize=1.0] {Number} Half-size on the X-axis.
 @param [cfg.ySize=1.0] {Number} Half-size on the Y-axis.
 @param [cfg.zSize=1.0] {Number} Half-size on the Z-axis.
 @extends Geometry
 */
(function () {

    "use strict";

    xeogl.BoxGeometry = xeogl.Geometry.extend({

        type: "xeogl.BoxGeometry",

        _init: function (cfg) {

            var xSize = cfg.xSize || 1;
            if (xSize < 0) {
                this.error("negative xSize not allowed - will invert");
                xSize *= -1;
            }

            var ySize = cfg.ySize || 1;
            if (ySize < 0) {
                this.error("negative ySize not allowed - will invert");
                ySize *= -1;
            }

            var zSize = cfg.zSize || 1;
            if (zSize < 0) {
                this.error("negative zSize not allowed - will invert");
                zSize *= -1;
            }

            var center = cfg.center;
            var centerX = center ? center[0] : 0;
            var centerY = center ? center[1] : 0;
            var centerZ = center ? center[2] : 0;

            var xmin = -xSize + centerX;
            var ymin = -ySize + centerY;
            var zmin = -zSize + centerZ;
            var xmax = xSize + centerX;
            var ymax = ySize + centerY;
            var zmax = zSize + centerZ;

            this._super(xeogl._apply(cfg, {

                // The vertices - eight for our cube, each
                // one spanning three array elements for X,Y and Z
                positions: [

                    // v0-v1-v2-v3 front
                    xmax, ymax, zmax,
                    xmin, ymax, zmax,
                    xmin, ymin, zmax,
                    xmax, ymin, zmax,

                    // v0-v3-v4-v1 right
                    xmax, ymax, zmax,
                    xmax, ymin, zmax,
                    xmax, ymin, zmin,
                    xmax, ymax, zmin,

                    // v0-v1-v6-v1 top
                    xmax, ymax, zmax,
                    xmax, ymax, zmin,
                    xmin, ymax, zmin,
                    xmin, ymax, zmax,

                    // v1-v6-v7-v2 left
                    xmin, ymax, zmax,
                    xmin, ymax, zmin,
                    xmin, ymin, zmin,
                    xmin, ymin, zmax,

                    // v7-v4-v3-v2 bottom
                    xmin, ymin, zmin,
                    xmax, ymin, zmin,
                    xmax, ymin, zmax,
                    xmin, ymin, zmax,

                    // v4-v7-v6-v1 back
                    xmax, ymin, zmin,
                    xmin, ymin, zmin,
                    xmin, ymax, zmin,
                    xmax, ymax, zmin
                ],

                // Normal vectors, one for each vertex
                normals: [

                    // v0-v1-v2-v3 front
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,

                    // v0-v3-v4-v5 right
                    1, 0, 0,
                    1, 0, 0,
                    1, 0, 0,
                    1, 0, 0,

                    // v0-v5-v6-v1 top
                    0, 1, 0,
                    0, 1, 0,
                    0, 1, 0,
                    0, 1, 0,

                    // v1-v6-v7-v2 left
                    -1, 0, 0,
                    -1, 0, 0,
                    -1, 0, 0,
                    -1, 0, 0,

                    // v7-v4-v3-v2 bottom
                    0, -1, 0,
                    0, -1, 0,
                    0, -1, 0,
                    0, -1, 0,

                    // v4-v7-v6-v5 back
                    0, 0, -1,
                    0, 0, -1,
                    0, 0, -1,
                    0, 0, -1
                ],

                // UV coords
                uv: [

                    // v0-v1-v2-v3 front
                    1, 0,
                    0, 0,
                    0, 1,
                    1, 1,

                    // v0-v3-v4-v1 right
                    0, 0,
                    0, 1,
                    1, 1,
                    1, 0,

                    // v0-v1-v6-v1 top
                    1, 1,
                    1, 0,
                    0, 0,
                    0, 1,

                    // v1-v6-v7-v2 left
                    1, 0,
                    0, 0,
                    0, 1,
                    1, 1,

                    // v7-v4-v3-v2 bottom
                    0, 1,
                    1, 1,
                    1, 0,
                    0, 0,

                    // v4-v7-v6-v1 back
                    0, 1,
                    1, 1,
                    1, 0,
                    0, 0
                ],

                // Indices - these organise the
                // positions and uv texture coordinates
                // into geometric primitives in accordance
                // with the "primitive" parameter,
                // in this case a set of three indices
                // for each triangle.
                //
                // Note that each triangle is specified
                // in counter-clockwise winding order.
                //
                // You can specify them in clockwise
                // order if you configure the Modes
                // node's frontFace flag as "cw", instead of
                // the default "ccw".
                indices: [
                    0, 1, 2,
                    0, 2, 3,
                    // front
                    4, 5, 6,
                    4, 6, 7,
                    // right
                    8, 9, 10,
                    8, 10, 11,
                    // top
                    12, 13, 14,
                    12, 14, 15,
                    // left
                    16, 17, 18,
                    16, 18, 19,
                    // bottom
                    20, 21, 22,
                    20, 22, 23
                ],

                // Tangents are lazy-computed from normals and UVs
                // for Normal mapping once we know we have texture

                tangents: null
            }));

            this.box = true;
        }
    });

})();
;/**
 A **TorusGeometry** is a parameterized {{#crossLink "Geometry"}}{{/crossLink}} that defines a torus-shaped mesh for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 <a href="../../examples/#geometry_primitives_torus"><img src="../../assets/images/screenshots/TorusGeometry.png"></img></a>

 ## Overview

 * Dynamically modify a TorusGeometry's shape at any time by updating its {{#crossLink "TorusGeometry/center:property"}}{{/crossLink}}, {{#crossLink "TorusGeometry/radius:property"}}{{/crossLink}}, {{#crossLink "TorusGeometry/tube:property"}}{{/crossLink}},
 {{#crossLink "TorusGeometry/radialSegments:property"}}{{/crossLink}}, {{#crossLink "TorusGeometry/tubeSegments:property"}}{{/crossLink}},  and
 {{#crossLink "TorusGeometry/arc:property"}}{{/crossLink}} properties.
 * Dynamically switch its primitive type between ````"points"````, ````"lines"```` and ````"triangles"```` at any time by
 updating its {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} property.

 ## Examples


 * [Textured TorusGeometry](../../examples/#geometry_primitives_torus)


 ## Usage

 An {{#crossLink "Entity"}}{{/crossLink}} with a TorusGeometry and a {{#crossLink "PhongMaterial"}}{{/crossLink}} with
 diffuse {{#crossLink "Texture"}}{{/crossLink}}:

 ````javascript
 new xeogl.Entity({

     geometry: new xeogl.TorusGeometry({
         center: [0,0,0],
         radius: 1.0,
         tube: 0.5,
         radialSegments: 32,
         tubeSegments: 24,
         arc: Math.PI * 2.0
     }),

     material: new xeogl.PhongMaterial({
        diffuseMap: new xeogl.Texture({
            src: "textures/diffuse/uvGrid2.jpg"
        })
     })
 });
 ````

 @class TorusGeometry
 @module xeogl
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this TorusGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this TorusGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values for a TorusGeometry are 'points', 'lines' and 'triangles'.
 @param [cfg.center] {Float32Array} 3D point indicating the center position of the TorusGeometry.
 @param [cfg.radius=1] {Number} The overall radius of the TorusGeometry.
 @param [cfg.tube=0.3] {Number} The tube radius of the TorusGeometry.
 @param [cfg.radialSegments=32] {Number} The number of radial segments that make up the TorusGeometry.
 @param [cfg.tubeSegments=24] {Number} The number of tubular segments that make up the TorusGeometry.
 @param [cfg.arc=Math.PI / 2.0] {Number} The length of the TorusGeometry's arc in radians, where Math.PI*2 is a closed torus.
 @extends Geometry
 */
(function () {

    "use strict";

    xeogl.TorusGeometry = xeogl.Geometry.extend({

        type: "xeogl.TorusGeometry",

        _init: function (cfg) {

            var radius = cfg.radius || 1;
            if (radius < 0) {
                this.error("negative radius not allowed - will invert");
                radius *= -1;
            }
            radius *= 0.5;

            var tube = cfg.tube || 0.3;
            if (tube < 0) {
                this.error("negative tube not allowed - will invert");
                tube *= -1;
            }

            var radialSegments = cfg.radialSegments || 32;
            if (radialSegments < 0) {
                this.error("negative radialSegments not allowed - will invert");
                radialSegments *= -1;
            }
            if (radialSegments < 4) {
                radialSegments = 4;
            }

            var tubeSegments = cfg.tubeSegments || 24;
            if (tubeSegments < 0) {
                this.error("negative tubeSegments not allowed - will invert");
                tubeSegments *= -1;
            }
            if (tubeSegments < 4) {
                tubeSegments = 4;
            }

            var arc = cfg.arc || Math.PI * 2;
            if (arc < 0) {
                this.warn("negative arc not allowed - will invert");
                arc *= -1;
            }
            if (arc > 360) {
                arc = 360;
            }

            var center = cfg.center;
            var centerX = center ? center[0] : 0;
            var centerY = center ? center[1] : 0;
            var centerZ = center ? center[2] : 0;

            var positions = [];
            var normals = [];
            var uvs = [];
            var indices = [];

            var u;
            var v;
            var x;
            var y;
            var z;
            var vec;

            var i;
            var j;

            for (j = 0; j <= tubeSegments; j++) {
                for (i = 0; i <= radialSegments; i++) {

                    u = i / radialSegments * arc;
                    v = j / tubeSegments * Math.PI * 2;

                    centerX = radius * Math.cos(u);
                    centerY = radius * Math.sin(u);

                    x = (radius + tube * Math.cos(v) ) * Math.cos(u);
                    y = (radius + tube * Math.cos(v) ) * Math.sin(u);
                    z = tube * Math.sin(v);

                    positions.push(x + centerX);
                    positions.push(y + centerY);
                    positions.push(z + centerZ);

                    uvs.push(1 - (i / radialSegments));
                    uvs.push((j / tubeSegments));

                    vec = xeogl.math.normalizeVec3(xeogl.math.subVec3([x, y, z], [centerX, centerY, centerZ], []), []);

                    normals.push(vec[0]);
                    normals.push(vec[1]);
                    normals.push(vec[2]);
                }
            }

            var a;
            var b;
            var c;
            var d;

            for (j = 1; j <= tubeSegments; j++) {
                for (i = 1; i <= radialSegments; i++) {

                    a = ( radialSegments + 1 ) * j + i - 1;
                    b = ( radialSegments + 1 ) * ( j - 1 ) + i - 1;
                    c = ( radialSegments + 1 ) * ( j - 1 ) + i;
                    d = ( radialSegments + 1 ) * j + i;

                    indices.push(a);
                    indices.push(b);
                    indices.push(c);

                    indices.push(c);
                    indices.push(d);
                    indices.push(a);
                }
            }

            this._super(xeogl._apply(cfg, {
                positions: positions,
                normals: normals,
                uv: uvs,
                indices: indices
            }));
        }
    });

})();
;/**
 A **SphereGeometry** is a parameterized {{#crossLink "Geometry"}}{{/crossLink}} that defines a sphere-shaped mesh for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 <a href="../../examples/#geometry_primitives_sphere"><img src="../../assets/images/screenshots/SphereGeometry.png"></img></a>

 ## Examples

 * [Textured SphereGeometry](../../examples/#geometry_primitives_sphere)

 ## Usage

 An {{#crossLink "Entity"}}{{/crossLink}} with a SphereGeometry and a {{#crossLink "PhongMaterial"}}{{/crossLink}} with
 diffuse {{#crossLink "Texture"}}{{/crossLink}}:

 ````javascript
 new xeogl.Entity({

     geometry: new xeogl.SphereGeometry({
         center: [0,0,0],
         radius: 1.5,
         heightSegments: 60,
         widthSegments: 60
     }),

     material: new xeogl.PhongMaterial({
        diffuseMap: new xeogl.Texture({
            src: "textures/diffuse/uvGrid2.jpg"
        })
     })
 });
 ````

 @class SphereGeometry
 @module xeogl
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this SphereGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this SphereGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values for a SphereGeometry are 'points', 'lines' and 'triangles'.
 @param [cfg.center] {Float32Array} 3D point indicating the center position of the SphereGeometry.
 @param [cfg.radius=1] {Number}
 @param [cfg.heightSegments=24] {Number} The SphereGeometry's number of latitudinal bands.
 @param [cfg.widthSegments=18] {Number} The SphereGeometry's number of longitudinal bands.
 @param [cfg.lod=1] {Number} Level-of-detail, in range [0..1].
 @extends Geometry
 */
(function () {

    "use strict";

    xeogl.SphereGeometry = xeogl.Geometry.extend({

        type: "xeogl.SphereGeometry",

        _init: function (cfg) {

            var lod = cfg.lod || 1;

            var centerX = cfg.center ? cfg.center[0] : 0;
            var centerY = cfg.center ? cfg.center[1] : 0;
            var centerZ = cfg.center ? cfg.center[2] : 0;

            var radius = cfg.radius || 1;
            if (radius < 0) {
                this.warn("negative radius not allowed - will invert");
                radius *= -1;
            }

            var heightSegments = cfg.heightSegments || 18;
            if (heightSegments < 0) {
                this.warn("negative heightSegments not allowed - will invert");
                heightSegments *= -1;
            }
            heightSegments = Math.floor(lod * heightSegments);
            if (heightSegments < 18) {
                heightSegments = 18;
            }

            var widthSegments = cfg.widthSegments || 18;
            if (widthSegments < 0) {
                this.warn("negative widthSegments not allowed - will invert");
                widthSegments *= -1;
            }
            widthSegments = Math.floor(lod * widthSegments);
            if (widthSegments < 18) {
                widthSegments = 18;
            }

            var positions = [];
            var normals = [];
            var uvs = [];
            var indices = [];

            var i;
            var j;

            var theta;
            var sinTheta;
            var cosTheta;

            var phi;
            var sinPhi;
            var cosPhi;

            var x;
            var y;
            var z;

            var u;
            var v;

            var first;
            var second;

            for (i = 0; i <= heightSegments; i++) {

                theta = i * Math.PI / heightSegments;
                sinTheta = Math.sin(theta);
                cosTheta = Math.cos(theta);

                for (j = 0; j <= widthSegments; j++) {

                    phi = j * 2 * Math.PI / widthSegments;
                    sinPhi = Math.sin(phi);
                    cosPhi = Math.cos(phi);

                    x = cosPhi * sinTheta;
                    y = cosTheta;
                    z = sinPhi * sinTheta;
                    u = 1.0 - j / widthSegments;
                    v = i / heightSegments;

                    normals.push(x);
                    normals.push(y);
                    normals.push(z);

                    uvs.push(u);
                    uvs.push(v);

                    positions.push(centerX + radius * x);
                    positions.push(centerY + radius * y);
                    positions.push(centerZ + radius * z);
                }
            }

            for (i = 0; i < heightSegments; i++) {
                for (j = 0; j < widthSegments; j++) {

                    first = (i * (widthSegments + 1)) + j;
                    second = first + widthSegments + 1;

                    indices.push(first + 1);
                    indices.push(second + 1);
                    indices.push(second);
                    indices.push(first + 1);
                    indices.push(second);
                    indices.push(first);
                }
            }

            this._super(xeogl._apply(cfg, {
                positions: positions,
                normals: normals,
                uv: uvs,
                indices: indices
            }));
        }
    });

})();
;/**
 An **OBBGeometry** is a {{#crossLink "Geometry"}}{{/crossLink}} that shows the extents of an oriented bounding box (OBB).

 <a href="../../examples/#geometry_primitives_OBBGeometry"><img src="http://i.giphy.com/3o6ZsSVy0NKXZ1vDSo.gif"></img></a>

 ## Overview

 * A World-space OBB a bounding box that's oriented to its contents, given as a 32-element array containing the homogeneous coordinates for the eight corner vertices, ie. each having elements [x,y,z,w].
 * Set an OBBGeometry's {{#crossLink "OBBGeometry/targetOBB:property"}}{{/crossLink}} property to an OBB to fix it to those extents, or
 * Set an OBBGeometry's {{#crossLink "OBBGeometry/target:property"}}{{/crossLink}} property to any {{#crossLink "Component"}}{{/crossLink}} subtype that has an OBB.

 ## Examples

 * [Rendering an OBBGeometry](../../examples/#geometry_primitives_OBBGeometry)

 ## Usage

 ````javascript
 // First Entity with a TorusGeometry
 var entity = new xeogl.Entity({
     geometry: new xeogl.TorusGeometry()
 });

 // Second Entity with an OBBGeometry that shows a wireframe box
 // for the World-space boundary of the first Entity

 var boundaryHelper = new xeogl.Entity({

     geometry: new xeogl.OBBGeometry({
         target: entity
     }),

     material: new xeogl.PhongMaterial({
         diffuse: [0.5, 1.0, 0.5],
         emissive: [0.5, 1.0, 0.5],
         lineWidth:2
     })
 });
 ````

 Now whenever our entity {{#crossLink "Entity"}}{{/crossLink}} changes shape or position, our OBBGeometry will automatically
 update to stay fitted to it.

 We could also directly configure the OBBGeometry with the {{#crossLink "Entity"}}{{/crossLink}}'s {{#crossLink "Entity/obb:property"}}OBB{{/crossLink}}:

 ````javascript
 var boundaryHelper2 = new xeogl.Entity({

     geometry: new xeogl.OBBGeometry({
         targetOBB: entity.obb
     }),

     material: new xeogl.PhongMaterial({
         diffuse: [0.5, 1.0, 0.5],
         emissive: [0.5, 1.0, 0.5],
         lineWidth:2
     })
 });
 ````

 @class OBBGeometry
 @module xeogl
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this OBBGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this OBBGeometry.
 @param [cfg.target] {Component} ID or instance of a {{#crossLink "Component"}}{{/crossLink}} whose OBB we'll show.
 @param [cfg.targetOBB] {Float32Array} An entity-oriented box (OBB) in a 32-element Float32Array
 containing homogeneous coordinates for the eight corner vertices, ie. each having elements (x,y,z,w).
 @extends Component
 */
(function () {

    "use strict";

    xeogl.OBBGeometry = xeogl.Geometry.extend({

        type: "xeogl.OBBGeometry",

        _init: function (cfg) {

            this._super(xeogl._apply(cfg, {
                primitive: cfg.primitive || "lines",
                positions: cfg.positions || [1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0,
                    1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0],
                indices: [0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]
            }));

            if (cfg.target) {
                this.target = cfg.target;

            } else if (cfg.targetOBB) {
                this.targetOBB = cfg.targetOBB;
            }
        },

        _props: {

            /**
             A component whose OBB we'll dynamically fit this AABBGeometry to.

             This property effectively replaces the {{#crossLink "OBBGeometry/targetOBB:property"}}{{/crossLink}} property.

             @property target
             @type Component
             */
            target: {

                set: function (value) {

                    var geometryDirty = false;
                    var self = this;

                    this._attach({
                        name: "target",
                        type: "xeogl.Component",
                        component: value,
                        sceneDefault: false,
                        on: {
                            boundary: function () {
                                if (geometryDirty) {
                                    return;
                                }
                                geometryDirty = true;
                                xeogl.scheduleTask(function () {
                                    self._setPositionsFromOBB(self._attached.target.obb);
                                    geometryDirty = false;
                                });
                            }
                        },
                        onAttached: function () {
                            self._setPositionsFromOBB(self._attached.target.obb);
                        }
                    });
                },

                get: function () {
                    return this._attached.target;
                }
            },

            /**
             Sets this OBBGeometry to an entity-oriented bounding box (OBB), given as a 32-element Float32Array
             containing homogeneous coordinates for the eight corner vertices, ie. each having elements [x,y,z,w].

             This property effectively replaces the {{#crossLink "OBBGeometry/boundary:property"}}{{/crossLink}} property, causing it to become null.

             @property targetOBB
             @type Float32Array
             */
            targetOBB: {

                set: function (value) {

                    if (!value) {
                        return;
                    }

                    if (this._attached.boundary) {
                        this.boundary = null;
                    }

                    this._setPositionsFromOBB(value);
                }
            }
        },

        _setPositionsFromOBB: function (obb) {
            this.positions = [
                obb[0], obb[1], obb[2],
                obb[4], obb[5], obb[6],
                obb[8], obb[9], obb[10],
                obb[12], obb[13], obb[14],
                obb[16], obb[17], obb[18],
                obb[20], obb[21], obb[22],
                obb[24], obb[25], obb[26],
                obb[28], obb[29], obb[30]
            ];
        }
    });
})();
;/**
 An **AABBGeometry** is a {{#crossLink "Geometry"}}{{/crossLink}} that shows the extents of a World-space axis-aligned bounding box (AABB).

 <a href="../../examples/#geometry_primitives_AABBGeometry"><img src="http://i.giphy.com/3o6ZsSVy0NKXZ1vDSo.gif"></img></a>

 ## Overview

 * A World-space AABB is an axis-aligned box given as a six-element array containing the min/max extents of an axis-aligned volume, ie. ````[xmin,ymin,zmin,xmax,ymax,zmax]````.
 * Set a AABBGeometry's {{#crossLink "AABBGeometry/targetAABB:property"}}{{/crossLink}} property to an AABB to fix the AABBGeometry to those extents, or
 * set a AABBGeometry's {{#crossLink "AABBGeometry/target:property"}}{{/crossLink}} property to any target {{#crossLink "Component"}}{{/crossLink}}
 subtype that has an AABB, to make it dynamically fit itself to changes in the target AABB.

 ## Examples

 * [Rendering an AABBGeometry](../../examples/#geometry_primitives_AABBGeometry)

 ## Usage

 ````javascript
 // First Entity with a TorusGeometry
 var entity = new xeogl.Entity({
     geometry: new xeogl.TorusGeometry()
 });

 // Second Entity with an AABBGeometry that shows a wireframe box
 // for the World-space axis-aligned boundary of the first Entity
 var boundaryHelper = new xeogl.Entity({

     geometry: new xeogl.AABBGeometry({
         targetAABB: entity.aabb
     }),

     material: new xeogl.PhongMaterial({
         diffuse: [0.5, 1.0, 0.5],
         emissive: [0.5, 1.0, 0.5],
         lineWidth:2
     })
 });
 ````

 Now whenever our entity {{#crossLink "Entity"}}{{/crossLink}} changes shape or position, our AABBGeometry will automatically
 update to stay fitted to it.

 We could also directly configure the AABBGeometry with the {{#crossLink "Entity"}}{{/crossLink}}'s {{#crossLink "Entity/aabb:property"}}AABB{{/crossLink}}:

 ````javascript
 var boundaryHelper2 = new xeogl.Entity({

     geometry: new xeogl.AABBGeometry({
         targetAABB: entity.aabb
     }),

     material: new xeogl.PhongMaterial({
         diffuse: [0.5, 1.0, 0.5],
         emissive: [0.5, 1.0, 0.5],
         lineWidth:2
     })
 });
 ````

 @class AABBGeometry
 @module xeogl
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this AABBGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this AABBGeometry.
 @param [cfg.target] {Component} ID or instance of a {{#crossLink "Component"}}{{/crossLink}} subtype whose AABB we'll show.
 @param [cfg.targetAABB] {Float32Array} An axis-aligned box (AABB) in a six-element Float32Array
 containing the min/max extents of the axis-aligned volume, ie. ````(xmin,ymin,zmin,xmax,ymax,zmax)````.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.AABBGeometry = xeogl.Geometry.extend({

        type: "xeogl.AABBGeometry",

        _init: function (cfg) {

            this._super(xeogl._apply(cfg, {

                // combined: true,

                primitive: cfg.primitive || "lines",
                indices: [
                    0, 1, 1, 2, 2, 3, 3, 0, 4,
                    5, 5, 6, 6, 7, 7, 4, 0, 4,
                    1, 5, 2, 6, 3, 7
                ],
                positions: cfg.positions || [
                    1.0, 1.0, 1.0,
                    1.0, -1.0, 1.0,
                    -1.0, -1.0, 1.0,
                    -1.0, 1.0, 1.0,
                    1.0, 1.0, -1.0,
                    1.0, -1.0, -1.0,
                    -1.0, -1.0, -1.0,
                    -1.0, 1.0, -1.0
                ]
            }));

            if (cfg.target) {
                this.target = cfg.target;

            } else if (cfg.targetAABB) {
                this.targetAABB = cfg.targetAABB;
            }
        },

        _props: {

            /**
             A component whose AABB we'll dynamically fit this AABBGeometry to.

             This property effectively replaces the {{#crossLink "AABBGeometry/targetAABB:property"}}{{/crossLink}} property.

             @property target
             @type Component
             */
            target: {

                set: function (value) {

                    var geometryDirty = false;
                    var self = this;

                    this._attach({
                        name: "target",
                        type: "xeogl.Component",
                        component: value,
                        sceneDefault: false,
                        on: {
                            boundary: function () {
                                if (geometryDirty) {
                                    return;
                                }
                                geometryDirty = true;
                                xeogl.scheduleTask(function () {
                                    self._setPositionsFromAABB(self._attached.target.aabb);
                                    geometryDirty = false;
                                });
                            }
                        },
                        onAttached: function () {
                            self._setPositionsFromAABB(self._attached.target.aabb);
                        }
                    });
                },

                get: function () {
                    return this._attached.target;
                }
            },

            /**
             Sets this AABBGeometry to an axis-aligned box (AABB), given as a six-element Float32Array
             containing the min/max extents of the
             axis-aligned volume, ie. ````[xmin,ymin,zmin,xmax,ymax,zmax]````.

             This property overrides the {{#crossLink "AABBGeometry/target:property"}}{{/crossLink}} property, causing it to become null.

             @property targetAABB
             @type Float32Array
             */
            targetAABB: {
                set: function (value) {
                    if (!value) {
                        return;
                    }
                    if (this._attached.target) {
                        this.target = null;
                    }
                    this._setPositionsFromAABB(value);
                }
            }
        },

        _setPositionsFromAABB: function (aabb) {
            this.positions = [
                aabb[3], aabb[4], aabb[5],
                aabb[3], aabb[1], aabb[5],
                aabb[0], aabb[1], aabb[5],
                aabb[0], aabb[4], aabb[5],
                aabb[3], aabb[4], aabb[2],
                aabb[3], aabb[1], aabb[2],
                aabb[0], aabb[1], aabb[2],
                aabb[0], aabb[4], aabb[2]
            ];
        }
    });
})();
;/**

 A **PathGeometry** is a {{#crossLink "Geometry"}}{{/crossLink}} that is defined by a {{#crossLink "Curve"}}{{/crossLink}}.

 ## Usage

 An {{#crossLink "Entity"}}{{/crossLink}} with a PathGeometry, a {{#crossLink "Path"}}{{/crossLink}} and
 a {{#crossLink "PhongMaterial"}}{{/crossLink}}:

 ````javascript
 new xeogl.Entity({

     geometry: new xeogl.PathGeometry({

        divisions: 10,

        path: new xeogl.Path({

            // Subpaths

            curves: [
                new xeogl.CubicBezierCurve({
                    v0: [-10, 0, 0],
                    v1: [-5, 15, 0],
                    v2: [20, 15, 0],
                    v3: [10, 0, 0]
                }),
                new xeogl.QuadraticBezierCurve({
                    v0: [10, 0, 0],
                    v1: [30, 15, 0],
                    v2: [20, 0, 0]
                }),
                new xeogl.SplineCurve({
                    points: [
                        [20, 0, 0],
                        [-5, 15, 0],
                        [20, 15, 0],
                        [10, 0, 0]
                    ]
                })
            ]
        })
     }),

     material: new xeogl.PhongMaterial(
        diffuse: [1,0,0]
     })
 });
 ````

 @class PathGeometry
 @module xeogl
 @submodule geometry
 @extends Geometry
 */
xeogl.PathGeometry = xeogl.Geometry.extend({

    type: "xeogl.PathGeometry",

    // Constructor

    _init: function (cfg) {

        this._super(cfg);

        this.path = cfg.path;
        this.divisions = cfg.divisions;
    },

    /**
     * Implement protected virtual template method {{#crossLink "Geometry/method:_update"}}{{/crossLink}},
     * to generate geometry data arrays.
     *
     * @protected
     */
    _update: function () {

        var path = this._attached.path;

        if (!path) {
            return;
        }

        var i;
        var len;

        var points = path.getPoints(this._divisions);

        var positions = [];
        var point;

        for (i = 0, len = points.length; i < len; i++) {

            point = points[i];

            positions.push(point[0]);
            positions.push(point[1]);
            positions.push(point[2]);
        }

        var indices = [];

        for (i = 0, len = points.length - 1; i < len; i++) {
            indices.push(i);
            indices.push(i + 1);
        }

        this.primitive = "lines";
        this.positions = positions;
        this.indices = indices;
        this.normals = null;
        this.uv = null;
    },

    _props: {

        /**
         * The Path for this PathGeometry.
         *
         * @property path
         * @type {Path}
         */
        path: {

            set: function (value) {

                this._attach({
                    name: "path",
                    type: "xeogl.Curve",
                    component: value,
                    sceneDefault: false,
                    on: {
                        curves: {
                            callback: this._needUpdate,
                            scope: this
                        }
                    }
                });
            },

            get: function () {
                return this._attached.path;
            }
        },

        /**
         * The number of segments in this PathGeometry.
         *
         * @property divisions
         * @default 6
         * @type {Number}
         */
        divisions: {

            set: function (value) {

                value = value || 6;

                this._divisions = value;

                this._needUpdate();
            },

            get: function () {
                return this._divisions;
            }
        }
    }
});;/**
 A **CylinderGeometry** is a parameterized {{#crossLink "Geometry"}}{{/crossLink}} that defines a cylinder-shaped mesh for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 <a href="../../examples/#geometry_primitives_cylinder"><img src="../../assets/images/screenshots/CylinderGeometry.png"></img></a>

 ## Examples

 * [Textured CylinderGeometry](../../examples/#geometry_primitives_cylinder)

 ## Usage

 An {{#crossLink "Entity"}}{{/crossLink}} with a CylinderGeometry and a {{#crossLink "PhongMaterial"}}{{/crossLink}} with
 diffuse {{#crossLink "Texture"}}{{/crossLink}}:

 ````javascript
 new xeogl.Entity({

     geometry: new xeogl.CylinderGeometry({
         center: [0,0,0],
         radiusTop: 2.0,
         radiusBottom: 2.0,
         height: 5.0,
         radialSegments: 20,
         heightSegments: 1,
         openEnded: false
     }),

     material: new xeogl.PhongMaterial({
        diffuseMap: new xeogl.Texture({
            src: "textures/diffuse/uvGrid2.jpg"
        })
     })
 });
 ````

 @class CylinderGeometry
 @module xeogl
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this CylinderGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CylinderGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values for a CylinderGeometry are 'points', 'lines' and 'triangles'.
 @param [cfg.center] {Float32Array} 3D point indicating the center position of the CylinderGeometry.
 @param [cfg.radiusTop=1] {Number} Radius of top.
 @param [cfg.radiusBottom=1] {Number} Radius of bottom.
 @param [cfg.height=1] {Number} Height.
 @param [cfg.radialSegments=60] {Number} Number of segments around the CylinderGeometry.
 @param [cfg.heightSegments=1] {Number} Number of vertical segments.
 @param [cfg.openEnded=false] {Boolean} Whether or not the CylinderGeometry has solid caps on the ends.
 @param [cfg.lod=1] {Number} Level-of-detail, in range [0..1].
 @extends Geometry
 */
(function () {

    "use strict";

    xeogl.CylinderGeometry = xeogl.Geometry.extend({

        type: "xeogl.CylinderGeometry",

        _init: function (cfg) {

            var radiusTop = cfg.radiusTop || 1;
            if (radiusTop < 0) {
                this.error("negative radiusTop not allowed - will invert");
                radiusTop *= -1;
            }

            var radiusBottom = cfg.radiusBottom || 1;
            if (radiusBottom < 0) {
                this.error("negative radiusBottom not allowed - will invert");
                radiusBottom *= -1;
            }

            var height = cfg.height || 1;
            if (height < 0) {
                this.error("negative height not allowed - will invert");
                height *= -1;
            }

            var radialSegments = cfg.radialSegments || 32;
            if (radialSegments < 0) {
                this.error("negative radialSegments not allowed - will invert");
                radialSegments *= -1;
            }
            if (radialSegments < 3) {
                radialSegments = 3;
            }

            var heightSegments = cfg.heightSegments || 1;
            if (heightSegments < 0) {
                this.error("negative heightSegments not allowed - will invert");
                heightSegments *= -1;
            }
            if (heightSegments < 1) {
                heightSegments = 1;
            }

            var openEnded = !!cfg.openEnded;

            var center = cfg.center;
            var centerX = center ? center[0] : 0;
            var centerY = center ? center[1] : 0;
            var centerZ = center ? center[2] : 0;

            var heightHalf = height / 2;
            var heightLength = height / heightSegments;
            var radialAngle = (2.0 * Math.PI / radialSegments);
            var radialLength = 1.0 / radialSegments;
            //var nextRadius = this._radiusBottom;
            var radiusChange = (radiusTop - radiusBottom) / heightSegments;

            var positions = [];
            var normals = [];
            var uvs = [];
            var indices = [];

            var h;
            var i;

            var x;
            var z;

            var currentRadius;
            var currentHeight;

            var first;
            var second;

            var startIndex;
            var tu;
            var tv;

            // create vertices
            var normalY = (90.0 - (Math.atan(height / (radiusBottom - radiusTop))) * 180 / Math.PI) / 90.0;

            for (h = 0; h <= heightSegments; h++) {
                currentRadius = radiusTop - h * radiusChange;
                currentHeight = heightHalf - h * heightLength;

                for (i = 0; i <= radialSegments; i++) {
                    x = Math.sin(i * radialAngle);
                    z = Math.cos(i * radialAngle);

                    normals.push(currentRadius * x);
                    normals.push(normalY); //todo
                    normals.push(currentRadius * z);

                    uvs.push((i * radialLength));
                    uvs.push(h * 1 / heightSegments);

                    positions.push((currentRadius * x) + centerX);
                    positions.push((currentHeight) + centerY);
                    positions.push((currentRadius * z) + centerZ);
                }
            }

            // create faces
            for (h = 0; h < heightSegments; h++) {
                for (i = 0; i <= radialSegments; i++) {

                    first = h * (radialSegments + 1) + i;
                    second = first + radialSegments;

                    indices.push(first);
                    indices.push(second);
                    indices.push(second + 1);

                    indices.push(first);
                    indices.push(second + 1);
                    indices.push(first + 1);
                }
            }

            // create top cap
            if (!openEnded && radiusTop > 0) {
                startIndex = (positions.length / 3);

                // top center
                normals.push(0.0);
                normals.push(1.0);
                normals.push(0.0);

                uvs.push(0.5);
                uvs.push(0.5);

                positions.push(0 + centerX);
                positions.push(heightHalf + centerY);
                positions.push(0 + centerZ);

                // top triangle fan
                for (i = 0; i <= radialSegments; i++) {
                    x = Math.sin(i * radialAngle);
                    z = Math.cos(i * radialAngle);
                    tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;
                    tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;

                    normals.push(radiusTop * x);
                    normals.push(1.0);
                    normals.push(radiusTop * z);

                    uvs.push(tu);
                    uvs.push(tv);

                    positions.push((radiusTop * x) + centerX);
                    positions.push((heightHalf) + centerY);
                    positions.push((radiusTop * z) + centerZ);
                }

                for (i = 0; i < radialSegments; i++) {
                    center = startIndex;
                    first = startIndex + 1 + i;

                    indices.push(first);
                    indices.push(first + 1);
                    indices.push(center);
                }
            }

            // create bottom cap
            if (!openEnded && radiusBottom > 0) {

                startIndex = (positions.length / 3);

                // top center
                normals.push(0.0);
                normals.push(-1.0);
                normals.push(0.0);

                uvs.push(0.5);
                uvs.push(0.5);

                positions.push(0 + centerX);
                positions.push(0 - heightHalf + centerY);
                positions.push(0 + centerZ);

                // top triangle fan
                for (i = 0; i <= radialSegments; i++) {

                    x = Math.sin(i * radialAngle);
                    z = Math.cos(i * radialAngle);

                    tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;
                    tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;

                    normals.push(radiusBottom * x);
                    normals.push(-1.0);
                    normals.push(radiusBottom * z);

                    uvs.push(tu);
                    uvs.push(tv);

                    positions.push((radiusBottom * x) + centerX);
                    positions.push((0 - heightHalf) + centerY);
                    positions.push((radiusBottom * z) + centerZ);
                }

                for (i = 0; i < radialSegments; i++) {

                    center = startIndex;
                    first = startIndex + 1 + i;

                    indices.push(center);
                    indices.push(first + 1);
                    indices.push(first);
                }
            }

            this._super(xeogl._apply(cfg, {
                positions: positions,
                normals: normals,
                uv: uvs,
                indices: indices
            }));
        }
    });

})();
;/**
 A **PlaneGeometry** is a parameterized {{#crossLink "Geometry"}}{{/crossLink}} that defines a plane-shaped mesh for attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 <a href="../../examples/#geometry_primitives_plane"><img src="../../assets/images/screenshots/PlaneGeometry.png"></img></a>

 ## Overview

 * A PlaneGeometry lies in the X-Z plane.
 * Dynamically modify it's shape at any time by updating its {{#crossLink "PlaneGeometry/center:property"}}{{/crossLink}}, {{#crossLink "PlaneGeometry/xSize:property"}}{{/crossLink}}, {{#crossLink "PlaneGeometry/zSize:property"}}{{/crossLink}}, {{#crossLink "PlaneGeometry/xSegments:property"}}{{/crossLink}} and
 {{#crossLink "PlaneGeometry/zSegments:property"}}{{/crossLink}} properties.
 * Dynamically switch its primitive type between ````"points"````, ````"lines"```` and ````"triangles"```` at any time by
 updating its {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} property.
 
 ## Examples

 * [Textured PlaneGeometry](../../examples/#geometry_primitives_plane)

 ## Usage

 An {{#crossLink "Entity"}}{{/crossLink}} with a PlaneGeometry and a {{#crossLink "PhongMaterial"}}{{/crossLink}} with
 diffuse {{#crossLink "Texture"}}{{/crossLink}}:

 ````javascript
 new xeogl.Entity({

     geometry: new xeogl.PlaneGeometry({
         primitive: "triangles",
         center: [0,0,0],
         xSize: 2,
         zSize: 2,
         xSegments: 10,
         zSegments: 10
     }),

     material: new xeogl.PhongMaterial({
        diffuseMap: new xeogl.Texture({
            src: "textures/diffuse/uvGrid2.jpg"
        })
     })
 });
 ````

 @class PlaneGeometry
 @module xeogl
 @submodule geometry
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this PlaneGeometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this PlaneGeometry.
 @param [cfg.primitive="triangles"] {String} The primitive type. Accepted values for a PlaneGeometry are 'points', 'lines' and 'triangles'.
 @param [cfg.center] {Float32Array} 3D point indicating the center position of the PlaneGeometry.
 @param [cfg.xSize=1] {Number} Dimension on the X-axis.
 @param [cfg.zSize=1] {Number} Dimension on the Z-axis.
 @param [cfg.xSegments=1] {Number} Number of segments on the X-axis.
 @param [cfg.zSegments=1] {Number} Number of segments on the Z-axis.
 @extends Geometry
 */
(function () {

    "use strict";

    xeogl.PlaneGeometry = xeogl.Geometry.extend({

        type: "xeogl.PlaneGeometry",

        _init: function (cfg) {

            var xSize = cfg.xSize || 1;
            if (xSize < 0) {
                this.error("negative xSize not allowed - will invert");
                xSize *= -1;
            }

            var zSize = cfg.zSize || 1;
            if (zSize < 0) {
                this.error("negative zSize not allowed - will invert");
                zSize *= -1;
            }

            var xSegments = cfg.xSegments || 1;
            if (xSegments < 0) {
                this.error("negative xSegments not allowed - will invert");
                xSegments *= -1;
            }
            if (xSegments < 1) {
                xSegments = 1;
            }

            var zSegments = cfg.xSegments || 1;
            if (zSegments < 0) {
                this.error("negative zSegments not allowed - will invert");
                zSegments *= -1;
            }
            if (zSegments < 1) {
                zSegments = 1;
            }

            var center = cfg.center;
            var centerX = center ? center[0] : 0;
            var centerY = center ? center[1] : 0;
            var centerZ = center ? center[2] : 0;

            var halfWidth = xSize / 2;
            var halfHeight = zSize / 2;

            var planeX = Math.floor(xSegments) || 1;
            var planeZ = Math.floor(zSegments) || 1;

            var planeX1 = planeX + 1;
            var planeZ1 = planeZ + 1;

            var segmentWidth = xSize / planeX;
            var segmentHeight = zSize / planeZ;

            var positions = new Float32Array(planeX1 * planeZ1 * 3);
            var normals = new Float32Array(planeX1 * planeZ1 * 3);
            var uvs = new Float32Array(planeX1 * planeZ1 * 2);

            var offset = 0;
            var offset2 = 0;

            var iz;
            var ix;
            var x;
            var a;
            var b;
            var c;
            var d;

            for (iz = 0; iz < planeZ1; iz++) {

                var z = iz * segmentHeight - halfHeight;

                for (ix = 0; ix < planeX1; ix++) {

                    x = ix * segmentWidth - halfWidth;

                    positions[offset] = x + centerX;
                    positions[offset + 1] = centerY;
                    positions[offset + 2] = -z + centerZ;

                    normals[offset + 2] = -1;

                    uvs[offset2] = (planeX - ix) / planeX;
                    uvs[offset2 + 1] = ( (planeZ - iz) / planeZ );

                    offset += 3;
                    offset2 += 2;
                }
            }

            offset = 0;

            var indices = new ( ( positions.length / 3 ) > 65535 ? Uint32Array : Uint16Array )(planeX * planeZ * 6);

            for (iz = 0; iz < planeZ; iz++) {

                for (ix = 0; ix < planeX; ix++) {

                    a = ix + planeX1 * iz;
                    b = ix + planeX1 * ( iz + 1 );
                    c = ( ix + 1 ) + planeX1 * ( iz + 1 );
                    d = ( ix + 1 ) + planeX1 * iz;

                    indices[offset] = d;
                    indices[offset + 1] = b;
                    indices[offset + 2] = a;

                    indices[offset + 3] = d;
                    indices[offset + 4] = c;
                    indices[offset + 5] = b;

                    offset += 6;
                }
            }

            this._super(xeogl._apply(cfg, {
                positions: positions,
                normals: normals,
                uv: uvs,
                indices: indices
            }));
        }
    });

})();
;/**
 * Components for capturing user input.
 *
 * @module xeogl
 * @submodule input
 */;/**
 Publishes keyboard and mouse events that occur on the parent {{#crossLink "Scene"}}{{/crossLink}}'s {{#crossLink "Canvas"}}{{/crossLink}}.

 * Each {{#crossLink "Scene"}}{{/crossLink}} provides an Input on itself as a read-only property.

 <img src="../../../assets/images/Input.png"></img>

 ## Usage

 In this example, we're subscribing to some mouse and key events that will occur on
 a {{#crossLink "Scene"}}Scene's{{/crossLink}} {{#crossLink "Canvas"}}Canvas{{/crossLink}}.

 ````javascript
 var myScene = new xeogl.Scene();

 var input = myScene.input;

 // We'll save a handle to this subscription
 // to show how to unsubscribe, further down
 var handle = input.on("mousedown", function(coords) {
       console.log("Mouse down at: x=" + coords[0] + ", y=" + coords[1]);
 });

 input.on("mouseup", function(coords) {
       console.log("Mouse up at: x=" + coords[0] + ", y=" + coords[1]);
 });

 input.on("mouseclicked", function(coords) {
      console.log("Mouse clicked at: x=" + coords[0] + ", y=" + coords[1]);
 });

 input.on("dblclick", function(coords) {
       console.log("Double-click at: x=" + coords[0] + ", y=" + coords[1]);
 });

 input.on("keydown", function(keyCode) {
        switch (keyCode) {

            case this.KEY_A:
               console.log("The 'A' key is down");
               break;

            case this.KEY_B:
               console.log("The 'B' key is down");
               break;

            case this.KEY_C:
               console.log("The 'C' key is down");
               break;

            default:
               console.log("Some other key is down");
       }
     });

 input.on("keyup", function(keyCode) {
        switch (keyCode) {

            case this.KEY_A:
               console.log("The 'A' key is up");
               break;

            case this.KEY_B:
               console.log("The 'B' key is up");
               break;

            case this.KEY_C:
               console.log("The 'C' key is up");
               break;

            default:
               console.log("Some other key is up");
        }
     });

 // TODO: ALT and CTRL keys etc
 ````

 ### Unsubscribing from Events

 In the snippet above, we saved a handle to one of our event subscriptions.

 We can then use that handle to unsubscribe again, like this:

 ````javascript
 input.off(handle);
 ````

 @class Input
 @module xeogl
 @submodule input
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Input = xeogl.Component.extend({

        type: "xeogl.Input",

        serializable: false,

        _init: function (cfg) {

            var self = this;

            // True when ALT down
            this.altDown = false;

            /** True whenever CTRL is down
             *
             * @type {boolean}
             */
            this.ctrlDown = false;

            /** True whenever left mouse button is down
             *
             * @type {boolean}
             */
            this.mouseDownLeft = false;

            /** True whenever middle mouse button is down
             *
             * @type {boolean}
             */
            this.mouseDownMiddle = false;

            /** True whenever right mouse button is down
             *
             * @type {boolean}
             */
            this.mouseDownRight = false;

            /** Flag for each key that's down
             *
             * @type {boolean}
             */
            this.keyDown = [];

            /** True while input enabled
             *
             * @type {boolean}
             */
            this.enabled = true;

            /** True while mouse is over the parent {{#crossLink "Scene"}}Scene's{{/crossLink}} {{#crossLink "Canvas"}}Canvas{{/crossLink}}
             *
             * @type {boolean}
             */
            this.mouseover = false;

            // Capture input events and publish them on this component

            document.addEventListener("keydown", this._keyDownListener = function (e) {

                if (!self.enabled) {
                    return;
                }

                if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {

                    if (e.ctrlKey) {
                        self.ctrlDown = true;

                    } else if (e.altKey) {
                        self.altDown = true;

                    } else {
                        self.keyDown[e.keyCode] = true;

                        /**
                         * Fired whenever a key is pressed while the parent
                         * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}} has input focus.
                         * @event keydown
                         * @param value {Number} The key code, for example {{#crossLink "Input/KEY_LEFT_ARROW:property"}}{{/crossLink}},
                         */
                        self.fire("keydown", e.keyCode, true);
                    }
                }

                if (self.mouseover) {
                    e.preventDefault();
                }

            }, true);

            document.addEventListener("keyup", this._keyUpListener = function (e) {

                if (!self.enabled) {
                    return;
                }

                if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {

                    if (e.ctrlKey) {
                        self.ctrlDown = false;

                    } else if (e.altKey) {
                        self.altDown = false;

                    } else {
                        self.keyDown[e.keyCode] = false;

                        /**
                         * Fired whenever a key is released while the parent
                         * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}} has input focus.
                         * @event keyup
                         * @param value {Number} The key code, for example {{#crossLink "Input/KEY_LEFT_ARROW:property"}}{{/crossLink}},
                         */
                        self.fire("keyup", e.keyCode, true);
                    }
                }
            });

            cfg.element.addEventListener("mouseenter", this._mouseEnterListener = function (e) {

                if (!self.enabled) {
                    return;
                }

                self.mouseover = true;

                var coords = self._getClickCoordsWithinElement(e);

                /**
                 * Fired whenever the mouse is moved into of the parent
                 * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                 * @event mouseenter
                 * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                 */
                self.fire("mouseenter", coords, true);
            });

            cfg.element.addEventListener("mouseleave", this._mouseLeaveListener = function (e) {

                if (!self.enabled) {
                    return;
                }

                self.mouseover = false;

                var coords = self._getClickCoordsWithinElement(e);

                /**
                 * Fired whenever the mouse is moved out of the parent
                 * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                 * @event mouseleave
                 * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                 */
                self.fire("mouseleave", coords, true);
            });


            cfg.element.addEventListener("mousedown", this._mouseDownListener = function (e) {

                if (!self.enabled) {
                    return;
                }

                switch (e.which) {

                    case 1:// Left button
                        self.mouseDownLeft = true;
                        break;

                    case 2:// Middle/both buttons
                        self.mouseDownMiddle = true;
                        break;

                    case 3:// Right button
                        self.mouseDownRight = true;
                        break;

                    default:
                        break;
                }

                var coords = self._getClickCoordsWithinElement(e);

                cfg.element.focus();

                /**
                 * Fired whenever the mouse is pressed over the parent
                 * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                 * @event mousedown
                 * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                 */
                self.fire("mousedown", coords, true);

                if (self.mouseover) {
                    e.preventDefault();
                }
            });

            document.addEventListener("mouseup", this._mouseUpListener = function (e) {

                if (!self.enabled) {
                    return;
                }

                switch (e.which) {

                    case 1:// Left button
                        self.mouseDownLeft = false;
                        break;

                    case 2:// Middle/both buttons
                        self.mouseDownMiddle = false;
                        break;

                    case 3:// Right button
                        self.mouseDownRight = false;
                        break;

                    default:
                        break;
                }

                var coords = self._getClickCoordsWithinElement(e);

                /**
                 * Fired whenever the mouse is released over the parent
                 * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                 * @event mouseup
                 * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                 */
                self.fire("mouseup", coords, true);

                if (self.mouseover) {
                    e.preventDefault();
                }
            }, true);

            document.addEventListener("dblclick", this._dblClickListener = function (e) {

                if (!self.enabled) {
                    return;
                }

                switch (e.which) {

                    case 1:// Left button
                        self.mouseDownLeft = false;
                        self.mouseDownRight = false;
                        break;

                    case 2:// Middle/both buttons
                        self.mouseDownMiddle = false;
                        break;

                    case 3:// Right button
                        self.mouseDownLeft = false;
                        self.mouseDownRight = false;
                        break;

                    default:
                        break;
                }

                var coords = self._getClickCoordsWithinElement(e);

                /**
                 * Fired whenever the mouse is double-clicked over the parent
                 * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                 * @event dblclick
                 * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                 */
                self.fire("dblclick", coords, true);

                if (self.mouseover) {
                    e.preventDefault();
                }
            });

            cfg.element.addEventListener("mousemove", this._mouseMoveListener = function (e) {

                if (!self.enabled) {
                    return;
                }

                var coords = self._getClickCoordsWithinElement(e);

                /**
                 * Fired whenever the mouse is moved over the parent
                 * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                 * @event mousedown
                 * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                 */
                self.fire("mousemove", coords, true);

                if (self.mouseover) {
                    e.preventDefault();
                }
            });

            cfg.element.addEventListener("wheel", this._mouseWheelListener = function (e, d) {

                if (!self.enabled) {
                    return;
                }

                var delta = Math.max(-1, Math.min(1, -e.deltaY * 40));

                /**
                 * Fired whenever the mouse wheel is moved over the parent
                 * {{#crossLink "Viewer"}}Viewer{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                 * @event mousewheel
                 * @param delta {Number} The mouse wheel delta,
                 */
                self.fire("mousewheel", delta, true);
            }, {passive: true});

            // mouseclicked

            (function () {

                var downX;
                var downY;

                // Tolerance between down and up positions for a mouse click
                var tolerance = 2;

                self.on("mousedown", function (params) {
                    downX = params[0];
                    downY = params[1];
                });

                self.on("mouseup", function (params) {

                    if (downX >= (params[0] - tolerance) &&
                        downX <= (params[0] + tolerance) &&
                        downY >= (params[1] - tolerance) &&
                        downY <= (params[1] + tolerance)) {

                        /**
                         * Fired whenever the mouse is clicked over the parent
                         * {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas{{/crossLink}}.
                         * @event mouseclicked
                         * @param value {[Number, Number]} The mouse coordinates within the {{#crossLink "Canvas"}}Canvas{{/crossLink}},
                         */
                        self.fire("mouseclicked", params, true);
                    }
                });
            })();


            // VR

            (function () {

                var orientationAngleLookup = {
                    'landscape-primary': 90,
                    'landscape-secondary': -90,
                    'portrait-secondary': 180,
                    'portrait-primary': 0
                };

                var orientation;
                var orientationAngle;
                var acceleration = xeogl.math.vec3();
                var accelerationIncludingGravity = xeogl.math.vec3();

                var orientationChangeEvent = {
                    orientation: null,
                    orientationAngle: 0
                };

                var deviceMotionEvent = {
                    orientationAngle: 0,
                    acceleration: null,
                    accelerationIncludingGravity: accelerationIncludingGravity,
                    rotationRate: xeogl.math.vec3(),
                    interval: 0
                };

                var deviceOrientationEvent = {
                    alpha: 0,
                    beta: 0,
                    gamma: 0,
                    absolute: false
                };

                if (window.OrientationChangeEvent) {
                    window.addEventListener('orientationchange', self._orientationchangedListener = function () {

                            orientation = window.screen.orientation || window.screen.mozOrientation || window.msOrientation || null;
                            orientationAngle = orientation ? (orientationAngleLookup[orientation] || 0) : 0;

                            orientationChangeEvent.orientation = orientation;
                            orientationChangeEvent.orientationAngle = orientationAngle;

                            /**
                             * Fired when the orientation of the device has changed.
                             *
                             * @event orientationchange
                             * @param orientation The orientation: "landscape-primary", "landscape-secondary", "portrait-secondary" or "portrait-primary"
                             * @param orientationAngle The orientation angle in degrees: 90 for landscape-primary, -90 for landscape-secondary, 180 for portrait-secondary or 0 for portrait-primary.
                             */
                            self.fire("orientationchange", orientationChangeEvent);
                        },
                        false);
                }

                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', self._deviceMotionListener = function (e) {

                            deviceMotionEvent.interval = e.interval;
                            deviceMotionEvent.orientationAngle = orientationAngle;

                            var accel = e.acceleration;

                            if (accel) {
                                acceleration[0] = accel.x;
                                acceleration[1] = accel.y;
                                acceleration[2] = accel.z;
                                deviceMotionEvent.acceleration = acceleration;
                            } else {
                                deviceMotionEvent.acceleration = null;
                            }

                            var accelGrav = e.accelerationIncludingGravity;

                            if (accelGrav) {
                                accelerationIncludingGravity[0] = accelGrav.x;
                                accelerationIncludingGravity[1] = accelGrav.y;
                                accelerationIncludingGravity[2] = accelGrav.z;
                                deviceMotionEvent.accelerationIncludingGravity = accelerationIncludingGravity;
                            } else {
                                deviceMotionEvent.accelerationIncludingGravity = null;
                            }

                            deviceMotionEvent.rotationRate = e.rotationRate;

                            /**
                             * Fires on a regular interval and returns data about the rotation
                             * (in degrees per second) and acceleration (in meters per second squared) of the device, at that moment in
                             * time. Some devices do not have the hardware to exclude the effect of gravity.
                             *
                             * @event devicemotion
                             * @param Float32Array acceleration The acceleration of the device, in meters per second squared, as a 3-element vector. This value has taken into account the effect of gravity and removed it from the figures. This value may not exist if the hardware doesn't know how to remove gravity from the acceleration data.
                             * @param Float32Array accelerationIncludingGravity The acceleration of the device, in meters per second squared, as a 3-element vector. This value includes the effect of gravity, and may be the only value available on devices that don't have a gyroscope to allow them to properly remove gravity from the data.
                             * @param, Number interval The interval, in milliseconds, at which this event is fired. The next event will be fired in approximately this amount of time.
                             * @param  Float32Array rotationRate The rates of rotation of the device about each axis, in degrees per second.
                             */
                            self.fire("devicemotion", deviceMotionEvent);
                        },
                        false);
                }

                if (window.DeviceOrientationEvent) {
                    window.addEventListener("deviceorientation", self._deviceOrientListener = function (e) {

                            deviceOrientationEvent.gamma = e.gamma;
                            deviceOrientationEvent.beta = e.beta;
                            deviceOrientationEvent.alpha = e.alpha;
                            deviceOrientationEvent.absolute = e.absolute;

                            /**
                             * Fired when fresh data is available from an orientation sensor about the current orientation
                             * of the device as compared to the Earth coordinate frame. This data is gathered from a
                             * magnetometer inside the device. See
                             * <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained">Orientation and motion data explained</a> for more info.
                             *
                             * @event deviceorientation
                             * @param Number alpha The current orientation of the device around the Z axis in degrees; that is, how far the device is rotated around a line perpendicular to the device.
                             * @param Number beta The current orientation of the device around the X axis in degrees; that is, how far the device is tipped forward or backward.
                             * @param Number gamma The current orientation of the device around the Y axis in degrees; that is, how far the device is turned left or right.
                             * @param Boolean absolute This value is true if the orientation is provided as a difference between the device coordinate frame and the Earth coordinate frame; if the device can't detect the Earth coordinate frame, this value is false.
                             */
                            self.fire("deviceorientation", deviceOrientationEvent);
                        },
                        false);
                }
            })();
        },

        _getClickCoordsWithinElement: function (event) {
            var coords = [0, 0];
            if (!event) {
                event = window.event;
                coords.x = event.x;
                coords.y = event.y;
            }
            else {
                var element = event.target;
                var totalOffsetLeft = 0;
                var totalOffsetTop = 0;

                while (element.offsetParent) {
                    totalOffsetLeft += element.offsetLeft;
                    totalOffsetTop += element.offsetTop;
                    element = element.offsetParent;
                }
                coords[0] = event.pageX - totalOffsetLeft;
                coords[1] = event.pageY - totalOffsetTop;
            }
            return coords;
        },

        /**
         * Enable or disable all input handlers
         *
         * @param enable
         */
        setEnabled: function (enable) {
            if (this.enabled !== enable) {
                this.fire("enabled", this.enabled = enable);
            }
        },

        // Key codes

        /**
         * Code for the BACKSPACE key.
         * @property KEY_BACKSPACE
         * @final
         * @type Number
         */
        KEY_BACKSPACE: 8,

        /**
         * Code for the TAB key.
         * @property KEY_TAB
         * @final
         * @type Number
         */
        KEY_TAB: 9,

        /**
         * Code for the ENTER key.
         * @property KEY_ENTER
         * @final
         * @type Number
         */
        KEY_ENTER: 13,

        /**
         * Code for the SHIFT key.
         * @property KEY_SHIFT
         * @final
         * @type Number
         */
        KEY_SHIFT: 16,

        /**
         * Code for the CTRL key.
         * @property KEY_CTRL
         * @final
         * @type Number
         */
        KEY_CTRL: 17,

        /**
         * Code for the ALT key.
         * @property KEY_ALT
         * @final
         * @type Number
         */
        KEY_ALT: 18,

        /**
         * Code for the PAUSE_BREAK key.
         * @property KEY_PAUSE_BREAK
         * @final
         * @type Number
         */
        KEY_PAUSE_BREAK: 19,

        /**
         * Code for the CAPS_LOCK key.
         * @property KEY_CAPS_LOCK
         * @final
         * @type Number
         */
        KEY_CAPS_LOCK: 20,

        /**
         * Code for the ESCAPE key.
         * @property KEY_ESCAPE
         * @final
         * @type Number
         */
        KEY_ESCAPE: 27,

        /**
         * Code for the PAGE_UP key.
         * @property KEY_PAGE_UP
         * @final
         * @type Number
         */
        KEY_PAGE_UP: 33,

        /**
         * Code for the PAGE_DOWN key.
         * @property KEY_PAGE_DOWN
         * @final
         * @type Number
         */
        KEY_PAGE_DOWN: 34,

        /**
         * Code for the END key.
         * @property KEY_END
         * @final
         * @type Number
         */
        KEY_END: 35,

        /**
         * Code for the HOME key.
         * @property KEY_HOME
         * @final
         * @type Number
         */
        KEY_HOME: 36,

        /**
         * Code for the LEFT_ARROW key.
         * @property KEY_LEFT_ARROW
         * @final
         * @type Number
         */
        KEY_LEFT_ARROW: 37,

        /**
         * Code for the UP_ARROW key.
         * @property KEY_UP_ARROW
         * @final
         * @type Number
         */
        KEY_UP_ARROW: 38,

        /**
         * Code for the RIGHT_ARROW key.
         * @property KEY_RIGHT_ARROW
         * @final
         * @type Number
         */
        KEY_RIGHT_ARROW: 39,

        /**
         * Code for the DOWN_ARROW key.
         * @property KEY_DOWN_ARROW
         * @final
         * @type Number
         */
        KEY_DOWN_ARROW: 40,

        /**
         * Code for the INSERT key.
         * @property KEY_INSERT
         * @final
         * @type Number
         */
        KEY_INSERT: 45,

        /**
         * Code for the DELETE key.
         * @property KEY_DELETE
         * @final
         * @type Number
         */
        KEY_DELETE: 46,

        /**
         * Code for the 0 key.
         * @property KEY_NUM_0
         * @final
         * @type Number
         */
        KEY_NUM_0: 48,

        /**
         * Code for the 1 key.
         * @property KEY_NUM_1
         * @final
         * @type Number
         */
        KEY_NUM_1: 49,

        /**
         * Code for the 2 key.
         * @property KEY_NUM_2
         * @final
         * @type Number
         */
        KEY_NUM_2: 50,

        /**
         * Code for the 3 key.
         * @property KEY_NUM_3
         * @final
         * @type Number
         */
        KEY_NUM_3: 51,

        /**
         * Code for the 4 key.
         * @property KEY_NUM_4
         * @final
         * @type Number
         */
        KEY_NUM_4: 52,

        /**
         * Code for the 5 key.
         * @property KEY_NUM_5
         * @final
         * @type Number
         */
        KEY_NUM_5: 53,

        /**
         * Code for the 6 key.
         * @property KEY_NUM_6
         * @final
         * @type Number
         */
        KEY_NUM_6: 54,

        /**
         * Code for the 7 key.
         * @property KEY_NUM_7
         * @final
         * @type Number
         */
        KEY_NUM_7: 55,

        /**
         * Code for the 8 key.
         * @property KEY_NUM_8
         * @final
         * @type Number
         */
        KEY_NUM_8: 56,

        /**
         * Code for the 9 key.
         * @property KEY_NUM_9
         * @final
         * @type Number
         */
        KEY_NUM_9: 57,

        /**
         * Code for the A key.
         * @property KEY_A
         * @final
         * @type Number
         */
        KEY_A: 65,

        /**
         * Code for the B key.
         * @property KEY_B
         * @final
         * @type Number
         */
        KEY_B: 66,

        /**
         * Code for the C key.
         * @property KEY_C
         * @final
         * @type Number
         */
        KEY_C: 67,

        /**
         * Code for the D key.
         * @property KEY_D
         * @final
         * @type Number
         */
        KEY_D: 68,

        /**
         * Code for the E key.
         * @property KEY_E
         * @final
         * @type Number
         */
        KEY_E: 69,

        /**
         * Code for the F key.
         * @property KEY_F
         * @final
         * @type Number
         */
        KEY_F: 70,

        /**
         * Code for the G key.
         * @property KEY_G
         * @final
         * @type Number
         */
        KEY_G: 71,

        /**
         * Code for the H key.
         * @property KEY_H
         * @final
         * @type Number
         */
        KEY_H: 72,

        /**
         * Code for the I key.
         * @property KEY_I
         * @final
         * @type Number
         */
        KEY_I: 73,

        /**
         * Code for the J key.
         * @property KEY_J
         * @final
         * @type Number
         */
        KEY_J: 74,

        /**
         * Code for the K key.
         * @property KEY_K
         * @final
         * @type Number
         */
        KEY_K: 75,

        /**
         * Code for the L key.
         * @property KEY_L
         * @final
         * @type Number
         */
        KEY_L: 76,

        /**
         * Code for the M key.
         * @property KEY_M
         * @final
         * @type Number
         */
        KEY_M: 77,

        /**
         * Code for the N key.
         * @property KEY_N
         * @final
         * @type Number
         */
        KEY_N: 78,

        /**
         * Code for the O key.
         * @property KEY_O
         * @final
         * @type Number
         */
        KEY_O: 79,

        /**
         * Code for the P key.
         * @property KEY_P
         * @final
         * @type Number
         */
        KEY_P: 80,

        /**
         * Code for the Q key.
         * @property KEY_Q
         * @final
         * @type Number
         */
        KEY_Q: 81,

        /**
         * Code for the R key.
         * @property KEY_R
         * @final
         * @type Number
         */
        KEY_R: 82,

        /**
         * Code for the S key.
         * @property KEY_S
         * @final
         * @type Number
         */
        KEY_S: 83,

        /**
         * Code for the T key.
         * @property KEY_T
         * @final
         * @type Number
         */
        KEY_T: 84,

        /**
         * Code for the U key.
         * @property KEY_U
         * @final
         * @type Number
         */
        KEY_U: 85,

        /**
         * Code for the V key.
         * @property KEY_V
         * @final
         * @type Number
         */
        KEY_V: 86,

        /**
         * Code for the W key.
         * @property KEY_W
         * @final
         * @type Number
         */
        KEY_W: 87,

        /**
         * Code for the X key.
         * @property KEY_X
         * @final
         * @type Number
         */
        KEY_X: 88,

        /**
         * Code for the Y key.
         * @property KEY_Y
         * @final
         * @type Number
         */
        KEY_Y: 89,

        /**
         * Code for the Z key.
         * @property KEY_Z
         * @final
         * @type Number
         */
        KEY_Z: 90,

        /**
         * Code for the LEFT_WINDOW key.
         * @property KEY_LEFT_WINDOW
         * @final
         * @type Number
         */
        KEY_LEFT_WINDOW: 91,

        /**
         * Code for the RIGHT_WINDOW key.
         * @property KEY_RIGHT_WINDOW
         * @final
         * @type Number
         */
        KEY_RIGHT_WINDOW: 92,

        /**
         * Code for the SELECT key.
         * @property KEY_SELECT
         * @final
         * @type Number
         */
        KEY_SELECT_KEY: 93,

        /**
         * Code for the number pad 0 key.
         * @property KEY_NUMPAD_0
         * @final
         * @type Number
         */
        KEY_NUMPAD_0: 96,

        /**
         * Code for the number pad 1 key.
         * @property KEY_NUMPAD_1
         * @final
         * @type Number
         */
        KEY_NUMPAD_1: 97,

        /**
         * Code for the number pad 2 key.
         * @property KEY_NUMPAD 2
         * @final
         * @type Number
         */
        KEY_NUMPAD_2: 98,

        /**
         * Code for the number pad 3 key.
         * @property KEY_NUMPAD_3
         * @final
         * @type Number
         */
        KEY_NUMPAD_3: 99,

        /**
         * Code for the number pad 4 key.
         * @property KEY_NUMPAD_4
         * @final
         * @type Number
         */
        KEY_NUMPAD_4: 100,

        /**
         * Code for the number pad 5 key.
         * @property KEY_NUMPAD_5
         * @final
         * @type Number
         */
        KEY_NUMPAD_5: 101,

        /**
         * Code for the number pad 6 key.
         * @property KEY_NUMPAD_6
         * @final
         * @type Number
         */
        KEY_NUMPAD_6: 102,

        /**
         * Code for the number pad 7 key.
         * @property KEY_NUMPAD_7
         * @final
         * @type Number
         */
        KEY_NUMPAD_7: 103,

        /**
         * Code for the number pad 8 key.
         * @property KEY_NUMPAD_8
         * @final
         * @type Number
         */
        KEY_NUMPAD_8: 104,

        /**
         * Code for the number pad 9 key.
         * @property KEY_NUMPAD_9
         * @final
         * @type Number
         */
        KEY_NUMPAD_9: 105,

        /**
         * Code for the MULTIPLY key.
         * @property KEY_MULTIPLY
         * @final
         * @type Number
         */
        KEY_MULTIPLY: 106,

        /**
         * Code for the ADD key.
         * @property KEY_ADD
         * @final
         * @type Number
         */
        KEY_ADD: 107,

        /**
         * Code for the SUBTRACT key.
         * @property KEY_SUBTRACT
         * @final
         * @type Number
         */
        KEY_SUBTRACT: 109,

        /**
         * Code for the DECIMAL POINT key.
         * @property KEY_DECIMAL_POINT
         * @final
         * @type Number
         */
        KEY_DECIMAL_POINT: 110,

        /**
         * Code for the DIVIDE key.
         * @property KEY_DIVIDE
         * @final
         * @type Number
         */
        KEY_DIVIDE: 111,

        /**
         * Code for the F1 key.
         * @property KEY_F1
         * @final
         * @type Number
         */
        KEY_F1: 112,

        /**
         * Code for the F2 key.
         * @property KEY_F2
         * @final
         * @type Number
         */
        KEY_F2: 113,

        /**
         * Code for the F3 key.
         * @property KEY_F3
         * @final
         * @type Number
         */
        KEY_F3: 114,

        /**
         * Code for the F4 key.
         * @property KEY_F4
         * @final
         * @type Number
         */
        KEY_F4: 115,

        /**
         * Code for the F5 key.
         * @property KEY_F5
         * @final
         * @type Number
         */
        KEY_F5: 116,

        /**
         * Code for the F6 key.
         * @property KEY_F6
         * @final
         * @type Number
         */
        KEY_F6: 117,

        /**
         * Code for the F7 key.
         * @property KEY_F7
         * @final
         * @type Number
         */
        KEY_F7: 118,

        /**
         * Code for the F8 key.
         * @property KEY_F8
         * @final
         * @type Number
         */
        KEY_F8: 119,

        /**
         * Code for the F9 key.
         * @property KEY_F9
         * @final
         * @type Number
         */
        KEY_F9: 120,

        /**
         * Code for the F10 key.
         * @property KEY_F10
         * @final
         * @type Number
         */
        KEY_F10: 121,

        /**
         * Code for the F11 key.
         * @property KEY_F11
         * @final
         * @type Number
         */
        KEY_F11: 122,

        /**
         * Code for the F12 key.
         * @property KEY_F12
         * @final
         * @type Number
         */
        KEY_F12: 123,

        /**
         * Code for the NUM_LOCK key.
         * @property KEY_NUM_LOCK
         * @final
         * @type Number
         */
        KEY_NUM_LOCK: 144,

        /**
         * Code for the SCROLL_LOCK key.
         * @property KEY_SCROLL_LOCK
         * @final
         * @type Number
         */
        KEY_SCROLL_LOCK: 145,

        /**
         * Code for the SEMI_COLON key.
         * @property KEY_SEMI_COLON
         * @final
         * @type Number
         */
        KEY_SEMI_COLON: 186,

        /**
         * Code for the EQUAL_SIGN key.
         * @property KEY_EQUAL_SIGN
         * @final
         * @type Number
         */
        KEY_EQUAL_SIGN: 187,

        /**
         * Code for the COMMA key.
         * @property KEY_COMMA
         * @final
         * @type Number
         */
        KEY_COMMA: 188,

        /**
         * Code for the DASH key.
         * @property KEY_DASH
         * @final
         * @type Number
         */
        KEY_DASH: 189,

        /**
         * Code for the PERIOD key.
         * @property KEY_PERIOD
         * @final
         * @type Number
         */
        KEY_PERIOD: 190,

        /**
         * Code for the FORWARD_SLASH key.
         * @property KEY_FORWARD_SLASH
         * @final
         * @type Number
         */
        KEY_FORWARD_SLASH: 191,

        /**
         * Code for the GRAVE_ACCENT key.
         * @property KEY_GRAVE_ACCENT
         * @final
         * @type Number
         */
        KEY_GRAVE_ACCENT: 192,

        /**
         * Code for the OPEN_BRACKET key.
         * @property KEY_OPEN_BRACKET
         * @final
         * @type Number
         */
        KEY_OPEN_BRACKET: 219,

        /**
         * Code for the BACK_SLASH key.
         * @property KEY_BACK_SLASH
         * @final
         * @type Number
         */
        KEY_BACK_SLASH: 220,

        /**
         * Code for the CLOSE_BRACKET key.
         * @property KEY_CLOSE_BRACKET
         * @final
         * @type Number
         */
        KEY_CLOSE_BRACKET: 221,

        /**
         * Code for the SINGLE_QUOTE key.
         * @property KEY_SINGLE_QUOTE
         * @final
         * @type Number
         */
        KEY_SINGLE_QUOTE: 222,

        /**
         * Code for the SPACE key.
         * @property KEY_SPACE
         * @final
         * @type Number
         */
        KEY_SPACE: 32,


        _destroy: function () {
            document.removeEventListener("keydown", this._keyDownListener);
            document.removeEventListener("keyup", this._keyUpListener);
        }
    });

})();
;/**
 * Components for defining light sources.
 *
 * @module xeogl
 * @submodule lighting
 */;/**
 A **Lights** defines a group of light sources within a {{#crossLink "Scene"}}{{/crossLink}}.

 ## Overview

 A Lights may contain a virtually unlimited number of three types of light source:

 * {{#crossLink "AmbientLight"}}AmbientLight{{/crossLink}}s, which are fixed-intensity and fixed-color, and
 affect all the Scene's {{#crossLink "Entity"}}Entities{{/crossLink}} equally,
 * {{#crossLink "PointLight"}}PointLight{{/crossLink}}s, which emit light that
 originates from a single point and spreads outward in all directions,
 * {{#crossLink "DirLight"}}DirLight{{/crossLink}}s, which illuminate all the
 Entities equally from a given direction and may cast shadows, and
 * {{#crossLink "SpotLight"}}SpotLight{{/crossLink}}s, which eminate from a position in a given direction and may also cast shadows.

 A Lights can also have two other components that define environmental reflection and irradiance:

 * {{#crossLink "Lights/lightMap:property"}}{{/crossLink}} set to a {{#crossLink "CubeTexture"}}{{/crossLink}}, and
 * {{#crossLink "Lights/reflectionMap:property"}}{{/crossLink}} set to a {{#crossLink "CubeTexture"}}{{/crossLink}}.

 ## Examples

 * [Light and reflection maps](../../examples/#materials_metallic_fireHydrant)
 * [World-space point lighting with normal map](../../examples/#lights_point_world_normalMap)
 * [View-space directional three-point lighting](../../examples/#lights_directional_view_threePoint)
 * [View-space positional three-point lighting](../../examples/#lights_point_world_threePoint)
 * [World-space directional three-point lighting](../../examples/#lights_directional_world_threePoint)
 * [World-space positional three-point lighting](../../examples/#lights_point_world_threePoint)

 ## Usage

 In the example below we'll customize the default Scene's light sources, then create a metallic sphere entity.

 ````javascript

 // We're using the default xeogl Scene
 // Get Scene's Lights
 var lights = xeogl.scene.lights;

 // Customize the light sources
 lights.lights = [
    new xeogl.DirLight({
        dir: [0.8, -0.6, -0.8],
        color: [0.8, 0.8, 0.8],
        space: "view"
    }),
    new xeogl.DirLight({
        dir: [-0.8, -0.4, -0.4],
        color: [0.4, 0.4, 0.5],
        space: "view"
    }),
    new xeogl.DirLight({
        dir: [0.2, -0.8, 0.8],
        color: [0.8, 0.8, 0.8],
        space: "view"
    })
 ];

 // Add a light cube map
 lights.lightMap = new xeogl.CubeTexture({
    src: [
        "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PX.png",
        "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NX.png",
        "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PY.png",
        "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NY.png",
        "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PZ.png",
        "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NZ.png"
    ]
 });

 // Add a reflection cube map
 lights.reflectionMap = new xeogl.CubeTexture({
    src: [
        "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PX.png",
        "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NX.png",
        "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PY.png",
        "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NY.png",
        "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PZ.png",
        "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NZ.png"
    ]
 });

 // Create a metallic sphere entity
 new xeogl.Entity({
    material: new xeogl.MetallicMaterial({
        roughness: 1.0,
        metallic: 1.0,
        baseColorMap: new xeogl.Texture({
            src: "textures/materials/poligon/RustMixedOnPaint012_1k/RustMixedOnPaint012_COL_VAR1_1K.jpg"
        }),
        roughnessMap: new xeogl.Texture({
            src: "textures/materials/poligon/RustMixedOnPaint012_1k/RustMixedOnPaint012_REFL_1K.jpg"
        })
    }),
    geometry: new xeogl.SphereGeometry()
 });
 ````

 @class Lights
 @constructor
 @module xeogl
 @submodule lighting
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Lights in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Lights.
 @param [cfg.lights] {Array of String|Entity} Array of light source IDs or instances.
 @param [cfg.lightMap=undefined] {CubeTexture} A light map {{#crossLink "CubeTexture"}}{{/crossLink}}. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Lights.
 @param [cfg.reflectionMap=undefined] {CubeTexture} A reflection map {{#crossLink "CubeTexture"}}{{/crossLink}}. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Lights.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Lights = xeogl.Component.extend({

        type: "xeogl.Lights",

        _init: function (cfg) {

            // Renderer state contains the states of the child light source components
            this._state = new xeogl.renderer.Lights({
                lights: [],
                hash: ""
            });

            // Array of child light source components
            this._lights = [];

            // Subscriptions to "dirty" events from child light source components
            this._dirtySubs = [];

            // Subscriptions to "destroyed" events from child light source components
            this._destroyedSubs = [];

            // Add initial light source components
            if (cfg.lights) {
                this.lights = cfg.lights;
            }

            if (cfg.lightMap) {
                this.lightMap = cfg.lightMap;
            }

            if (cfg.reflectionMap) {
                this.reflectionMap = cfg.reflectionMap;
            }
        },

        _props: {

            /**
             * The light sources in this Lights.
             *
             * Note that when removing or inserting light sources, you must reassign this property to the modified array,
             * so that this Lights able to detect that lights sources were actually added or removed. For example:
             *
             * ````javascript
             * var lights = myLights.lights;
             * lights.push(new xeogl.PointLight({...}));
             * myLights.lights = lights; // This way, the xeogl.Lights component is able to detect that the new light was added.
             * ````
             *
             * We'll be able to relax this once JavaScript gets the (proper) ability to observe array updates.
             *
             * Fires a {{#crossLink "Lights/lights:event"}}{{/crossLink}} event on change.
             *
             * @property lights
             * @default []
             * @type {{Array of AmbientLight, PointLight, DirLight or SpotLight}}
             */
            lights: {

                set: function (value) {

                    value = value || [];

                    var light;
                    var i;
                    var len;

                    // Unsubscribe from events on old lights

                    for (i = 0, len = this._lights.length; i < len; i++) {

                        light = this._lights[i];

                        light.off(this._dirtySubs[i]);
                        light.off(this._destroyedSubs[i]);
                    }

                    this._lights = [];

                    this._dirtySubs = [];
                    this._destroyedSubs = [];

                    var self = this;

                    function lightDirty() {
                        self.fire("dirty", true);
                    }

                    function lightDestroyed() { // TODO: Cache this callback

                        var id = this.id; // Light ID

                        for (var i = 0, len = self._lights.length; i < len; i++) {

                            if (self._lights[i].id === id) {

                                self._lights = self._lights.slice(i, i + 1);
                                self._dirtySubs = self._dirtySubs.slice(i, i + 1);
                                self._destroyedSubs = self._destroyedSubs.slice(i, i + 1);

                                self.fire("dirty", true);
                                self.fire("lights", self._lights);

                                return;
                            }
                        }
                    }

                    for (i = 0, len = value.length; i < len; i++) {

                        light = value[i];

                        if (xeogl._isNumeric(light) || xeogl._isString(light)) {

                            // ID given for light - find the light component

                            var id = light;

                            light = this.scene.components[id];

                            if (!light) {
                                this.error("Component not found: " + xeogl._inQuotes(id));
                                continue;
                            }
                        }

                        var type = light.type;

                        if (type !== "xeogl.AmbientLight" && type !== "xeogl.DirLight" && type !== "xeogl.PointLight" && type !== "xeogl.SpotLight") {
                            this.error("Component " + xeogl._inQuotes(light.id) + " is not an xeogl.AmbientLight, xeogl.DirLight, xeogl.PointLight or xeogl.SpotLight");
                            continue;
                        }

                        this._lights.push(light);

                        this._dirtySubs.push(light.on("dirty", lightDirty));

                        this._destroyedSubs.push(light.on("destroyed", lightDestroyed));
                    }

                    this.fire("dirty", true);

                    this._renderer.setImageForceDirty(); // Triggers a re-render (to clear) even if there are no entities

                    /**
                     Fired whenever this Lights's {{#crossLink "Lights/lights:property"}}{{/crossLink}} property changes.

                     @event lights
                     @param value Number The property's new value
                     */
                    this.fire("lights", this._lights);
                },

                get: function () {
                    return this._lights;
                }
            },

            /**
             A {{#crossLink "CubeTexture"}}{{/crossLink}} that defines the brightness of the
             surfaces of attached {{#crossLink "Entities"}}{{/crossLink}}.

             Must be within the same {{#crossLink "Scene"}}{{/crossLink}} as this Lights.

             Fires a {{#crossLink "Lights/lightMap:event"}}{{/crossLink}} event on change.

             @property lightMap
             @default undefined
             @type {CubeTexture}
             */
            lightMap: {

                set: function (texture) {

                    /**
                     Fired whenever this Lights's {{#crossLink "Lights/lightMap:property"}}{{/crossLink}} property changes.

                     @event lightMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.CubeTexture", "lightMap", texture);
                },

                get: function () {
                    return this._attached.lightMap;
                }
            },

            /**
             A {{#crossLink "CubeTexture"}}{{/crossLink}} that defines a background image that is reflected in the
             surfaces of attached {{#crossLink "Entities"}}{{/crossLink}}.

             Must be within the same {{#crossLink "Scene"}}{{/crossLink}} as this Lights.

             Fires a {{#crossLink "Lights/reflectionMap:event"}}{{/crossLink}} event on change.

             @property reflectionMap
             @default undefined
             @type {CubeTexture}
             */
            reflectionMap: {

                set: function (texture) {

                    /**
                     Fired whenever this Lights's {{#crossLink "Lights/reflectionMap:property"}}{{/crossLink}} property changes.

                     @event reflectionMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.CubeTexture", "reflectionMap", texture);
                },

                get: function () {
                    return this._attached.reflectionMap;
                }
            }
        },

        _attachComponent: function (expectedType, name, component) {
            component = this._attach({
                name: name,
                type: expectedType,
                component: component,
                sceneDefault: false,
                on: {
                    destroyed: {
                        callback: function () {
                            this._state[name] = null;
                            this._hashDirty = true;
                        },
                        scope: this
                    }
                }
            });
            this._state[name] = component ? component._state : undefined; // FIXME: Accessing _state breaks encapsulation
            this._hashDirty = true;
        },

        _shadowsDirty: function () {
            var light;
            for (var i = 0, len = this._lights.length; i < len; i++) {
                light = this._lights[i]._state;
                if (light.shadow) {
                    light.shadowDirty = true;
                }
            }
        },

        _getState: function () {
            var state = this._state;
            state.lights = [];
            for (var i = 0, len = this._lights.length; i < len; i++) {
                state.lights.push(this._lights[i]._state);
            }
            this._makeHash();
            return state;
        },

        _makeHash: function () {

            var hash = [];

            var state = this._state;

            var lights = state.lights;

            var light;

            for (var i = 0, len = lights.length; i < len; i++) {
                light = lights[i];
                hash.push("/");
                hash.push(light.type);
                hash.push((light.space === "world") ? "w" : "v");
                if (light.shadow) {
                    hash.push("sh");
                }
            }

            if (state.lightMap) {
                hash.push("/lm");
            }

            if (state.reflectionMap) {
                hash.push("/rm");
            }

            hash.push(";");

            this._state.hash = hash.join("");
        },

        _destroy: function () {

            var i;
            var len;
            var light;

            for (i = 0, len = this._lights.length; i < len; i++) {

                light = this._lights[i];

                light.off(this._dirtySubs[i]);
                light.off(this._destroyedSubs[i]);
            }

            this._state.destroy();
        }
    });
})();
;/**
 An **AmbientLight** defines an ambient light source of fixed intensity and color that affects all {{#crossLink "Entity"}}Entities{{/crossLink}}
 equally.

 <a href="../../examples/#lights_ambient"><img src="http://i.giphy.com/l0HlGTxXQWMRVOPwk.gif"></img></a>

 ## Overview

 * AmbientLights are grouped, along with other light source types, within a {{#crossLink "Lights"}}Lights{{/crossLink}} component,
 which belongs to a {{#crossLink "Scene"}}{{/crossLink}}.
 * When the {{#crossLink "Entity"}}Entities{{/crossLink}} have {{#crossLink "PhongMaterial"}}PhongMaterials{{/crossLink}},
 AmbientLight {{#crossLink "AmbientLight/color:property"}}color{{/crossLink}} is multiplied by
 PhongMaterial {{#crossLink "PhongMaterial/ambient:property"}}{{/crossLink}} at each rendered fragment of the {{#crossLink "Geometry"}}{{/crossLink}} surface.
 * When the Entities have {{#crossLink "LambertMaterial"}}LambertMaterials{{/crossLink}},
 AmbientLight {{#crossLink "AmbientLight/color:property"}}color{{/crossLink}} is multiplied by
 LambertMaterial {{#crossLink "LambertMaterial/ambient:property"}}{{/crossLink}} for each rendered triangle of the Geometry surface (ie. flat shaded).

 ## Examples

 * [Ambient light source](../../examples/#lights_ambient)

 ## Usage

 In the example below we'll customize the default Scene's light sources, defining an AmbientLight and a couple of
 DirLights, then create a Phong-shaded box entity.

 ````javascript

 // We're using the default xeogl Scene
 // Get Scene's Lights
 var lights = xeogl.scene.lights;

 // Customize the light sources
 lights.lights = [
    new xeogl.AmbientLight({
        color: [0.8, 0.8, 0.8],
        intensity: 0.5
    }),
    new xeogl.DirLight({
        dir: [-0.8, -0.4, -0.4],
        color: [0.4, 0.4, 0.5],
        intensity: 0.5,
        space: "view"
    }),
    new xeogl.DirLight({
        dir: [0.2, -0.8, 0.8],
        color: [0.8, 0.8, 0.8],
        intensity: 0.5,
        space: "view"
    })
 ];

 // Create box entity
 new xeogl.Entity({
    material: new xeogl.PhongMaterial({
        ambient: [0.5, 0.5, 0.5],
        diffuse: [1,0.3,0.3]
    }),
    geometry: new xeogl.BoxGeometry()
 });
 ````

 @class AmbientLight
 @module xeogl
 @submodule lighting
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this AmbientLight within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} AmbientLight configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this AmbientLight.
 @param [cfg.color=[0.7, 0.7, 0.8]] {Array(Number)} The color of this AmbientLight.
 @param [cfg.intensity=[1.0]] {Number} The intensity of this AmbientLight, as a factor in range ````[0..1]````.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.AmbientLight = xeogl.Component.extend({

        type: "xeogl.AmbientLight",

        _init: function (cfg) {

            this._state = {
                type: "ambient",
                color: xeogl.math.vec3([0.7, 0.7, 0.7]),
                intensity: 1.0
            };

            this.color = cfg.color;
            this.intensity = cfg.intensity;
        },

        _props: {

            /**
             The color of this AmbientLight.

             Fires an {{#crossLink "AmbientLight/color:event"}}{{/crossLink}} event on change.

             @property color
             @default [0.7, 0.7, 0.8]
             @type Float32Array
             */
            color: {

                set: function (value) {

                    this._state.color.set(value ||  [ 0.7, 0.7, 0.8 ]);

                    this._renderer.setImageForceDirty();

                    /**
                     Fired whenever this AmbientLight's {{#crossLink "AmbientLight/color:property"}}{{/crossLink}} property changes.

                     @event color
                     @param value The property's new value
                     */
                    this.fire("color", this._state.color);
                },

                get: function () {
                    return this._state.color;
                }
            },

            /**
             The intensity of this AmbientLight.

             Fires a {{#crossLink "AmbientLight/intensity:event"}}{{/crossLink}} event on change.

             @property intensity
             @default 1.0
             @type Number
             */
            intensity: {

                set: function (value) {

                    this._state.intensity = value !== undefined ? value :  1.0;

                    this._renderer.setImageForceDirty();

                    /**
                     * Fired whenever this AmbientLight's  {{#crossLink "AmbientLight/intensity:property"}}{{/crossLink}} property changes.
                     * @event intensity
                     * @param value The property's new value
                     */
                    this.fire("intensity", this._state.intensity);
                },

                get: function () {
                    return this._state.intensity;
                }
            }
        }
    });

})();
;/**
 A **DirLight** is a directional light source that illuminates all {{#crossLink "Entity"}}Entities{{/crossLink}} equally
 from a given direction.

 ## Overview

 * DirLights are grouped, along with other light source types, within a {{#crossLink "Lights"}}Lights{{/crossLink}} component,
 which belongs to a {{#crossLink "Scene"}}{{/crossLink}}.
 * DirLights have a direction, but no position.
 * The direction is the **direction that the light is emitted in**.
 * DirLights may be defined in either **World** or **View** coordinate space. When in World-space, their direction
 is relative to the World coordinate system, and will appear to move as the {{#crossLink "Camera"}}{{/crossLink}} moves.
 When in View-space, their direction is relative to the View coordinate system, and will behave as if fixed to the viewer's
 head as the {{#crossLink "Camera"}}{{/crossLink}} moves.
 * A DirLight can also have a {{#crossLink "Shadow"}}{{/crossLink}} component, to configure it to cast a shadow.

 ## Examples

 * [View-space directional three-point lighting](../../examples/#lights_directional_view_threePoint)
 * [World-space directional three-point lighting](../../examples/#lights_directional_world_threePoint)

 ## Usage

 In the example below we'll customize the default Scene's light sources, defining an AmbientLight and a couple of
 DirLights, then create a Phong-shaded box entity.

 ````javascript

 // We're using the default xeogl Scene
 // Get Scene's Lights
 var lights = xeogl.scene.lights;

 // Customize the light sources
 lights.lights = [
 new xeogl.AmbientLight({
        color: [0.8, 0.8, 0.8],
        intensity: 0.5
     }),
 new xeogl.DirLight({
        dir: [1, 1, 1],     // Direction the light is shining in
        color: [0.5, 0.7, 0.5],
        intensity: 1.0,
        space: "view",      // Other option is "world", for World-space
        shadow: false       // Default
     }),
 new xeogl.DirLight({
        dir: [0.2, -0.8, 0.8],
        color: [0.8, 0.8, 0.8],
        intensity: 0.5,
        space: "view",
        shadow: false
     })
 ];

 // Create box entity
 new xeogl.Entity({
    material: new xeogl.PhongMaterial({
        ambient: [0.5, 0.5, 0.5],
        diffuse: [1,0.3,0.3]
    }),
    geometry: new xeogl.BoxGeometry()
 });
 ````

 @class DirLight
 @module xeogl
 @submodule lighting
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this DirLight within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The DirLight configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this DirLight.
 @param [cfg.dir=[1.0, 1.0, 1.0]] {Float32Array} A unit vector indicating the direction that the light is shining,
 given in either World or View space, depending on the value of the **space** parameter.
 @param [cfg.color=[0.7, 0.7, 0.8 ]] {Float32Array} The color of this DirLight.
 @param [cfg.intensity=1.0 ] {Number} The intensity of this DirLight, as a factor in range ````[0..1]````.
 @param [cfg.space="view"] {String} The coordinate system the DirLight is defined in - "view" or "space".
 @param [cfg.shadow=false] {Boolean} Flag which indicates if this DirLight casts a shadow.
 @extends Component
 */
(function () {

    "use strict";

    var math = xeogl.math;

    xeogl.DirLight = xeogl.Component.extend({

        type: "xeogl.DirLight",

        _init: function (cfg) {

            var self = this;

            this._shadowRenderBuf = null;
            this._shadowViewMatrix = null;
            this._shadowProjMatrix = null;
            this._shadowViewMatrixDirty = true;
            this._shadowProjMatrixDirty = true;

            this._state = new xeogl.renderer.Light({
                type: "dir",
                dir: xeogl.math.vec3([1.0, 1.0, 1.0]),
                color: xeogl.math.vec3([0.7, 0.7, 0.8]),
                intensity: 1.0,
                space: "view",
                shadow: false,
                shadowDirty: true,

                getShadowViewMatrix: (function () {
                    var look = math.vec3();
                    var up = math.vec3([0, 1, 0]);
                    return function () {
                        if (self._shadowViewMatrixDirty) {
                            if (!self._shadowViewMatrix) {
                                self._shadowViewMatrix = math.identityMat4();
                            }
                            var dir = self._state.dir;
                            math.lookAtMat4v([-dir[0], -dir[1], -dir[2]], [0, 0, 0], up, self._shadowViewMatrix);
                            self._shadowViewMatrixDirty = false;
                        }
                        return self._shadowViewMatrix;
                    };
                })(),

                getShadowProjMatrix: function () {
                    if (self._shadowProjMatrixDirty) { // TODO: Set when canvas resizes
                        if (!self._shadowProjMatrix) {
                            self._shadowProjMatrix = math.identityMat4();
                        }
                        xeogl.math.orthoMat4c(-10, 10, -10, 10, 0, 1000.0, self._shadowProjMatrix);
                        self._shadowProjMatrixDirty = false;
                    }
                    return self._shadowProjMatrix;
                },

                getShadowRenderBuf: function () {
                    if (!self._shadowRenderBuf) {
                        self._shadowRenderBuf = new xeogl.renderer.RenderBuffer(self.scene.canvas.canvas, self.scene.canvas.gl);
                    }
                    return self._shadowRenderBuf;
                }
            });

            this.dir = cfg.dir;
            this.color = cfg.color;
            this.intensity = cfg.intensity;
            this.space = cfg.space;
            this.shadow = cfg.shadow;
        },

        _props: {

            /**
             The direction in which the light is shining.

             Fires a {{#crossLink "DirLight/dir:event"}}{{/crossLink}} event on change.

             @property dir
             @default [1.0, 1.0, 1.0]
             @type Float32Array
             */
            dir: {

                set: function (value) {

                    this._state.dir.set(value || [1.0, 1.0, 1.0]);

                    this._shadowViewMatrixDirty = true;

                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this DirLight's  {{#crossLink "DirLight/dir:property"}}{{/crossLink}} property changes.
                     * @event dir
                     * @param value The property's new value
                     */
                    this.fire("dir", this._state.dir);
                },

                get: function () {
                    return this._state.dir;
                }
            },

            /**
             The color of this DirLight.

             Fires a {{#crossLink "DirLight/color:event"}}{{/crossLink}} event on change.

             @property color
             @default [0.7, 0.7, 0.8]
             @type Float32Array
             */
            color: {

                set: function (value) {

                    this._state.color.set(value || [0.7, 0.7, 0.8]);

                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this DirLight's  {{#crossLink "DirLight/color:property"}}{{/crossLink}} property changes.
                     * @event color
                     * @param value The property's new value
                     */
                    this.fire("color", this._state.color);
                },

                get: function () {
                    return this._state.color;
                }
            },

            /**
             The intensity of this DirLight.

             Fires a {{#crossLink "DirLight/intensity:event"}}{{/crossLink}} event on change.

             @property intensity
             @default 1.0
             @type Number
             */
            intensity: {

                set: function (value) {

                    value = value !== undefined ? value : 1.0;

                    this._state.intensity = value;

                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this DirLight's  {{#crossLink "DirLight/intensity:property"}}{{/crossLink}} property changes.
                     * @event intensity
                     * @param value The property's new value
                     */
                    this.fire("intensity", this._state.intensity);
                },

                get: function () {
                    return this._state.intensity;
                }
            },

            /**
             Specifies which coordinate space this DirLight is in.

             Supported values are:


             * "view" - View space, aligned within the view volume as if fixed to the viewer's head
             * "world" - World space, fixed within the world, moving within the view volume with respect to camera

             Fires a {{#crossLink "DirLight/space:event"}}{{/crossLink}} event on change.

             @property space
             @default "view"
             @type String
             */
            space: {

                set: function (value) {

                    this._state.space = value || "view";

                    this.fire("dirty", true); // Need to rebuild shader

                    /**
                     * Fired whenever this DirLight's {{#crossLink "DirLight/space:property"}}{{/crossLink}} property changes.
                     * @event space
                     * @param value The property's new value
                     */
                    this.fire("space", this._state.space);
                },

                get: function () {
                    return this._state.space;
                }
            },

            /**
             Flag which indicates if this DirLight casts a shadow.

             Fires a {{#crossLink "DirLight/shadow:event"}}{{/crossLink}} event on change.

             @property shadow
             @default false
             @type Boolean
             */
            shadow: {

                set: function (value) {

                    value = !!value;

                    if (this._state.shadow === value) {
                        return;
                    }

                    this._state.shadow = value;

                    this._shadowViewMatrixDirty = true;

                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this DirLight's {{#crossLink "DirLight/shadow:property"}}{{/crossLink}} property changes.
                     * @event shadow
                     * @param value The property's new value
                     */
                    this.fire("shadow", this._state.shadow);

                    this.fire("dirty", true);
                },

                get: function () {
                    return this._state.shadow;
                }
            }
        },

        _destroy: function () {
            if (this._shadowRenderBuf) {
                this._shadowRenderBuf.destroy();
            }
        }
    });

})();
;/**
 A **PointLight** defines a positional light source that originates from a single point and spreads outward in all directions,
 to illuminate {{#crossLink "Entity"}}Entities{{/crossLink}}.

 <a href="../../examples/#lights_point_world_normalMap"><img src="http://i.giphy.com/3o6ZsZoFGIOJ2nlmN2.gif"></img></a>

 ## Overview

 * PointLights are grouped, along with other light source types, within a {{#crossLink "Lights"}}Lights{{/crossLink}} component,
 which belongs to a {{#crossLink "Scene"}}{{/crossLink}}.
 * PointLights have a position, but no direction.
 * PointLights may be defined in either **World** or **View** coordinate space. When in World-space, their positions
 are relative to the World coordinate system, and will appear to move as the {{#crossLink "Camera"}}{{/crossLink}} moves.
 When in View-space, their positions are relative to the View coordinate system, and will behave as if fixed to the viewer's
 head as the {{#crossLink "Camera"}}{{/crossLink}} moves.
 * PointLights have {{#crossLink "PointLight/constantAttenuation:property"}}{{/crossLink}}, {{#crossLink "PointLight/linearAttenuation:property"}}{{/crossLink}} and
 {{#crossLink "PointLight/quadraticAttenuation:property"}}{{/crossLink}} factors, which indicate how their intensity attenuates over distance.

 ## Examples

 * [View-space positional three-point lighting](../../examples/#lights_point_view_threePoint)
 * [World-space positional three-point lighting](../../examples/#lights_point_world_threePoint)
 * [World-space point light and normal map](../../examples/#lights_point_world_normalMap)

 ## Usage

 In the example below we'll customize the default Scene's light sources, defining an AmbientLight and a couple of
 PointLights, then create a Phong-shaded box entity.

 ````javascript

 // We're using the default xeogl Scene
 // Get Scene's Lights
 var lights = xeogl.scene.lights;

 // Customize the light sources
 lights.lights = [
    new xeogl.AmbientLight({
        color: [0.8, 0.8, 0.8],
        intensity: 0.5
    }),
    new xeogl.PointLight({
        pos: [-100, 0, 100],
        color: [0.3, 0.3, 0.5],
        intensity: .7
        constantAttenuation: 0,
        linearAttenuation: 0,
        quadraticAttenuation: 0,
        space: "view"
    }),
    new xeogl.PointLight({
        pos: [0, 100, 100],
        color: [0.5, 0.7, 0.5],
        intensity: 1
        constantAttenuation: 0,
        linearAttenuation: 0,
        quadraticAttenuation: 0,
        space: "view"
    })
 ];

 // Create box entity
 new xeogl.Entity({
    material: new xeogl.PhongMaterial({
        ambient: [0.5, 0.5, 0.5],
        diffuse: [1,0.3,0.3]
    }),
    geometry: new xeogl.BoxGeometry()
 });
 ````


 @class PointLight
 @module xeogl
 @submodule lighting
 @constructor
 @extends Component
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this PointLight within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The PointLight configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this PointLight.
 @param [cfg.pos=[ 1.0, 1.0, 1.0 ]] {Float32Array} Position, in either World or View space, depending on the value of the **space** parameter.
 @param [cfg.color=[0.7, 0.7, 0.8 ]] {Float32Array} Color of this PointLight.
 @param [cfg.intensity=1.0] {Number} Intensity of this PointLight, as a factor in range ````[0..1]````.
 @param [cfg.constantAttenuation=0] {Number} Constant attenuation factor.
 @param [cfg.linearAttenuation=0] {Number} Linear attenuation factor.
 @param [cfg.quadraticAttenuation=0] {Number} Quadratic attenuation factor.
 @param [cfg.space="view"] {String} The coordinate system this PointLight is defined in - "view" or "world".
 @param [cfg.shadow=false] {Boolean} Flag which indicates if this PointLight casts a shadow.
 */
(function () {

    "use strict";

    var math = xeogl.math;

    xeogl.PointLight = xeogl.Component.extend({

        type: "xeogl.PointLight",

        _init: function (cfg) {

            var self = this;

            this._shadowRenderBuf = null;
            this._shadowViewMatrix = null;
            this._shadowProjMatrix = null;
            this._shadowViewMatrixDirty = true;
            this._shadowProjMatrixDirty = true;

            this._state = new xeogl.renderer.Light({
                type: "point",
                pos: xeogl.math.vec3([1.0, 1.0, 1.0]),
                color: xeogl.math.vec3([0.7, 0.7, 0.8]),
                intensity: 1.0,attenuation: [0.0, 0.0, 0.0],
                space: "view",
                shadow: false,
                shadowDirty: true,

                getShadowViewMatrix: (function () {
                    var look = math.vec3([0,0,0]);
                    var up = math.vec3([0, 1, 0]);
                    return function () {
                        if (self._shadowViewMatrixDirty) {
                            if (!self._shadowViewMatrix) {
                                self._shadowViewMatrix = math.identityMat4();
                            }
                            math.lookAtMat4v(self._state.pos, look, up, self._shadowViewMatrix);
                            self._shadowViewMatrixDirty = false;
                        }
                        return self._shadowViewMatrix;
                    };
                })(),

                getShadowProjMatrix: function () {
                    if (self._shadowProjMatrixDirty) { // TODO: Set when canvas resizes
                        if (!self._shadowProjMatrix) {
                            self._shadowProjMatrix = math.identityMat4();
                        }
                        var canvas = self.scene.canvas.canvas;
                        math.perspectiveMat4(70 *(Math.PI / 180.0), canvas.clientWidth / canvas.clientHeight, 0.1, 500.0, self._shadowProjMatrix);
                        self._shadowProjMatrixDirty = false;
                    }
                    return self._shadowProjMatrix;
                },

                getShadowRenderBuf: function () {
                    if (!self._shadowRenderBuf) {
                        self._shadowRenderBuf = new xeogl.renderer.RenderBuffer(self.scene.canvas.canvas, self.scene.canvas.gl);
                    }
                    return self._shadowRenderBuf;
                }
            });

            this.pos = cfg.pos;
            this.color = cfg.color;
            this.intensity = cfg.intensity;
            this.constantAttenuation = cfg.constantAttenuation;
            this.linearAttenuation = cfg.linearAttenuation;
            this.quadraticAttenuation = cfg.quadraticAttenuation;
            this.space = cfg.space;
            this.shadow = cfg.shadow;
        },

        _props: {

            /**
             The position of this PointLight.

             This will be either World- or View-space, depending on the value of {{#crossLink "PointLight/space:property"}}{{/crossLink}}.

             Fires a {{#crossLink "PointLight/pos:event"}}{{/crossLink}} event on change.

             @property pos
             @default [1.0, 1.0, 1.0]
             @type Array(Number)
             */
            pos: {

                set: function (value) {

                    this._state.pos.set(value || [1.0, 1.0, 1.0]);

                    this._shadowViewMatrixDirty = true;

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this PointLight's  {{#crossLink "PointLight/pos:property"}}{{/crossLink}} property changes.
                     @event pos
                     @param value The property's new value
                     */
                    this.fire("pos", this._state.pos);
                },

                get: function () {
                    return this._state.pos;
                }
            },

            /**
             The color of this PointLight.

             Fires a {{#crossLink "PointLight/color:event"}}{{/crossLink}} event on change.

             @property color
             @default [0.7, 0.7, 0.8]
             @type Float32Array
             */
            color: {

                set: function (value) {

                    this._state.color.set(value || [0.7, 0.7, 0.8]);

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this PointLight's  {{#crossLink "PointLight/color:property"}}{{/crossLink}} property changes.
                     @event color
                     @param value The property's new value
                     */
                    this.fire("color", this._state.color);
                },

                get: function () {
                    return this._state.color;
                }
            },

            /**
             The intensity of this PointLight.

             Fires a {{#crossLink "PointLight/intensity:event"}}{{/crossLink}} event on change.

             @property intensity
             @default 1.0
             @type Number
             */
            intensity: {

                set: function (value) {

                    value = value !== undefined ? value : 1.0;

                    this._state.intensity = value;

                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this PointLight's  {{#crossLink "PointLight/intensity:property"}}{{/crossLink}} property changes.
                     * @event intensity
                     * @param value The property's new value
                     */
                    this.fire("intensity", this._state.intensity);
                },

                get: function () {
                    return this._state.intensity;
                }
            },

            /**
             The constant attenuation factor for this PointLight.

             Fires a {{#crossLink "PointLight/constantAttenuation:event"}}{{/crossLink}} event on change.

             @property constantAttenuation
             @default 0
             @type Number
             */
            constantAttenuation: {

                set: function (value) {

                    this._state.attenuation[0] = value || 0.0;

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this PointLight's {{#crossLink "PointLight/constantAttenuation:property"}}{{/crossLink}} property changes.

                     @event constantAttenuation
                     @param value The property's new value
                     */
                    this.fire("constantAttenuation", this._state.attenuation[0]);
                },

                get: function () {
                    return this._state.attenuation[0];
                }
            },

            /**
             The linear attenuation factor for this PointLight.

             Fires a {{#crossLink "PointLight/linearAttenuation:event"}}{{/crossLink}} event on change.

             @property linearAttenuation
             @default 0
             @type Number
             */
            linearAttenuation: {

                set: function (value) {

                    this._state.attenuation[1] = value || 0.0;

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this PointLight's  {{#crossLink "PointLight/linearAttenuation:property"}}{{/crossLink}} property changes.

                     @event linearAttenuation
                     @param value The property's new value
                     */
                    this.fire("linearAttenuation", this._state.attenuation[1]);
                },

                get: function () {
                    return this._state.attenuation[1];
                }
            },

            /**
             The quadratic attenuation factor for this Pointlight.

             Fires a {{#crossLink "PointLight/quadraticAttenuation:event"}}{{/crossLink}} event on change.

             @property quadraticAttenuation
             @default 0
             @type Number
             */
            quadraticAttenuation: {

                set: function (value) {

                    this._state.attenuation[2] = value || 0.0;

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this PointLight's {{#crossLink "PointLight/quadraticAttenuation:property"}}{{/crossLink}} property changes.

                     @event quadraticAttenuation
                     @param value The property's new value
                     */
                    this.fire("quadraticAttenuation", this._state.attenuation[2]);
                },

                get: function () {
                    return this._state.attenuation[2];
                }
            },

            /**
             Indicates which coordinate space this PointLight is in.

             Supported values are:


             * "view" - View space, aligned within the view volume as if fixed to the viewer's head
             * "world" - World space, fixed within the world, moving within the view volume with respect to camera


             Fires a {{#crossLink "PointLight/space:event"}}{{/crossLink}} event on change.

             @property space
             @default "view"
             @type String
             */
            space: {

                set: function (value) {

                    this._state.space = value || "view";

                    this.fire("dirty", true); // Need to rebuild shader

                    /**
                     Fired whenever this Pointlight's  {{#crossLink "PointLight/space:property"}}{{/crossLink}} property changes.

                     @event space
                     @param value The property's new value
                     */
                    this.fire("space", this._state.space);
                },

                get: function () {
                    return this._state.space;
                }
            },

            /**
             Flag which indicates if this PointLight casts a shadow.

             Fires a {{#crossLink "PointLight/shadow:event"}}{{/crossLink}} event on change.

             @property shadow
             @default false
             @type Boolean
             */
            shadow: {

                set: function (value) {

                    value = !!value;

                    if (this._state.shadow === value) {
                        return;
                    }

                    this._state.shadow = value;

                    this._shadowViewMatrixDirty = true;

                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this PointLight's {{#crossLink "PointLight/shadow:property"}}{{/crossLink}} property changes.
                     * @event shadow
                     * @param value The property's new value
                     */
                    this.fire("shadow", this._state.shadow);

                    this.fire("dirty", true);
                },

                get: function () {
                    return this._state.shadow;
                }
            }
        },

        _destroy: function () {
            if (this._shadowRenderBuf) {
                this._shadowRenderBuf.destroy();
            }
        }
    });

})();
;/**
 A **SpotLight** defines a positional light source that originates from a single point and eminates in a given direction,
 to illuminate {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Overview

 * SpotLights are grouped, along with other light source types, within a {{#crossLink "Lights"}}Lights{{/crossLink}} component,
 which belongs to a {{#crossLink "Scene"}}{{/crossLink}}.
 * SpotLights have a position and direction.
 * SpotLights may be defined in either **World** or **View** coordinate space. When in World-space, their positions
 are relative to the World coordinate system, and will appear to move as the {{#crossLink "Camera"}}{{/crossLink}} moves.
 When in View-space, their positions are relative to the View coordinate system, and will behave as if fixed to the viewer's
 head as the {{#crossLink "Camera"}}{{/crossLink}} moves.
 * SpotLights have {{#crossLink "SpotLight/constantAttenuation:property"}}{{/crossLink}}, {{#crossLink "SpotLight/linearAttenuation:property"}}{{/crossLink}} and
 {{#crossLink "SpotLight/quadraticAttenuation:property"}}{{/crossLink}} factors, which indicate how their intensity attenuates over distance.
 * A SpotLight can also have a {{#crossLink "Shadow"}}{{/crossLink}} component, to configure it to cast a shadow.

 ## Examples

    TODO

 ## Usage

 In the example below we'll customize the default Scene's light sources, defining an AmbientLight and a couple of
 SpotLights, then create a Phong-shaded box entity.

 ````javascript

 // We're using the default xeogl Scene
 // Get Scene's Lights
 var lights = xeogl.scene.lights;

 // Customize the light sources
 lights.lights = [
     new xeogl.AmbientLight({
         color: [0.8, 0.8, 0.8],
         intensity: 0.5
     }),
     new xeogl.SpotLight({
         pos: [0, 100, 100],
         dir: [0, -1, 0],
         color: [0.5, 0.7, 0.5],
         intensity: 1
         constantAttenuation: 0,
         linearAttenuation: 0,
         quadraticAttenuation: 0,
         space: "view"
     }),
     new xeogl.PointLight({
         pos: [0, 100, 100],
         dir: [0, -1, 0],
         color: [0.5, 0.7, 0.5],
         intensity: 1
         constantAttenuation: 0,
         linearAttenuation: 0,
         quadraticAttenuation: 0,
         space: "view"
     })
 ];

 // Create box entity
 new xeogl.Entity({
    material: new xeogl.PhongMaterial({
        ambient: [0.5, 0.5, 0.5],
        diffuse: [1,0.3,0.3]
    }),
    geometry: new xeogl.BoxGeometry()
 });
 ````

 @class SpotLight
 @module xeogl
 @submodule lighting
 @constructor
 @extends Component
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this SpotLight within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The SpotLight configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this SpotLight.
 @param [cfg.pos=[ 1.0, 1.0, 1.0 ]] {Float32Array} Position, in either World or View space, depending on the value of the **space** parameter.
 @param [cfg.dir=[ 0.0, -1.0, 0.0 ]] {Float32Array} Direction in which this Spotlight is shining, in either World or View space, depending on the value of the **space** parameter.
 @param [cfg.color=[0.7, 0.7, 0.8 ]] {Float32Array} Color of this SpotLight.
 @param [cfg.intensity=1.0] {Number} Intensity of this SpotLight.
 @param [cfg.constantAttenuation=0] {Number} Constant attenuation factor.
 @param [cfg.linearAttenuation=0] {Number} Linear attenuation factor.
 @param [cfg.quadraticAttenuation=0] {Number} Quadratic attenuation factor.
 @param [cfg.space="view"] {String} The coordinate system this SpotLight is defined in - "view" or "world".
 @param [cfg.shadow=false] {Boolean} Flag which indicates if this SpotLight casts a shadow.
 */
(function () {

    "use strict";

    var math = xeogl.math;

    xeogl.SpotLight = xeogl.Component.extend({

        type: "xeogl.SpotLight",

        _init: function (cfg) {

            var self = this;

            this._shadowRenderBuf = null;
            this._shadowViewMatrix = null;
            this._shadowProjMatrix = null;
            this._shadowViewMatrixDirty = true;
            this._shadowProjMatrixDirty = true;

            this._state = new xeogl.renderer.Light({
                type: "spot",
                pos: math.vec3([1.0, 1.0, 1.0]),
                dir: math.vec3([0.0, -1.0, 0.0]),
                color: math.vec3([0.7, 0.7, 0.8]),
                intensity: 1.0,
                attenuation: [0.0, 0.0, 0.0],
                space: "view",
                shadow: false,
                shadowDirty: true,

                getShadowViewMatrix: (function () {
                    var look = math.vec3();
                    var up = math.vec3([0, 1, 0]);
                    return function () {
                        if (self._shadowViewMatrixDirty) {
                            if (!self._shadowViewMatrix) {
                                self._shadowViewMatrix = math.identityMat4();
                            }
                            math.addVec3(self._state.pos, self._state.dir, look);
                            math.lookAtMat4v(self._state.pos, look, up, self._shadowViewMatrix);
                            self._shadowViewMatrixDirty = false;
                        }
                        return self._shadowViewMatrix;
                    };
                })(),

                getShadowProjMatrix: function () {
                    if (self._shadowProjMatrixDirty) { // TODO: Set when canvas resizes
                        if (!self._shadowProjMatrix) {
                            self._shadowProjMatrix = math.identityMat4();
                        }
                        var canvas = self.scene.canvas.canvas;
                        math.perspectiveMat4(60 *(Math.PI / 180.0), canvas.clientWidth / canvas.clientHeight, 0.1, 400.0, self._shadowProjMatrix);
                        self._shadowProjMatrixDirty = false;
                    }
                    return self._shadowProjMatrix;
                },

                getShadowRenderBuf: function () {
                    if (!self._shadowRenderBuf) {
                        self._shadowRenderBuf = new xeogl.renderer.RenderBuffer(self.scene.canvas.canvas, self.scene.canvas.gl);
                    }
                    return self._shadowRenderBuf;
                }
            });

            this.pos = cfg.pos;
            this.color = cfg.color;
            this.intensity = cfg.intensity;
            this.constantAttenuation = cfg.constantAttenuation;
            this.linearAttenuation = cfg.linearAttenuation;
            this.quadraticAttenuation = cfg.quadraticAttenuation;
            this.space = cfg.space;
            this.shadow = cfg.shadow;
        },

        _props: {

            /**
             The position of this SpotLight.

             This will be either World- or View-space, depending on the value of {{#crossLink "SpotLight/space:property"}}{{/crossLink}}.

             Fires a {{#crossLink "SpotLight/pos:event"}}{{/crossLink}} event on change.

             @property pos
             @default [1.0, 1.0, 1.0]
             @type Array(Number)
             */
            pos: {

                set: function (value) {

                    this._state.pos.set(value || [1.0, 1.0, 1.0]);

                    this._shadowViewMatrixDirty = true;
                    this._renderer.imageDirty();

                    /**
                     Fired whenever this SpotLight's  {{#crossLink "SpotLight/pos:property"}}{{/crossLink}} property changes.
                     @event pos
                     @param value The property's new value
                     */
                    this.fire("pos", this._state.pos);
                },

                get: function () {
                    return this._state.pos;
                }
            },

            /**
             The direction in which the light is shining.

             Fires a {{#crossLink "SpotLight/dir:event"}}{{/crossLink}} event on change.

             @property dir
             @default [1.0, 1.0, 1.0]
             @type Float32Array
             */
            dir: {

                set: function (value) {

                    this._state.dir.set(value || [1.0, 1.0, 1.0]);

                    this._shadowViewMatrixDirty = true;
                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this SpotLight's  {{#crossLink "SpotLight/dir:property"}}{{/crossLink}} property changes.
                     * @event dir
                     * @param value The property's new value
                     */
                    this.fire("dir", this._state.dir);
                },

                get: function () {
                    return this._state.dir;
                }
            },

            /**
             The color of this SpotLight.

             Fires a {{#crossLink "SpotLight/color:event"}}{{/crossLink}} event on change.

             @property color
             @default [0.7, 0.7, 0.8]
             @type Float32Array
             */
            color: {

                set: function (value) {

                    this._state.color.set(value || [0.7, 0.7, 0.8]);

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this SpotLight's  {{#crossLink "SpotLight/color:property"}}{{/crossLink}} property changes.
                     @event color
                     @param value The property's new value
                     */
                    this.fire("color", this._state.color);
                },

                get: function () {
                    return this._state.color;
                }
            },

            /**
             The intensity of this SpotLight.

             Fires a {{#crossLink "SpotLight/intensity:event"}}{{/crossLink}} event on change.

             @property intensity
             @default 1.0
             @type Number
             */
            intensity: {

                set: function (value) {

                    value = value !== undefined ? value : 1.0;

                    this._state.intensity = value;

                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this SpotLight's  {{#crossLink "SpotLight/intensity:property"}}{{/crossLink}} property changes.
                     * @event intensity
                     * @param value The property's new value
                     */
                    this.fire("intensity", this._state.intensity);
                },

                get: function () {
                    return this._state.intensity;
                }
            },

            /**
             The constant attenuation factor for this SpotLight.

             Fires a {{#crossLink "SpotLight/constantAttenuation:event"}}{{/crossLink}} event on change.

             @property constantAttenuation
             @default 0
             @type Number
             */
            constantAttenuation: {

                set: function (value) {

                    this._state.attenuation[0] = value || 0.0;

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this SpotLight's {{#crossLink "SpotLight/constantAttenuation:property"}}{{/crossLink}} property changes.

                     @event constantAttenuation
                     @param value The property's new value
                     */
                    this.fire("constantAttenuation", this._state.attenuation[0]);
                },

                get: function () {
                    return this._state.attenuation[0];
                }
            },

            /**
             The linear attenuation factor for this SpotLight.

             Fires a {{#crossLink "SpotLight/linearAttenuation:event"}}{{/crossLink}} event on change.

             @property linearAttenuation
             @default 0
             @type Number
             */
            linearAttenuation: {

                set: function (value) {

                    this._state.attenuation[1] = value || 0.0;

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this SpotLight's  {{#crossLink "SpotLight/linearAttenuation:property"}}{{/crossLink}} property changes.

                     @event linearAttenuation
                     @param value The property's new value
                     */
                    this.fire("linearAttenuation", this._state.attenuation[1]);
                },

                get: function () {
                    return this._state.attenuation[1];
                }
            },

            /**
             The quadratic attenuation factor for this SpotLight.

             Fires a {{#crossLink "SpotLight/quadraticAttenuation:event"}}{{/crossLink}} event on change.

             @property quadraticAttenuation
             @default 0
             @type Number
             */
            quadraticAttenuation: {

                set: function (value) {

                    this._state.attenuation[2] = value || 0.0;

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this SpotLight's {{#crossLink "SpotLight/quadraticAttenuation:property"}}{{/crossLink}} property changes.

                     @event quadraticAttenuation
                     @param value The property's new value
                     */
                    this.fire("quadraticAttenuation", this._state.attenuation[2]);
                },

                get: function () {
                    return this._state.attenuation[2];
                }
            },

            /**
             Indicates which coordinate space this SpotLight is in.

             Supported values are:


             * "view" - View space, aligned within the view volume as if fixed to the viewer's head
             * "world" - World space, fixed within the world, moving within the view volume with respect to camera


             Fires a {{#crossLink "SpotLight/space:event"}}{{/crossLink}} event on change.

             @property space
             @default "view"
             @type String
             */
            space: {

                set: function (value) {

                    this._state.space = value || "view";

                    this.fire("dirty", true); // Need to rebuild shader

                    /**
                     Fired whenever this SpotLight's  {{#crossLink "SpotLight/space:property"}}{{/crossLink}} property changes.

                     @event space
                     @param value The property's new value
                     */
                    this.fire("space", this._state.space);
                },

                get: function () {
                    return this._state.space;
                }
            },

            /**
             Flag which indicates if this SpotLight casts a shadow.

             Fires a {{#crossLink "SpotLight/shadow:event"}}{{/crossLink}} event on change.

             @property shadow
             @default false
             @type Boolean
             */
            shadow: {

                set: function (value) {

                    value = !!value;

                    if (this._state.shadow === value) {
                        return;
                    }

                    this._state.shadow = value;

                    this._shadowViewMatrixDirty = true;

                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this SpotLight's {{#crossLink "SpotLight/shadow:property"}}{{/crossLink}} property changes.
                     * @event shadow
                     * @param value The property's new value
                     */
                    this.fire("shadow", this._state.shadow);

                    this.fire("dirty", true);
                },

                get: function () {
                    return this._state.shadow;
                }
            }
        },

        _destroy: function () {
//            this.scene.canvas.off(this._webglContextRestored);

            if (this._shadowRenderBuf) {
                this._shadowRenderBuf.destroy();
            }
        }
    });

})();
;/**
 A **CubeTexture** specifies a cube texture map.

 ## Overview

 See {{#crossLink "Lights"}}{{/crossLink}} for an example of how to use CubeTextures for light and reflection mapping.

 @class CubeTexture
 @module xeogl
 @submodule lighting
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this CubeTexture in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID for this CubeTexture, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this CubeTexture.
 @param [cfg.src=null] {Array of String} Paths to six image files to load into this CubeTexture.
 @param [cfg.flipY=false] {Boolean} Flips this CubeTexture's source data along its vertical axis when true.
 @param [cfg.encoding="linear"] {String} Encoding format.  See the {{#crossLink "CubeTexture/encoding:property"}}{{/crossLink}} property for more info.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.CubeTexture = xeogl.Component.extend({

        type: "xeogl.CubeTexture",

        _init: function (cfg) {

            this._state = new xeogl.renderer.CubeTexture({
                texture: null
            });

            this._src = [];
            this._images = [];

            this._srcDirty = false;
            this._imageDirty = false;

            this._webglContextRestored = this.scene.canvas.on("webglContextRestored", this._webglContextRestored, this);

            this.flipY = cfg.flipY;
            this.src = cfg.src; // Image file}
            this.encoding = cfg.encoding;

            xeogl.stats.memory.textures++;
        },

        _webglContextRestored: function () {

            this._state.texture = null;

            if (this._src) {
                this._srcDirty = true;
            }

            this._needUpdate();
        },

        _update: function () {

            if (this._srcDirty) {
                if (this._src) {
                    this._loadSrc(this._src); // _imageDirty is set when the image has loaded
                    this._srcDirty = false;
                    return;
                }
            }

            if (this._imageDirty) {
                this._createTexture();
                this._renderer.imageDirty();
            }
        },

        _loadSrc: function (src) {

            var self = this;

            this._images = [];

            var loadFailed = false;
            var numLoaded = 0;

            for (var i = 0; i < src.length; i++) {

                var image = new Image();

                image.onload = (function () {

                    var _image = image;
                    var index = i;

                    return function () {

                        if (loadFailed) {
                            return;
                        }

                        _image = xeogl.renderer.ensureImageSizePowerOfTwo(_image);

                        self._images[index] = _image;

                        numLoaded++;

                        if (numLoaded === 6) {

                            self._imageDirty = true;

                            self._needUpdate();

                            /**
                             * Fired whenever this CubeTexture has loaded the
                             * image files that its {{#crossLink "CubeTexture/src:property"}}{{/crossLink}} property currently points to.
                             * @event loaded
                             * @param value {HTML Image} The value of the {{#crossLink "CubeTexture/src:property"}}{{/crossLink}} property
                             */
                            self.fire("loaded", self._src);
                        }
                    };
                })();

                image.onerror = function () {
                    loadFailed = true;

                };

                image.src = src[i];
            }
        },

        _createTexture: function () {

            var gl = this.scene.canvas.gl;

            var texture = this._state.texture;

            if (!texture) {
                texture = new xeogl.renderer.Texture2D(gl, gl.TEXTURE_CUBE_MAP);
                this._state.texture = texture;
            }

            texture.setImage(this._images, this._state);

            texture.setProps({
                minFilter: "linearMipmapLinear",
                magFilter: "linear",
                wrapS: "clampToEdge",
                wrapT: "clampToEdge",
                mipmaps: true
            });

            this._imageDirty = false;
        },

        _props: {

            /**
             Array of paths to six image files to source this CubeTexture.

             Fires a {{#crossLink "CubeTexture/src:event"}}{{/crossLink}} event on change.

             @property src
             @default null
             @type {Array of String}
             */
            src: {

                set: function (value) {

                    this._src = value;

                    this._srcDirty = true;

                    this._needUpdate();

                    /**
                     * Fired whenever this CubeTexture's {{#crossLink "CubeTexture/src:property"}}{{/crossLink}} property changes.
                     * @event src
                     * @param value The property's new value
                     * @type {Array of String}
                     */
                    this.fire("src", this._src);
                },

                get: function () {
                    return this._src;
                }
            },

            /**
             * Flips this CubeTexture's source data along its vertical axis when true.
             *
             * Fires a {{#crossLink "CubeTexture/flipY:event"}}{{/crossLink}} event on change.
             *
             * @property flipY
             * @default false
             * @type Boolean
             */
            flipY: {

                set: function (value) {

                    value = !!value;

                    if (this._state.flipY === value) {
                        return;
                    }

                    this._state.flipY = value;
                    this._imageDirty = true; // flipY is used when loading image data, not when post-applying props

                    this._needUpdate();

                    /**
                     * Fired whenever this CubeTexture's  {{#crossLink "CubeTexture/flipY:property"}}{{/crossLink}} property changes.
                     * @event flipY
                     * @param value {String} The property's new value
                     */
                    this.fire("flipY", this._state.flipY);
                },

                get: function () {
                    return this._state.flipY;
                }
            },

            /**
             The CubeTexture's encoding format.

             Supported values are:

             * "linear" (default)
             * "sRGB"
             * "gamma"

             @property encoding
             @default "linear"
             @type String
             */
            encoding: {

                set: function (value) {

                    value = value || "linear";

                    if (value !== "linear" && value !== "sRGB" && value !== "gamma") {
                        this.error("Unsupported value for 'encoding': '" + value +  "' - supported values are 'linear', 'sRGB', 'gamma'. Defaulting to 'linear'.");

                        value = "linear";
                    }

                    this._state.encoding = value;

                    this.fire("dirty"); // Encoding/decoding is baked into shaders - need recompile of entities using this CubeTexture in their materials
                },

                get: function () {
                    return this._state.encoding;
                }
            }
        },

        _destroy: function () {

            this.scene.canvas.off(this._webglContextRestored);

            if (this._state.texture) {
                this._state.texture.destroy();
            }

            xeogl.stats.memory.textures--;
        }
    });

})();
;/**
 A **Shadow** defines a shadow cast by a {{#crossLink "DirLight"}}{{/crossLink}} or a {{#crossLink "SpotLight"}}{{/crossLink}}.

 Work in progress!

 ## Overview

 * Shadows are attached to {{#crossLink "DirLight"}}{{/crossLink}} and {{#crossLink "SpotLight"}}{{/crossLink}} components.

 TODO

 ## Examples

 TODO

 ## Usage

 ```` javascript
 var entity = new xeogl.Entity(scene, {

        lights: new xeogl.Lights({
            lights: [

                new xeogl.SpotLight({
                    pos: [0, 100, 100],
                    dir: [0, -1, 0],
                    color: [0.5, 0.7, 0.5],
                    intensity: 1
                    constantAttenuation: 0,
                    linearAttenuation: 0,
                    quadraticAttenuation: 0,
                    space: "view",

                    shadow: new xeogl.Shadow({
                        resolution: [1000, 1000],
                        intensity: 0.7,
                        sampling: "stratified" // "stratified" | "poisson" | "basic"
                    });
                })
            ]
        }),
 ,
        material: new xeogl.PhongMaterial({
            diffuse: [0.5, 0.5, 0.0]
        }),

        geometry: new xeogl.BoxGeometry()
  });
 ````

 @class Shadow
 @module xeogl
 @submodule lighting
 @constructor
 @extends Component
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this Shadow within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The Shadow configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Shadow.
 @param [cfg.resolution=[1000,1000]] {Uint16Array} Resolution of the texture map for this Shadow.
 @param [cfg.intensity=1.0] {Number} Intensity of this Shadow.
 */
(function () {

    "use strict";

    xeogl.Shadow = xeogl.Component.extend({

        type: "xeogl.Shadow",

        _init: function (cfg) {

            this._state = {
                resolution: xeogl.math.vec3([1000, 1000]),
                intensity: 1.0
            };

            this.resolution = cfg.resolution;
            this.intensity = cfg.intensity;
        },

        _props: {

            /**
             The resolution of the texture map for this Shadow.

             This will be either World- or View-space, depending on the value of {{#crossLink "Shadow/space:property"}}{{/crossLink}}.

             Fires a {{#crossLink "Shadow/resolution:event"}}{{/crossLink}} event on change.

             @property resolution
             @default [1000, 1000]
             @type Uint16Array
             */
            resolution: {

                set: function (value) {

                    this._state.resolution.set(value || [1000.0, 1000.0]);

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this Shadow's  {{#crossLink "Shadow/resolution:property"}}{{/crossLink}} property changes.
                     @event resolution
                     @param value The property's new value
                     */
                    this.fire("resolution", this._state.resolution);
                },

                get: function () {
                    return this._state.resolution;
                }
            },
            
            /**
             The intensity of this Shadow.

             Fires a {{#crossLink "Shadow/intensity:event"}}{{/crossLink}} event on change.

             @property intensity
             @default 1.0
             @type Number
             */
            intensity: {

                set: function (value) {

                    value = value !== undefined ? value : 1.0;

                    this._state.intensity = value;

                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this Shadow's  {{#crossLink "Shadow/intensity:property"}}{{/crossLink}} property changes.
                     * @event intensity
                     * @param value The property's new value
                     */
                    this.fire("intensity", this._state.intensity);
                },

                get: function () {
                    return this._state.intensity;
                }
            }
        }
    });

})();
;/**
 * Models are units of xeogl content.
 *
 * @module xeogl
 * @submodule models
 */;/**
 A **Model** is a collection of {{#crossLink "Component"}}Components{{/crossLink}}.

 ## Overview

 * A Model owns the components that are added to it, automatically destroying them when the Model is destroyed.
 * Can be attached to a {{#crossLink "Transform"}}{{/crossLink}} hierarchy, to transform its components as a group, within World-space.
 * Provides the collective axis-aligned World-space boundary of its components.

 A Model is subclassed by (at least):

 * {{#crossLink "GLTFModel"}}{{/crossLink}}, which loads its components from glTF files.
 * {{#crossLink "OBJModel"}}{{/crossLink}}, which loads its components from .OBJ and .MTL files.
 * {{#crossLink "STLModel"}}{{/crossLink}}, which loads its components from .STL files.
 * {{#crossLink "SceneJSModel"}}{{/crossLink}}, which loads its components from SceneJS scene definitions.
 * {{#crossLink "BuildableModel"}}{{/crossLink}}, which provides a fluent API for building its components.

 ## Usage

 * [Adding Components](#adding-components)
 * [Removing Components](#removing-components)
 * [Finding Models in Scenes](#finding-models-in-scenes)
 * [Finding Components in Models](#finding-components-in-models)
 * [Transforming a Model](#transforming-a-model)
 * [Getting the World-space boundary of a Model](#getting-the-world-space-boundary-of-a-model)
 * [Clearing a Model](#clearing-a-model)
 * [Destroying a Model](#destroying-a-model)

 ### Adding Components

 When adding components to a Model, it's usually easiest to just add their configuration objects and let the Model
 internally instantiate them, as shown below.

 As mentioned, a Model owns all the components added to it, destroying them when we destroy
 the Model or call the Model's {{#crossLink "Model/destroyAll:method"}}{{/crossLink}} method.

 ````javascript
 var model = new xeogl.Model({ // Create Model in xeogl's default Scene
     id: "myModel"
 });

 var geometry = model.add({
    type: "xeogl.TorusGeometry"
 });

 var material = model.add({
    type: "xeogl.PhongMaterial"
    diffuse: [0.4, 0.4, 9.0]
 });

 model.add({
    type: "xeogl.Entity",
    geometry: geometry,
    material: material
 });
 ````

 As shown below, we can also add our own component instances, supplying them either by reference or ID.

 Note that the components must be in the same {{#crossLink "Scene"}}{{/crossLink}} as the model.

 ````javascript
 // Add by instance
 var myEntity = new xeogl.Entity({
    geometry: geometry,
    material: material
 });
 model.add(myEntity);

 // Add by ID
 new xeogl.Entity({
    id: "myEntity",
    geometry: geometry,
    material: material
 })
 model.add("myEntity");
 ````

 We can also add components all in one shot,  via the Model's constructor:

 ````javascript
 model = new xeogl.Model({
    id: "myModel",
    components: [
        {
            type: "xeogl.TorusGeometry",
            id: "myGeometry"
        },
        {
            type: "xeogl.PhongMaterial",
            id: "myMaterial",
            diffuse: [0.4, 0.4, 0.9]
        },
        {
            type: "xeogl.Entity",
            id: "myEntity",
            geometry: "myGeometry",
            material: "myMaterial"
        }
    ]
 });
 ````

 ### Removing Components

 To remove a component instance from a Model:

 ````JavaScript
 model.remove(myEntity);
 ````

 We can also remove components by ID:

 ````JavaScript
 model.remove("myEntity");
 ````
 Note that if the Component is owned by the Model, where it was created like this:

 ````javascript
 var myComponent = new xeogl.Rotate(myModel, {... });
 ````

 then even after removing it, calling {{#crossLink "Model/destroyAll:method"}}destroyAll{{/crossLink}} on the
 Model will still destroy the component.

 ### Finding Models in Scenes

 Our Model will now be registered by ID on its Scene, so we can now find it like this:

 ````javascript
 model = xeogl.scene.models["myModel"];
 ````

 That's assuming that we've created the Model in the default xeogl Scene, which we did for these examples.

 ### Finding Components in Models

 Our Model now has various components within itself, which we can find by their IDs.

 To find the components grouped by their types, drop this expression into the browser's JavaScript
 debug console (we're using Chrome here):

 ````
 model.types;
 ````

 The result is the value of the Model's {{#crossLink "Model/types:property"}}types{{/crossLink}} map, which
 contains its components, mapped to their types:

 <img src="../../../assets/images/screenshots/Model_findingComponents.png"></img>

 Here we've expanded the {{#crossLink "PhongMaterial"}}{{/crossLink}} components, and we can see
 our {{#crossLink "PhongMaterial"}}{{/crossLink}}.

 Let's get that {{#crossLink "PhongMaterial"}}{{/crossLink}} from our Model's
 {{#crossLink "Model/components:property"}}{{/crossLink}} map and change its diffuse color:

 ```` JavaScript
 var material = model.components["myMaterial"];
 material.diffuse = [0.9, 0.4, 0.4];
 ````

 The Model also has an {{#crossLink "Model/entities:property"}}{{/crossLink}} map, in which we can find our {{#crossLink "Entity"}}{{/crossLink}}:

 <img src="../../../assets/images/screenshots/Model.entities.png"></img>

 ### Transforming a Model

 A Model lets us transform its Entities as a group.

 We can attach a modeling {{#crossLink "Transform"}}{{/crossLink}} to our Model, as a either a
 configuration object or a component instance:

 ```` Javascript
 // Attach transforms as a configuration object:
 model.transform = {
        type: "xeogl.Translate",
        xyz: [-35, 0, 0],
        parent: {
            type: "xeogl.Rotate",
            xyz: [0, 1, 0],
            angle: 45
        }
     };

 // Attach our own transform instances:
 model.transform = new xeogl.Translate({
        xyz: [-35, 0, 0],
        parent: new xeogl.Rotate({
            xyz: [0, 1, 0],
            angle: 45
        })
     });
 ````

 We can also provide the {{#crossLink "Transform"}}{{/crossLink}} to the Model constructor, as either configuration
 objects or instances.

 Here we'll provide them as configuration objects:

 ```` Javascript
 // Model internally instantiates our transform components:
 var model3 = new xeogl.Model({
        transform: {
            type: "xeogl.Translate",
            xyz: [-35, 0, 0],
            parent: {
                type: "xeogl.Rotate",
                xyz: [0, 1, 0],
                angle: 45
            }
        }
     });

 ````

 Note that, as with the components we added before, the Model will manage the lifecycles of our {{#crossLink "Transform"}}{{/crossLink}} components,
 destroying them when we destroy the Model or call its {{#crossLink "Model/destroyAll:method"}}{{/crossLink}} method. Also, when we call {{#crossLink "Component/destroy:method"}}{{/crossLink}} on a Model component, the component will remove itself from the Model first.

 ### Getting the World-space boundary of a Model

 Get the World-space axis-aligned boundary of a MOdel like this:

 ```` Javascript
 model.on("boundary", function() {
    var aabb = model.aabb; //  [xmin, ymin,zmin,xmax,ymax, zmax]
    //...
 });
 ````

 We can also subscribe to changes to that boundary, which will happen whenever

 * the Model's {{#crossLink "Transform"}}{{/crossLink}} is updated,
 * components are added or removed from the Model, or
 * the {{#crossLink "Geometry"}}Geometries{{/crossLink}} or {{#crossLink "Transform"}}Transforms{{/crossLink}} of its Entities are switched or modified.

 ````javascript
 model.on("boundary", function() {
    var aabb = model.aabb; // [xmin, ymin,zmin,xmax,ymax, zmax]
 });
 ````

 ### Clearing a Model

 ```` Javascript
 model.clear();
 ````

 ### Destroying a Model

 ```` Javascript
 model.destroy();
 ````


 @class Model
 @module xeogl
 @submodule models
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this ModelModel in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}},
 generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this ModelModel.
 @param [cfg.flattenTransforms=true] {Boolean} Flattens transform hierarchies to improve rendering performance.
 @param [cfg.ghosted=false] {Boolean} When true, sets all the Model's Entities initially ghosted.
 @param [cfg.highlighted=false] {Boolean} When true, sets all the Model's Entities initially highlighted.
 @param [cfg.outlined=false] {Boolean} When true, sets all the Model's Entities initially outlined.
 @param [cfg.transform] {Number|String|Transform} A Local-to-World-space (modelling) {{#crossLink "Transform"}}{{/crossLink}} to attach to this Model.
 Must be within the same {{#crossLink "Scene"}}{{/crossLink}} as this Model. Internally, the given
 {{#crossLink "Transform"}}{{/crossLink}} will be inserted above each top-most {{#crossLink "Transform"}}Transform{{/crossLink}}
 that the Model attaches to its {{#crossLink "Entity"}}Entities{{/crossLink}}.
 @param [cfg.components] {Array} Array of {{#crossLink "Components"}}{{/crossLink}} to add initially, given as IDs, configuration objects or instances.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Model = xeogl.Component.extend({

        /**
         JavaScript class name for this Component.

         @property type
         @type String
         @final
         */
        type: "xeogl.Model",

        _init: function (cfg) {

            /**
             * The {{#crossLink "Components"}}{{/crossLink}} within this Model, mapped to their IDs.
             *
             * Fires an {{#crossLink "Model/updated:event"}}{{/crossLink}} event on change.
             *
             * @property components
             * @type {{String:Component}}
             */
            this.components = {};

            /**
             * The number of {{#crossLink "Components"}}{{/crossLink}} within this Model.
             *
             * @property numComponents
             * @type Number
             */
            this.numComponents = 0;

            /**
             * A map of maps; for each {{#crossLink "Component"}}{{/crossLink}} type in this Model,
             * a map to IDs to {{#crossLink "Component"}}{{/crossLink}} instances, eg.
             *
             * ````
             * "xeogl.Geometry": {
             *   "alpha": <xeogl.Geometry>,
             *   "beta": <xeogl.Geometry>
             * },
             * "xeogl.Rotate": {
             *   "charlie": <xeogl.Rotate>,
             *   "delta": <xeogl.Rotate>,
             *   "echo": <xeogl.Rotate>,
             * },
             * //...
             * ````
             *
             * @property types
             * @type {String:{String:xeogl.Component}}
             */
            this.types = {};

            /**
             * The {{#crossLink "Entity"}}Entity{{/crossLink}} component instances within this Model, mapped to their IDs.
             *
             * @property entities
             * @type {{String:Entity}}
             */
            this.entities = {};

            // Subscriptions to "destroyed" events from components
            this._onDestroyed = {};

            // Subscriptions to "boundary" events from Entities
            this._onBoundary = {};

            this._aabb = xeogl.math.AABB3();

            this._aabbDirty = false;

            // Dummy transform to make it easy to graft user-supplied transforms above added entities
            this._dummyRootTransform = this.create({
                type: "xeogl.Transform",
                meta: "dummy"
            });

            this.transform = cfg.transform;

            this.ghosted = cfg.ghosted || cfg.ghost; // Backwards compat
            this.highlighted = cfg.highlighted;
            this.visible = cfg.visible;
            this.culled = cfg.culled;
            this.outlined = cfg.outlined;
            this.selected = cfg.selected;

            if (cfg.components) {
                var components = cfg.components;
                for (var i = 0, len = components.length; i < len; i++) {
                    this.add(components[i]);
                }
            }
        },

        /**
         * Adds a {{#crossLink "Component"}}Component{{/crossLink}} or subtype to this Model.
         *
         * The {{#crossLink "Component"}}Component(s){{/crossLink}} may be specified by ID, instance, JSON definition or type.
         *
         * See class comment for usage examples.
         *
         * The {{#crossLink "Component"}}Components{{/crossLink}} must be in the same {{#crossLink "Scene"}}{{/crossLink}} as this Model.
         *
         * Fires an {{#crossLink "Model/added:event"}}{{/crossLink}} event.
         *
         * @method add
         * @param {Number|String|*|Component} component ID, definition or instance of a {{#crossLink "Component"}}Component{{/crossLink}} type or subtype.
         */
        add: function (component) {

            var componentId;
            var types;

            if (xeogl._isNumeric(component) || xeogl._isString(component)) {

                if (this.scene.types[component]) {

                    // Component type

                    var type = component;

                    types = this.scene.types[type];

                    if (!types) {
                        this.warn("Component type not found: '" + type + "'");
                        return;
                    }

                    for (componentId in types) {
                        if (types.hasOwnProperty(componentId)) {
                            this.add(types[componentId]);
                        }
                    }

                    return;

                } else {

                    // Component ID

                    component = this.scene.components[component];

                    if (!component) {
                        this.warn("Component not found: " + xeogl._inQuotes(component));
                        return;
                    }
                }

            } else if (xeogl._isObject(component)) {

                // Component config given

                var type = component.type || "xeogl.Component";

                if (!xeogl._isComponentType(type)) {
                    this.error("Not a xeogl component type: " + type);
                    return;
                }

                component = new window[type](this.scene, component);
            }

            if (component.scene !== this.scene) {

                // Component in wrong Scene

                this.warn("Attempted to add component from different xeogl.Scene: " + xeogl._inQuotes(component.id));
                return;
            }

            // Add component to this map

            if (this.components[component.id]) {

                // Component already in this Model
                return;
            }

            this.components[component.id] = component;

            // Register component for its type

            types = this.types[component.type];

            if (!types) {
                types = this.types[component.type] = {};
            }

            types[component.id] = component;

            this.numComponents++;

            // Remove component when it's destroyed

            var self = this;

            this._onDestroyed[component.id] = component.on("destroyed", function () {
                self.remove(component);
            });

            if (component.isType("xeogl.Entity")) {

                // Insert the dummy transform above
                // each entity we just loaded

                var rootTransform = component.transform;

                if (!rootTransform || rootTransform.id === "default.transform") {

                    component.transform = self._dummyRootTransform;

                } else {

                    while (rootTransform.parent) {

                        if (rootTransform.id === self._dummyRootTransform.id) {

                            // Since transform hierarchies may contain
                            // transforms that share the same parents, there is potential to find
                            // our dummy root transform while walking up an entity's transform
                            // path, when that path is joins a path that belongs to an Entity that
                            // we processed earlier

                            break;
                        }

                        rootTransform = rootTransform.parent;
                    }

                    if (rootTransform.id !== self._dummyRootTransform.id) {
                        rootTransform.parent = self._dummyRootTransform;
                    }
                }

                this.entities[component.id] = component;

                component.ghosted = this.ghosted;
                component.highlighted = this.highlighted;
                component.visible = this.visible;
                component.culled = this.culled;
                component.selected = this.selected;

                this._onBoundary[component.id] = component.on("boundary", this._setAABBDirty, this);

                this._setAABBDirty();
            }

            /**
             * Fired whenever an individual {{#crossLink "Component"}}{{/crossLink}} is added to this {{#crossLink "Model"}}{{/crossLink}}.
             * @event added
             * @param value {Component} The {{#crossLink "Component"}}{{/crossLink}} that was added.
             */
            this.fire("added", component);

            if (!this._dirty) {
                this._needUpdate();
            }

            return component;
        },

        _needUpdate: function () {
            if (!this._dirty) {
                this._dirty = true;
                xeogl.scheduleTask(this._notifyUpdated, this);
            }
        },

        _notifyUpdated: function () {

            /* Fired on the next {{#crossLink "Scene/tick.animate:event"}}{{/crossLink}} whenever
             * {{#crossLink "Component"}}Components{{/crossLink}} were added or removed since the
             * last {{#crossLink "Scene/tick.animate:event"}}{{/crossLink}} event, to provide a batched change event
             * for subscribers who don't want to react to every individual addition or removal on this Model.
             *
             * @event updated
             */
            this.fire("updated");

            if (!this._aabbDirty) {
                this._setAABBDirty();
            }

            this._dirty = false;
        },

        /**
         * Destroys all {{#crossLink "Component"}}Components{{/crossLink}} in this Model.
         *
         * @method destroyAll
         */
        destroyAll: function () {

            // For efficiency, destroy Entities first to avoid
            // xeogl's automatic default component substitutions

            var type;
            var list = [];
            var components;
            var component;
            var id;

            for (type in this.types) {
                if (this.types.hasOwnProperty(type)) {
                    components = this.types[type];
                    for (id in components) {
                        if (components.hasOwnProperty(id)) {
                            component = components[id];
                            if (component.isType("xeogl.Entity")) {
                                list.push(component);
                            } else {
                                list.unshift(component);
                            }
                        }
                    }
                }
            }

            while (list.length > 0) {
                list.pop().destroy();
            }
        },
        /**
         * Removes all {{#crossLink "Component"}}Components{{/crossLink}} from this Model.
         *
         * @method removeAll
         */
        removeAll: function () {

            this.iterate(function (component) {
                component.destroy();
            });
        },

        /**
         * Removes a {{#crossLink "Component"}}{{/crossLink}} from this model, without destroying it.
         *
         * Note that if the Component is owned by the Model, where it was created like this:
         *
         * ````javascript
         * var myComponent = new xeogl.Rotate(myModel, {... });
         * ````
         *
         * then even after removing it, calling {{#crossLink "Model/destroyAll:method"}}destroyAll{{/crossLink}} on the
         * Model will still destroy the component.
         *
         * @param component
         */
        remove: function (component) {

            if (xeogl._isNumeric(component) || xeogl._isString(component)) {

                var id = component;

                // Component ID

                component = this.scene.components[id];

                if (!component) {
                    this.warn("Component not found in Scene: " + id);
                    return;
                }

                component = this.components[id];

                if (!component) {
                    this.warn("Component " + id + " is not in this Model");
                    return;
                }
            } else {

                if (component.scene !== this.scene) {
                    this.warn("Attempted to remove component that's not in same xeogl.Scene: '" + component.id + "'");
                    return;
                }
            }

            this._remove(component);
        },

        _remove: function (component) {

            var componentId = component.id;

            delete this.components[componentId];
            delete this.entities[componentId];

            // Unsubscribe from component destruction

            component.off(this._onDestroyed[componentId]);
            delete this._onDestroyed[componentId];

            // Unregister component for its type

            var types = this.types[component.type];

            if (types) {
                delete types[component.id];
            }

            this.numComponents--;

            //

            if (component.isType("xeogl.Entity")) {
                component.off(this._onBoundary[component.id]);
                delete this._onBoundary[component.id];
            }

            /**
             * Fired whenever an individual {{#crossLink "Component"}}{{/crossLink}} is removed from this {{#crossLink "Model"}}{{/crossLink}}.
             * @event removed
             * @param value {Component} The {{#crossLink "Component"}}{{/crossLink}} that was removed.
             */
            this.fire("removed", component);

            if (!this._dirty) {
                this._needUpdate();
            }
        },

        /**
         * Iterates with a callback over the {{#crossLink "Component"}}Components{{/crossLink}} in this Model.
         *
         * @method iterate
         * @param {Function} callback Callback called for each {{#crossLink "Component"}}{{/crossLink}}.
         * @param {Object} [scope=this] Optional scope for the callback, defaults to this Model.
         */
        iterate: function (callback, scope) {
            scope = scope || this;
            var components = this.components;
            for (var componentId in components) {
                if (components.hasOwnProperty(componentId)) {
                    callback.call(scope, components[componentId]);
                }
            }
        },

        _props: {

            /**
             * The Local-to-World-space (modelling) {{#crossLink "Transform"}}{{/crossLink}} attached to this Model.
             *
             * Must be within the same {{#crossLink "Scene"}}{{/crossLink}} as this Model.
             *
             * Internally, the given {{#crossLink "Transform"}}{{/crossLink}} will be inserted above each top-most
             * {{#crossLink "Transform"}}Transform{{/crossLink}} that the Model attaches to
             * its {{#crossLink "Entity"}}Entities{{/crossLink}}.
             *
             * Fires an {{#crossLink "Model/transform:event"}}{{/crossLink}} event on change.
             *
             * @property transform
             * @type Transform
             */
            transform: {

                set: function (value) {

                    /**
                     * Fired whenever this Model's {{#crossLink "Model/transform:property"}}{{/crossLink}} property changes.
                     *
                     * @event transform
                     * @param value The property's new value
                     */
                    this._attach({
                        name: "transform",
                        type: "xeogl.Transform",
                        component: value,
                        sceneDefault: false,
                        onAttached: {
                            callback: this._transformUpdated,
                            scope: this
                        }
                    });
                },

                get: function () {
                    return this._attached.transform;
                }
            },

            /**
             * World-space axis-aligned 3D boundary (AABB) of this Model.
             *
             * The AABB is represented by a six-element Float32Array containing the min/max extents of the
             * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
             *
             * @property aabb
             * @final
             * @type {Float32Array}
             */
            aabb: {

                get: function () {

                    if (this._aabbDirty) {

                        var xmin = xeogl.math.MAX_DOUBLE;
                        var ymin = xeogl.math.MAX_DOUBLE;
                        var zmin = xeogl.math.MAX_DOUBLE;
                        var xmax = -xeogl.math.MAX_DOUBLE;
                        var ymax = -xeogl.math.MAX_DOUBLE;
                        var zmax = -xeogl.math.MAX_DOUBLE;

                        var aabb;

                        var entities = this.entities;

                        for (var entityId in entities) {
                            if (entities.hasOwnProperty(entityId)) {

                                aabb = entities[entityId].aabb;

                                if (aabb[0] < xmin) {
                                    xmin = aabb[0];
                                }
                                if (aabb[1] < ymin) {
                                    ymin = aabb[1];
                                }
                                if (aabb[2] < zmin) {
                                    zmin = aabb[2];
                                }
                                if (aabb[3] > xmax) {
                                    xmax = aabb[3];
                                }
                                if (aabb[4] > ymax) {
                                    ymax = aabb[4];
                                }
                                if (aabb[5] > zmax) {
                                    zmax = aabb[5];
                                }
                            }
                        }

                        this._aabb[0] = xmin;
                        this._aabb[1] = ymin;
                        this._aabb[2] = zmin;
                        this._aabb[3] = xmax;
                        this._aabb[4] = ymax;
                        this._aabb[5] = zmax;

                        this._aabbDirty = false;
                    }

                    return this._aabb;
                }
            },

            /**
             Indicates whether this Model's Entities are visible or not.

             @property visible
             @default true
             @type Boolean
             */
            visible: {

                set: function (value) {
                    value = value !== false;
                    this._visible = value;
                    for (var id in this.entities) {
                        if (this.entities.hasOwnProperty(id)) {
                            this.entities[id].visible = value;
                        }
                    }
                },

                get: function () {
                    return this._visible;
                }
            },

            /**
             Indicates whether this Model's Entities are culled or not.

             @property culled
             @default false
             @type Boolean
             */
            culled: {

                set: function (value) {
                    value = !!value;
                    this._culled = value;
                    for (var id in this.entities) {
                        if (this.entities.hasOwnProperty(id)) {
                            this.entities[id].culled = value;
                        }
                    }
                },

                get: function () {
                    return this._culled;
                }
            },

            /**
             * Flag which indicates if this Model's Entities are rendered with ghosted effect.
             *
             * @property ghosted
             * @default false
             * @type Boolean
             */
            "ghosted,ghost": {

                set: function (value) {
                    value = !!value;
                    this._ghosted = value;
                    for (var id in this.entities) {
                        if (this.entities.hasOwnProperty(id)) {
                            this.entities[id].ghosted = value;
                        }
                    }
                },

                get: function () {
                    return this._ghosted;
                }
            },

            /**
             * Flag which indicates if this Model's Entities are rendered with highlighted effect.
             *
             * @property highlighted
             * @default false
             * @type Boolean
             */
            "highlight,highlighted": {

                set: function (value) {
                    value = !!value;
                    this._highlighted = value;
                    for (var id in this.entities) {
                        if (this.entities.hasOwnProperty(id)) {
                            this.entities[id].highlighted = value;
                        }
                    }
                },

                get: function () {
                    return this._highlighted;
                }
            },

            /**
             * Flag which indicates if this Model's Entities are rendered as selected.
             *
             * @property selected
             * @default false
             * @type Boolean
             */
            selected: {

                set: function (value) {
                    value = !!value;
                    this._selected = value;
                    for (var id in this.entities) {
                        if (this.entities.hasOwnProperty(id)) {
                            this.entities[id].selected = value;
                        }
                    }
                },

                get: function () {
                    return this._selected;
                }
            },

            /**
             * Flag which indicates if this Model's Entities are rendered with outlined effect.
             *
             * @property outlined
             * @default false
             * @type Boolean
             */
            "outlined,outline": {

                set: function (value) {
                    value = !!value;
                    this._outlined = value;
                    for (var id in this.entities) {
                        if (this.entities.hasOwnProperty(id)) {
                            this.entities[id].outlined = value;
                        }
                    }
                },

                get: function () {
                    return this._outlined;
                }
            }
        },

        _transformUpdated: function (transform) {
            this._dummyRootTransform.parent = transform;
            this._setAABBDirty();
        },

        _setAABBDirty: function () {
            if (this._aabbDirty) {
                return;
            }
            this._aabbDirty = true;

            /**
             Fired whenever this Model's World-space boundary changes.

             Get the latest boundary from the Model's {{#crossLink "Model/aabb:property"}}{{/crossLink}} property.

             @event boundary
             */
            this.fire("boundary");
        },

        _destroy: function () {
            this.removeAll();
        }
    });

})();;/**
 * Components to define the surface appearance of Entities.
 *
 * @module xeogl
 * @submodule materials
 */;/**
 A **Material** defines the surface appearance of attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

 Material is the base class for:

 * {{#crossLink "MetallicMaterial"}}{{/crossLink}} - physically-based material for metallic surfaces. Use this one for things made of metal.
 * {{#crossLink "SpecularMaterial"}}{{/crossLink}} - physically-based material for non-metallic (dielectric)
 surfaces. Use this one for insulators, such as ceramics, plastics, wood etc.
 * {{#crossLink "PhongMaterial"}}{{/crossLink}} - material for classic Blinn-Phong shading. This is less demanding of graphics hardware than the physically-based materials.
 * {{#crossLink "LambertMaterial"}}{{/crossLink}} - material for fast, flat-shaded CAD rendering without textures. Use
 this for navigating huge CAD or BIM models interactively. This material gives the best rendering performance and uses the least memory.
 * {{#crossLink "EmphasisMaterial"}}{{/crossLink}} - defines the appearance of Entities when "ghosted" or "highlighted".
 * {{#crossLink "OutlineMaterial"}}{{/crossLink}} - defines the appearance of outlines drawn around Entities.

 A {{#crossLink "Scene"}}Scene{{/crossLink}} is allowed to contain a mixture of these material types.

 @class Material
 @module xeogl
 @submodule materials
 @constructor
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Material = xeogl.Component.extend({

        type: "xeogl.Material",

        _init: function () {
            xeogl.stats.memory.materials++;
        },

        _destroy: function() {
            xeogl.stats.memory.materials--;
        }
    });

})();
;/**
 A **PhongMaterial** is a {{#crossLink "Material"}}{{/crossLink}} that defines the surface appearance of
 attached {{#crossLink "Entity"}}Entities{{/crossLink}} using
 the classic <a href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model">Blinn-Phong</a> lighting model.

 ## Examples

 | <a href="../../examples/#materials_phong_textures"><img src="../../assets/images/screenshots/PhongMaterial/textures.png"></img></a> | <a href="../../examples/#materials_phong_textures_video"><img src="../../assets/images/screenshots/PhongMaterial/videoTexture.png"></img></a> | <a href="../../examples/#materials_phong_fresnel"><img src="../../assets/images/screenshots/PhongMaterial/fresnel.png"></img></a> |
 |:------:|:----:|:-----:|:-----:|
 |[Phong textures](../../examples/#materials_phong_textures)|[Video texture](../../examples/#materials_phong_textures_video)| [Fresnels](../../examples/#materials_phong_fresnel)|

 ## Overview

 * Used for rendering non-realistic objects such as "helpers", wireframe objects, labels etc.
 * Use the physically-based {{#crossLink "MetallicMaterial"}}{{/crossLink}} or {{#crossLink "SpecularMaterial"}}{{/crossLink}} when more realism is required.

 <img src="../../../assets/images/PhongMaterial.png"></img>

 The following table summarizes PhongMaterial properties:

 | Property | Type | Range | Default Value | Space | Description |
 |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 |  {{#crossLink "PhongMaterial/ambient:property"}}{{/crossLink}} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the ambient light reflected by the material. |
 |  {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the diffuse light reflected by the material. |
 |  {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the specular light reflected by the material. |
 |  {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the light emitted by the material. |
 | {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 | {{#crossLink "PhongMaterial/shininess:property"}}{{/crossLink}} | Number | [0, 128] | 80 | linear | Determines the size and sharpness of specular highlights. |
 | {{#crossLink "PhongMaterial/reflectivity:property"}}{{/crossLink}} | Number | [0, 1] | 1 | linear | Determines the amount of reflectivity. |
 | {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | sRGB | Texture RGB components multiplying by {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}}. If the fourth component (A) is present, it multiplies by {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}}. |
 | {{#crossLink "PhongMaterial/specularMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | sRGB | Texture RGB components multiplying by {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}}. If the fourth component (A) is present, it multiplies by {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}}. |
 | {{#crossLink "PhongMaterial/emissiveMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with RGB components multiplying by {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}}. |
 | {{#crossLink "PhongMaterial/alphaMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with first component multiplying by {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}}. |
 | {{#crossLink "PhongMaterial/occlusionMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Ambient occlusion texture multiplying by {{#crossLink "PhongMaterial/ambient:property"}}{{/crossLink}}, {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}} and {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}}. |
 | {{#crossLink "PhongMaterial/normalMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Tangent-space normal map. |
 | {{#crossLink "PhongMaterial/diffuseFresnel:property"}}{{/crossLink}} | {{#crossLink "Fresnel"}}{{/crossLink}} |  | null |  | Fresnel term applied to {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}}. |
 | {{#crossLink "PhongMaterial/specularFresnel:property"}}{{/crossLink}} | {{#crossLink "Fresnel"}}{{/crossLink}} |  | null |  | Fresnel term applied to {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}}. |
 | {{#crossLink "PhongMaterial/emissiveFresnel:property"}}{{/crossLink}} | {{#crossLink "Fresnel"}}{{/crossLink}} |  | null |  | Fresnel term applied to {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}}. |
 | {{#crossLink "PhongMaterial/reflectivityFresnel:property"}}{{/crossLink}} | {{#crossLink "Fresnel"}}{{/crossLink}} |  | null |  | Fresnel term applied to {{#crossLink "PhongMaterial/reflectivity:property"}}{{/crossLink}}. |
 | {{#crossLink "PhongMaterial/alphaFresnel:property"}}{{/crossLink}} | {{#crossLink "Fresnel"}}{{/crossLink}} |  | null |  | Fresnel term applied to {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}}. |
 | {{#crossLink "PhongMaterial/lineWidth:property"}}{{/crossLink}} | Number | [0..100] | 1 |  | Line width in pixels. |
 | {{#crossLink "PhongMaterial/pointSize:property"}}{{/crossLink}} | Number | [0..100] | 1 |  | Point size in pixels. |
 | {{#crossLink "PhongMaterial/alphaMode:property"}}{{/crossLink}} | String | "opaque", "blend", "mask" | "blend" |  | Alpha blend mode. |
 | {{#crossLink "PhongMaterial/alphaCutoff:property"}}{{/crossLink}} | Number | [0..1] | 0.5 |  | Alpha cutoff value. |
 | {{#crossLink "PhongMaterial/backfaces:property"}}{{/crossLink}} | Boolean |  | false |  | Whether to render {{#crossLink "Geometry"}}Geometry{{/crossLink}} backfaces. |
 | {{#crossLink "PhongMaterial/frontface:property"}}{{/crossLink}} | String | "ccw", "cw" | "ccw" |  | The winding order for {{#crossLink "Geometry"}}Geometry{{/crossLink}} frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |

 ## Usage

 In this example we have an Entity with

 * a {{#crossLink "Lights"}}{{/crossLink}} containing an {{#crossLink "AmbientLight"}}{{/crossLink}} and a {{#crossLink "DirLight"}}{{/crossLink}},
 * a {{#crossLink "PhongMaterial"}}{{/crossLink}} which applies a {{#crossLink "Texture"}}{{/crossLink}} as a diffuse map and a specular {{#crossLink "Fresnel"}}{{/crossLink}}, and
 * a {{#crossLink "TorusGeometry"}}{{/crossLink}}.

 ```` javascript
 var torus = new xeogl.Entity({

    lights: new xeogl.Lights({
        lights: [
            new xeogl.AmbientLight({
                color: [0.7, 0.7, 0.7]
            }),
            new xeogl.DirLight({
                dir: [-1, -1, -1],
                color: [0.5, 0.7, 0.5],
                intensity: [1.0, 1.0, 1.0],
                space: "view"
            })
        ]
    }),

    material: new xeogl.PhongMaterial({
        ambient: [0.3, 0.3, 0.3],
        diffuse: [0.5, 0.5, 0.0],   // Ignored, since we have assigned a Texture to diffuseMap, below
        diffuseMap: new xeogl.Texture({
            src: "diffuseMap.jpg"
        }),
        specular: [1, 1, 1],
        specularFresnel: new xeogl.Fresnel({
            leftColor: [1.0, 1.0, 1.0],
            rightColor: [0.0, 0.0, 0.0],
            power: 4
        }),
        shininess: 80, // Default
        alpha: 1.0 // Default
    }),

    geometry: new xeogl.TorusGeometry()
});
 ````

 ## Transparency

 ### Alpha Blending

 Let's make our torus transparent. We'll update its PhongMaterial's {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}}
 and {{#crossLink "PhongMaterial/alphaMode:property"}}{{/crossLink}}, causing it to blend 50% with the background:

 ````javascript
 torus.material.alpha = 0.5;
 torus.material.alphaMode = "blend";
 ````
 *TODO: Screenshot*

 ### Alpha Masking

 Now let's make holes in our torus instead. We'll give its PhongMaterial an {{#crossLink "PhongMaterial/alphaMap:property"}}{{/crossLink}}
 and configure {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}}, {{#crossLink "PhongMaterial/alphaMode:property"}}{{/crossLink}},
 and {{#crossLink "PhongMaterial/alphaCutoff:property"}}{{/crossLink}} to treat it as an alpha mask:

 ````javascript
 torus.material.alphaMap = new xeogl.Texture({
        src: "textures/diffuse/crossGridColorMap.jpg"
    });

 torus.material.alpha = 1.0;
 torus.material.alphaMode = "mask";
 torus.material.alphaCutoff = 0.2;
 ````
 *TODO: Screenshot*


 @class PhongMaterial
 @module xeogl
 @submodule materials
 @constructor
 @extends Material
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this PhongMaterial within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The PhongMaterial configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta=null] {String:Object} Metadata to attach to this PhongMaterial.
 @param [cfg.ambient=[1.0, 1.0, 1.0 ]] {Array of Number} PhongMaterial ambient color.
 @param [cfg.diffuse=[ 1.0, 1.0, 1.0 ]] {Array of Number} PhongMaterial diffuse color.
 @param [cfg.specular=[ 1.0, 1.0, 1.0 ]] {Array of Number} PhongMaterial specular color.
 @param [cfg.emissive=[ 0.0, 0.0, 0.0 ]] {Array of Number} PhongMaterial emissive color.
 @param [cfg.alpha=1] {Number} Scalar in range 0-1 that controls alpha, where 0 is completely transparent and 1 is completely opaque.
 @param [cfg.shininess=80] {Number} Scalar in range 0-128 that determines the size and sharpness of specular highlights.
 @param [cfg.reflectivity=1] {Number} Scalar in range 0-1 that controls how much {{#crossLink "CubeMap"}}CubeMap{{/crossLink}} is reflected.
 @param [cfg.lineWidth=1] {Number} Scalar that controls the width of lines for {{#crossLink "Geometry"}}{{/crossLink}} with {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "lines".
 @param [cfg.pointSize=1] {Number} Scalar that controls the size of points for {{#crossLink "Geometry"}}{{/crossLink}} with {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "points".
 @param [cfg.ambientMap=null] {Texture} A ambient map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will multiply by the diffuse property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.diffuseMap=null] {Texture} A diffuse map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will override the effect of the diffuse property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.specularMap=null] {Texture} A specular map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will override the effect of the specular property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.emissiveMap=undefined] {Texture} An emissive map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will override the effect of the emissive property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.normalMap=undefined] {Texture} A normal map {{#crossLink "Texture"}}Texture{{/crossLink}}. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.alphaMap=undefined] {Texture} An alpha map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will override the effect of the alpha property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.reflectivityMap=undefined] {Texture} A reflectivity control map {{#crossLink "Texture"}}Texture{{/crossLink}}, which will override the effect of the reflectivity property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.occlusionMap=null] {Texture} An occlusion map {{#crossLink "Texture"}}Texture{{/crossLink}}. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.diffuseFresnel=undefined] {Fresnel} A diffuse {{#crossLink "Fresnel"}}Fresnel{{/crossLink}}. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.specularFresnel=undefined] {Fresnel} A specular {{#crossLink "Fresnel"}}Fresnel{{/crossLink}}. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.emissiveFresnel=undefined] {Fresnel} An emissive {{#crossLink "Fresnel"}}Fresnel{{/crossLink}}. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.alphaFresnel=undefined] {Fresnel} An alpha {{#crossLink "Fresnel"}}Fresnel{{/crossLink}}. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.reflectivityFresnel=undefined] {Fresnel} A reflectivity {{#crossLink "Fresnel"}}Fresnel{{/crossLink}}. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.
 @param [cfg.alphaMode="opaque"] {String} The alpha blend mode - accepted values are "opaque", "blend" and "mask".
 See the {{#crossLink "PhongMaterial/alphaMode:property"}}{{/crossLink}} property for more info.
 @param [cfg.alphaCutoff=0.5] {Number} The alpha cutoff value. See the {{#crossLink "PhongMaterial/alphaCutoff:property"}}{{/crossLink}} property for more info.
 @param [cfg.backfaces=false] {Boolean} Whether to render {{#crossLink "Geometry"}}Geometry{{/crossLink}} backfaces.
 @param [cfg.frontface="ccw"] {Boolean} The winding order for {{#crossLink "Geometry"}}Geometry{{/crossLink}} front faces - "cw" for clockwise, or "ccw" for counter-clockwise.
 */
(function () {

    "use strict";

    xeogl.PhongMaterial = xeogl.Material.extend({

        type: "xeogl.PhongMaterial",

        _init: function (cfg) {

            this._super(cfg);

            this._state = new xeogl.renderer.PhongMaterial({

                type: "PhongMaterial",

                ambient: xeogl.math.vec3([1.0, 1.0, 1.0]),
                diffuse: xeogl.math.vec3([1.0, 1.0, 1.0]),
                specular: xeogl.math.vec3([1.0, 1.0, 1.0]),
                emissive: xeogl.math.vec3([0.0, 0.0, 0.0]),

                alpha: null,
                shininess: null,
                reflectivity: null,

                alphaMode: null,
                alphaCutoff: null,

                lineWidth: null,
                pointSize: null,

                backfaces: null,
                frontface: null, // Boolean for speed; true == "ccw", false == "cw"

                hash: null
            });

            this._hashDirty = true;

            this.on("dirty", function () {

                // This PhongMaterial is flagged dirty when a
                // child component fires "dirty", which always
                // means that a shader recompile will be needed.

                this._hashDirty = true;
            }, this);

            this.ambient = cfg.ambient;
            this.diffuse = cfg.diffuse;
            this.specular = cfg.specular;
            this.emissive = cfg.emissive;

            this.alpha = cfg.alpha;
            this.shininess = cfg.shininess;
            this.reflectivity = cfg.reflectivity;

            this.lineWidth = cfg.lineWidth;
            this.pointSize = cfg.pointSize;

            if (cfg.ambientMap) {
                this.ambientMap = cfg.ambientMap;
            }

            if (cfg.diffuseMap) {
                this.diffuseMap = cfg.diffuseMap;
            }

            if (cfg.specularMap) {
                this.specularMap = cfg.specularMap;
            }

            if (cfg.emissiveMap) {
                this.emissiveMap = cfg.emissiveMap;
            }

            if (cfg.alphaMap) {
                this.alphaMap = cfg.alphaMap;
            }

            if (cfg.reflectivityMap) {
                this.reflectivityMap = cfg.reflectivityMap;
            }

            if (cfg.normalMap) {
                this.normalMap = cfg.normalMap;
            }

            if (cfg.occlusionMap) {
                this.occlusionMap = cfg.occlusionMap;
            }

            if (cfg.diffuseFresnel) {
                this.diffuseFresnel = cfg.diffuseFresnel;
            }

            if (cfg.specularFresnel) {
                this.specularFresnel = cfg.specularFresnel;
            }

            if (cfg.emissiveFresnel) {
                this.emissiveFresnel = cfg.emissiveFresnel;
            }

            if (cfg.alphaFresnel) {
                this.alphaFresnel = cfg.alphaFresnel;
            }

            if (cfg.reflectivityFresnel) {
                this.reflectivityFresnel = cfg.reflectivityFresnel;
            }

            this.alphaMode = cfg.alphaMode;
            this.alphaCutoff = cfg.alphaCutoff;

            this.backfaces = cfg.backfaces;
            this.frontface = cfg.frontface;
        },

        _props: {

            /**
             The PhongMaterial's ambient color.

             @property ambient
             @default [0.3, 0.3, 0.3]
             @type Float32Array
             */
            ambient: {

                set: function (value) {

                    var ambient = this._state.ambient;

                    if (!ambient) {
                        ambient = this._state.ambient = new Float32Array(3);

                    } else if (value && ambient[0] === value[0] && ambient[1] === value[1] && ambient[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        ambient[0] = value[0];
                        ambient[1] = value[1];
                        ambient[2] = value[2];

                    } else {
                        ambient[0] = .2;
                        ambient[1] = .2;
                        ambient[2] = .2;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.ambient;
                }
            },

            /**
             The PhongMaterial's diffuse color.

             Multiplies by {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}}.

             @property diffuse
             @default [1.0, 1.0, 1.0]
             @type Float32Array
             */
            diffuse: {

                set: function (value) {

                    var diffuse = this._state.diffuse;

                    if (!diffuse) {
                        diffuse = this._state.diffuse = new Float32Array(3);

                    } else if (value && diffuse[0] === value[0] && diffuse[1] === value[1] && diffuse[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        diffuse[0] = value[0];
                        diffuse[1] = value[1];
                        diffuse[2] = value[2];

                    } else {
                        diffuse[0] = 1;
                        diffuse[1] = 1;
                        diffuse[2] = 1;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.diffuse;
                }
            },

            /**
             The material's specular color.

             Multiplies by {{#crossLink "PhongMaterial/specularMap:property"}}{{/crossLink}}.

             @property specular
             @default [1.0, 1.0, 1.0]
             @type Float32Array
             */
            specular: {

                set: function (value) {

                    var specular = this._state.specular;

                    if (!specular) {
                        specular = this._state.specular = new Float32Array(3);

                    } else if (value && specular[0] === value[0] && specular[1] === value[1] && specular[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        specular[0] = value[0];
                        specular[1] = value[1];
                        specular[2] = value[2];

                    } else {
                        specular[0] = 1;
                        specular[1] = 1;
                        specular[2] = 1;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.specular;
                }
            },

            /**
             The PhongMaterial's emissive color.

             Multiplies by {{#crossLink "PhongMaterial/emissiveMap:property"}}{{/crossLink}}.

             @property emissive
             @default [0.0, 0.0, 0.0]
             @type Float32Array
             */
            emissive: {

                set: function (value) {

                    var emissive = this._state.emissive;

                    if (!emissive) {
                        emissive = this._state.emissive = new Float32Array(3);

                    } else if (value && emissive[0] === value[0] && emissive[1] === value[1] && emissive[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        emissive[0] = value[0];
                        emissive[1] = value[1];
                        emissive[2] = value[2];

                    } else {
                        emissive[0] = 0;
                        emissive[1] = 0;
                        emissive[2] = 0;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.emissive;
                }
            },

            /**
             Factor in the range [0..1] indicating how transparent the PhongMaterial is.

             A value of 0.0 indicates fully transparent, 1.0 is fully opaque.

             Multiplies by {{#crossLink "PhongMaterial/alphaMap:property"}}{{/crossLink}}.

             @property alpha
             @default 1.0
             @type Number
             */
            alpha: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 1.0;

                    if (this._state.alpha === value) {
                        return;
                    }

                    this._state.alpha = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.alpha;
                }
            },

            /**
             A factor in range [0..128] that determines the size and sharpness of the specular highlights create by this PhongMaterial.

             Larger values produce smaller, sharper highlights. A value of 0.0 gives very large highlights that are almost never
             desirable. Try values close to 10 for a larger, fuzzier highlight and values of 100 or more for a small, sharp
             highlight.

             @property shininess
             @default 80.0
             @type Number
             */
            shininess: {

                set: function (value) {

                    this._state.shininess = value !== undefined ? value : 80;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.shininess;
                }
            },

            /**
             The PhongMaterial's line width.

             @property lineWidth
             @default 1.0
             @type Number
             */
            lineWidth: {

                set: function (value) {

                    this._state.lineWidth = value || 1.0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.lineWidth;
                }
            },

            /**
             The PhongMaterial's point size.

             @property pointSize
             @default 1.0
             @type Number
             */
            pointSize: {

                set: function (value) {

                    this._state.pointSize = value || 1.0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.pointSize;
                }
            },

            /**
             Scalar in range 0-1 that controls how much {{#crossLink "CubeMap"}}CubeMap{{/crossLink}} is reflected by this PhongMaterial.

             The surface will be non-reflective when this is 0, and completely mirror-like when it is 1.0.

             Multiplies by {{#crossLink "PhongMaterial/reflectivityMap:property"}}{{/crossLink}}.

             @property reflectivity
             @default 1.0
             @type Number
             */
            reflectivity: {

                set: function (value) {

                    this._state.reflectivity = value !== undefined ? value : 1.0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.reflectivity;
                }
            },

            /**
             A normal {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property normalMap
             @default undefined
             @type {Texture}
             */
            normalMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/normalMap:property"}}{{/crossLink}} property changes.

                     @event normalMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "normalMap", texture);
                },

                get: function () {
                    return this._attached.normalMap;
                }
            },

            /**
             An ambient {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/ambient:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property ambientMap
             @default undefined
             @type {Texture}
             */
            ambientMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/ambientMap:property"}}{{/crossLink}} property changes.

                     @event ambientMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "ambientMap", texture);
                },

                get: function () {
                    return this._attached.ambientMap;
                }
            },

            /**
             A diffuse {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}} when not null or undefined.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property diffuseMap
             @default undefined
             @type {Texture}
             */
            diffuseMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}} property changes.

                     @event diffuseMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "diffuseMap", texture);
                },

                get: function () {
                    return this._attached.diffuseMap;
                }
            },

            /**
             A specular {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}} when not null or undefined.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property specularMap
             @default undefined
             @type {Texture}
             */
            specularMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/specularMap:property"}}{{/crossLink}} property changes.

                     @event specularMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "specularMap", texture);
                },

                get: function () {
                    return this._attached.specularMap;
                }
            },

            /**
             An emissive {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}} when not null or undefined.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property emissiveMap
             @default undefined
             @type {Texture}
             */
            emissiveMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/emissiveMap:property"}}{{/crossLink}} property changes.

                     @event emissiveMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "emissiveMap", texture);
                },

                get: function () {
                    return this._attached.emissiveMap;
                }
            },

            /**
             An alpha {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}} when not null or undefined.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property alphaMap
             @default undefined
             @type {Texture}
             */
            alphaMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/alphaMap:property"}}{{/crossLink}} property changes.

                     @event alphaMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "alphaMap", texture);
                },

                get: function () {
                    return this._attached.alphaMap;
                }
            },

            /**
             A reflectivity {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/reflectivity:property"}}{{/crossLink}} when not null or undefined.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property reflectivityMap
             @default undefined
             @type {Texture}
             */
            reflectivityMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/reflectivityMap:property"}}{{/crossLink}} property changes.

                     @event reflectivityMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "reflectivityMap", texture);
                },

                get: function () {
                    return this._attached.reflectivityMap;
                }
            },

            /**
             A reflection {{#crossLink "CubeMap"}}{{/crossLink}} attached to this PhongMaterial.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property reflection
             @default undefined
             @type {Reflect}
             */
            reflection: {

                set: function (cubeMap) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/reflectivityMap:property"}}{{/crossLink}} property changes.

                     @event reflection
                     @param value {Reflect} The property's new value
                     */
                    this._attachComponent("xeogl.Reflect", "reflection", cubeMap);
                },

                get: function () {
                    return this._attached.reflection;
                }
            },

            /**

             An occlusion map {{#crossLink "Texture"}}{{/crossLink}} attached to this PhongMaterial.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property occlusionMap
             @default undefined
             @type {Texture}
             */
            occlusionMap: {

                set: function (texture) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/occlusionMap:property"}}{{/crossLink}} property changes.

                     @event occlusionMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "occlusionMap", texture);
                },

                get: function () {
                    return this._attached.occlusionMap;
                }
            },

            /**
             A diffuse {{#crossLink "Fresnel"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/diffuseFresnel:property"}}{{/crossLink}} when not null or undefined.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property diffuseFresnel
             @default undefined
             @type {Fresnel}
             */
            diffuseFresnel: {

                set: function (fresnel) {

                    /**
                     Fired whenever this PhongMaterial's {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}} property changes.

                     @event diffuseFresnel
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Fresnel", "diffuseFresnel", fresnel);
                },

                get: function () {
                    return this._attached.diffuseFresnel;
                }
            },

            /**
             A specular {{#crossLink "Fresnel"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}} when not null or undefined.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property specularFresnel
             @default undefined
             @type {Fresnel}
             */
            specularFresnel: {

                set: function (fresnel) {
                    this._attachComponent("xeogl.Fresnel", "specularFresnel", fresnel);
                },

                get: function () {
                    return this._attached.specularFresnel;
                }
            },

            /**
             An emissive {{#crossLink "Fresnel"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/emissive:property"}}{{/crossLink}} when not null or undefined.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property emissiveFresnel
             @default undefined
             @type {Fresnel}
             */
            emissiveFresnel: {

                set: function (fresnel) {
                    this._attachComponent("xeogl.Fresnel", "emissiveFresnel", fresnel);
                },

                get: function () {
                    return this._attached.emissiveFresnel;
                }
            },

            /**
             An alpha {{#crossLink "Fresnel"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}} when not null or undefined.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property alphaFresnel
             @default undefined
             @type {Fresnel}
             */
            alphaFresnel: {

                set: function (fresnel) {
                    this._attachComponent("xeogl.Fresnel", "alphaFresnel", fresnel);
                },

                get: function () {
                    return this._attached.alphaFresnel;
                }
            },

            /**
             A reflectivity {{#crossLink "Fresnel"}}{{/crossLink}} attached to this PhongMaterial.

             This property multiplies by {{#crossLink "PhongMaterial/reflectivity:property"}}{{/crossLink}} when not null or undefined.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this PhongMaterial.

             @property reflectivityFresnel
             @default undefined
             @type {Fresnel}
             */
            reflectivityFresnel: {

                set: function (fresnel) {
                    this._attachComponent("xeogl.Fresnel", "reflectivityFresnel", fresnel);
                },

                get: function () {
                    return this._attached.reflectivityFresnel;
                }
            },

            /**
             The alpha rendering mode.

             This governs how alpha is treated. Alpha is the combined result of the
             {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}} and
             {{#crossLink "PhongMaterial/alphaMap:property"}}{{/crossLink}} properties.

             * "opaque" - The alpha value is ignored and the rendered output is fully opaque.
             * "mask" - The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value.
             * "blend" - The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator).

             @property alphaMode
             @default "opaque"
             @type {String}
             */
            alphaMode: (function () {
                var modes = {"opaque": 0, "mask": 1, "blend": 2};
                var modeNames = ["opaque", "mask", "blend"];
                return {
                    set: function (alphaMode) {

                        alphaMode = alphaMode || "opaque";

                        var value = modes[alphaMode];

                        if (value === undefined) {
                            this.error("Unsupported value for 'alphaMode': " + alphaMode + " - defaulting to 'opaque'");
                            value = "opaque";
                        }

                        if (this._state.alphaMode === value) {
                            return;
                        }

                        this._state.alphaMode = value;

                        this._renderer.imageDirty();
                    },
                    get: function () {
                        return modeNames[this._state.alphaMode];
                    }
                };
            })(),

            /**
             The alpha cutoff value.

             Specifies the cutoff threshold when {{#crossLink "PhongMaterial/alphaMode:property"}}{{/crossLink}}
             equals "mask". If the alpha is greater than or equal to this value then it is rendered as fully
             opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire
             material as fully transparent. This value is ignored for other modes.

             Alpha is the combined result of the
             {{#crossLink "PhongMaterial/alpha:property"}}{{/crossLink}} and
             {{#crossLink "PhongMaterial/alphaMap:property"}}{{/crossLink}} properties.

             @property alphaCutoff
             @default 0.5
             @type {Number}
             */
            alphaCutoff: {
                set: function (alphaCutoff) {

                    if (alphaCutoff === null || alphaCutoff === undefined) {
                        alphaCutoff = 0.5;
                    }

                    if (this._state.alphaCutoff === alphaCutoff) {
                        return;
                    }

                    this._state.alphaCutoff = alphaCutoff;
                },
                get: function () {
                    return this._state.alphaCutoff;
                }
            },

            /**
             Whether backfaces are visible on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             The backfaces will belong to {{#crossLink "Geometry"}}{{/crossLink}} compoents that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             @property backfaces
             @default false
             @type Boolean
             */
            backfaces: {

                set: function (value) {

                    value = !!value;

                    if (this._state.backfaces === value) {
                        return;
                    }

                    this._state.backfaces = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.backfaces;
                }
            },

            /**
             Indicates the winding direction of front faces on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             The faces will belong to {{#crossLink "Geometry"}}{{/crossLink}} components that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             @property frontface
             @default "ccw"
             @type String
             */
            frontface: {

                set: function (value) {

                    value = value !== "cw";

                    if (this._state.frontface === value) {
                        return;
                    }

                    this._state.frontface = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.frontface ? "ccw" : "cw";
                }
            }
        },

        _attachComponent: function (expectedType, name, component) {
            component = this._attach({
                name: name,
                type: expectedType,
                component: component,
                sceneDefault: false,
                on: {
                    destroyed: {
                        callback: function () {
                            this._state[name] = null;
                            this._hashDirty = true;
                        },
                        scope: this
                    }
                }
            });
            this._state[name] = component ? component._state : null; // FIXME: Accessing _state breaks encapsulation
            this._hashDirty = true;
        },

        _getState: function () {
            if (this._hashDirty) {
                this._makeHash();
                this._hashDirty = false;
            }
            return this._state;
        },

        _makeHash: function () {

            var state = this._state;

            var hash = ["/p"]; // 'P' for Phong

            if (state.normalMap) {
                hash.push("/nm");
                if (state.normalMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.ambientMap) {
                hash.push("/am");
                if (state.ambientMap.matrix) {
                    hash.push("/mat");
                }
                hash.push("/" + state.ambientMap.encoding);
            }

            if (state.diffuseMap) {
                hash.push("/dm");
                if (state.diffuseMap.matrix) {
                    hash.push("/mat");
                }
                hash.push("/" + state.diffuseMap.encoding);
            }

            if (state.specularMap) {
                hash.push("/sm");
                if (state.specularMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.emissiveMap) {
                hash.push("/em");
                if (state.emissiveMap.matrix) {
                    hash.push("/mat");
                }
                hash.push("/" + state.emissiveMap.encoding);
            }

            if (state.alphaMap) {
                hash.push("/opm");
                if (state.alphaMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.reflectivityMap) {
                hash.push("/rm");
                if (state.reflectivityMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.occlusionMap) {
                hash.push("/ocm");
                if (state.occlusionMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.diffuseFresnel) {
                hash.push("/df");
            }

            if (state.specularFresnel) {
                hash.push("/sf");
            }

            if (state.emissiveFresnel) {
                hash.push("/ef");
            }

            if (state.alphaFresnel) {
                hash.push("/of");
            }

            if (state.reflectivityFresnel) {
                hash.push("/rf");
            }

            hash.push(";");

            state.hash = hash.join("");
        },

        _destroy: function () {
            this._super();
            this._state.destroy();
        }
    });

})();;/**
 A **LambertMaterial** is a {{#crossLink "Material"}}{{/crossLink}} that defines the surface appearance of
 attached {{#crossLink "Entity"}}Entities{{/crossLink}} using
 the non-physically based <a href="https://en.wikipedia.org/wiki/Lambertian_reflectance">Lambertian</a> model for calculating reflectance.

 ## Examples

TODO

 ## Overview

 * Used for rendering non-realistic objects such as "helpers", wireframe objects, labels etc.
 * Use  {{#crossLink "PhongMaterial"}}{{/crossLink}} when you need specular highlights.
 * Use the physically based {{#crossLink "MetallicMaterial"}}{{/crossLink}} or {{#crossLink "SpecularMaterial"}}{{/crossLink}} when you need more realism.

 For LambertMaterial, the illumination calculation is performed at each triangle vertex, and the resulting color is
 interpolated across the face of the triangle. For {{#crossLink "PhongMaterial"}}{{/crossLink}}, {{#crossLink "MetallicMaterial"}}{{/crossLink}} and
 {{#crossLink "SpecularMaterial"}}{{/crossLink}}, vertex normals are interpolated across the surface of the triangle, and
 the illumination calculation is performed at each texel.

 The following table summarizes LambertMaterial properties:

 | Property | Type | Range | Default Value | Space | Description |
 |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 |  {{#crossLink "LambertMaterial/ambient:property"}}{{/crossLink}} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the ambient light reflected by the material. |
 |  {{#crossLink "LambertMaterial/color:property"}}{{/crossLink}} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the diffuse light reflected by the material. |
 |  {{#crossLink "LambertMaterial/emissive:property"}}{{/crossLink}} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the light emitted by the material. |
 | {{#crossLink "LambertMaterial/alpha:property"}}{{/crossLink}} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 | {{#crossLink "LambertMaterial/lineWidth:property"}}{{/crossLink}} | Number | [0..100] | 1 |  | Line width in pixels. |
 | {{#crossLink "LambertMaterial/pointSize:property"}}{{/crossLink}} | Number | [0..100] | 1 |  | Point size in pixels. |
 | {{#crossLink "LambertMaterial/backfaces:property"}}{{/crossLink}} | Boolean |  | false |  | Whether to render {{#crossLink "Geometry"}}Geometry{{/crossLink}} backfaces. |
 | {{#crossLink "LambertMaterial/backfaces:property"}}{{/crossLink}} | String | "ccw", "cw" | "ccw" |  | The winding order for {{#crossLink "Geometry"}}Geometry{{/crossLink}} frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |

 ## Usage

 ```` javascript
 var torus = new xeogl.Entity({
    material: new xeogl.LambertMaterial({
        ambient: [0.3, 0.3, 0.3],
        color: [0.5, 0.5, 0.0],
        alpha: 1.0 // Default
    }),

    geometry: new xeogl.TorusGeometry()
});
 ````
 @class LambertMaterial
 @module xeogl
 @submodule materials
 @constructor
 @extends Material
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this LambertMaterial within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The LambertMaterial configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta=null] {String:Object} Metadata to attach to this LambertMaterial.
 @param [cfg.ambient=[1.0, 1.0, 1.0 ]] {Array of Number} LambertMaterial ambient color.
 @param [cfg.color=[ 1.0, 1.0, 1.0 ]] {Array of Number} LambertMaterial diffuse color.
 @param [cfg.emissive=[ 0.0, 0.0, 0.0 ]] {Array of Number} LambertMaterial emissive color.
 @param [cfg.alpha=1] {Number} Scalar in range 0-1 that controls alpha, where 0 is completely transparent and 1 is completely opaque.
 @param [cfg.reflectivity=1] {Number} Scalar in range 0-1 that controls how much {{#crossLink "CubeMap"}}CubeMap{{/crossLink}} is reflected.
 @param [cfg.lineWidth=1] {Number} Scalar that controls the width of lines for {{#crossLink "Geometry"}}{{/crossLink}} with {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "lines".
 @param [cfg.pointSize=1] {Number} Scalar that controls the size of points for {{#crossLink "Geometry"}}{{/crossLink}} with {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "points".
 @param [cfg.backfaces=false] {Boolean} Whether to render {{#crossLink "Geometry"}}Geometry{{/crossLink}} backfaces.
 @param [cfg.frontface="ccw"] {Boolean} The winding order for {{#crossLink "Geometry"}}Geometry{{/crossLink}} front faces - "cw" for clockwise, or "ccw" for counter-clockwise.
 */
(function () {

    "use strict";

    xeogl.LambertMaterial = xeogl.Material.extend({

        type: "xeogl.LambertMaterial",

        _init: function (cfg) {

            this._super(cfg);

            this._state = new xeogl.renderer.LambertMaterial({

                type: "LambertMaterial",

                ambient: xeogl.math.vec3([1.0, 1.0, 1.0]),
                color: xeogl.math.vec3([1.0, 1.0, 1.0]),
                emissive: xeogl.math.vec3([0.0, 0.0, 0.0]),

                alpha: null,
                alphaMode: 0, // 2 ("blend") when transparent, so renderer knows when to add to transparency bin

                lineWidth: null,
                pointSize: null,

                backfaces: null,
                frontface: null, // Boolean for speed; true == "ccw", false == "cw"

                hash: "/lam;"
            });

            this.ambient = cfg.ambient;
            this.color = cfg.color;
            this.emissive = cfg.emissive;
            this.alpha = cfg.alpha;

            this.lineWidth = cfg.lineWidth;
            this.pointSize = cfg.pointSize;

            this.backfaces = cfg.backfaces;
            this.frontface = cfg.frontface;
        },

        _props: {

            /**
             The LambertMaterial's ambient color.

             @property ambient
             @default [0.3, 0.3, 0.3]
             @type Float32Array
             */
            ambient: {

                set: function (value) {

                    var ambient = this._state.ambient;

                    if (!ambient) {
                        ambient = this._state.ambient = new Float32Array(3);

                    } else if (value && ambient[0] === value[0] && ambient[1] === value[1] && ambient[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        ambient[0] = value[0];
                        ambient[1] = value[1];
                        ambient[2] = value[2];

                    } else {
                        ambient[0] = .2;
                        ambient[1] = .2;
                        ambient[2] = .2;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.ambient;
                }
            },

            /**
             The LambertMaterial's diffuse color.

             @property color
             @default [1.0, 1.0, 1.0]
             @type Float32Array
             */
            color: {

                set: function (value) {

                    var color = this._state.color;

                    if (!color) {
                        color = this._state.color = new Float32Array(3);

                    } else if (value && color[0] === value[0] && color[1] === value[1] && color[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        color[0] = value[0];
                        color[1] = value[1];
                        color[2] = value[2];

                    } else {
                        color[0] = 1;
                        color[1] = 1;
                        color[2] = 1;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.color;
                }
            },

            /**
             The LambertMaterial's emissive color.

             @property emissive
             @default [0.0, 0.0, 0.0]
             @type Float32Array
             */
            emissive: {

                set: function (value) {

                    var emissive = this._state.emissive;

                    if (!emissive) {
                        emissive = this._state.emissive = new Float32Array(3);

                    } else if (value && emissive[0] === value[0] && emissive[1] === value[1] && emissive[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        emissive[0] = value[0];
                        emissive[1] = value[1];
                        emissive[2] = value[2];

                    } else {
                        emissive[0] = 0;
                        emissive[1] = 0;
                        emissive[2] = 0;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.emissive;
                }
            },

            /**
             Factor in the range [0..1] indicating how transparent the LambertMaterial is.

             A value of 0.0 indicates fully transparent, 1.0 is fully opaque.

             @property alpha
             @default 1.0
             @type Number
             */
            alpha: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 1.0;

                    if (this._state.alpha === value) {
                        return;
                    }

                    this._state.alpha = value;
                    this._state.alphaMode = value < 1.0 ? 2 /* blend */ : 0 /* opaque */

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.alpha;
                }
            },

            /**
             The LambertMaterial's line width.

             @property lineWidth
             @default 1.0
             @type Number
             */
            lineWidth: {

                set: function (value) {

                    this._state.lineWidth = value || 1.0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.lineWidth;
                }
            },

            /**
             The LambertMaterial's point size.

             @property pointSize
             @default 1.0
             @type Number
             */
            pointSize: {

                set: function (value) {

                    this._state.pointSize = value || 1.0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.pointSize;
                }
            },

            /**
             Whether backfaces are visible on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             The backfaces will belong to {{#crossLink "Geometry"}}{{/crossLink}} compoents that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             @property backfaces
             @default false
             @type Boolean
             */
            backfaces: {

                set: function (value) {

                    value = !!value;

                    if (this._state.backfaces === value) {
                        return;
                    }

                    this._state.backfaces = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.backfaces;
                }
            },

            /**
             Indicates the winding direction of front faces on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             The faces will belong to {{#crossLink "Geometry"}}{{/crossLink}} components that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             @property frontface
             @default "ccw"
             @type String
             */
            frontface: {

                set: function (value) {

                    value = value !== "cw";

                    if (this._state.frontface === value) {
                        return;
                    }

                    this._state.frontface = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.frontface ? "ccw" : "cw";
                }
            }
        },


        _getState: function () {
            return this._state;
        },

        _destroy: function () {
            this._super();
            this._state.destroy();
        }
    });

})();;/**
 A **SpecularMaterial** is a physically-based {{#crossLink "Material"}}{{/crossLink}} that defines the surface appearance of
 {{#crossLink "Entity"}}Entities{{/crossLink}} using the *specular-glossiness* workflow.

 ## Examples

 | <a href="../../examples/#importing_gltf_pbr_specular_telephone"><img src="../../assets/images/screenshots/SpecularMaterial/telephone.png"></img></a> | <a href="../../examples/#materials_specular_samples"><img src="../../assets/images/screenshots/SpecularMaterial/materials.png"></img></a> | <a href="../../examples/#materials_specular_textures"><img src="../../assets/images/screenshots/SpecularMaterial/textures.png"></img></a> | <a href="../../examples/#materials_specular_specularVsGlossiness"><img src="../../assets/images/screenshots/SpecularMaterial/specVsGloss.png"></img></a> |
 |:------:|:----:|:-----:|:-----:|
 |[glTF models with PBR materials](../../examples/#importing_gltf_pbr_specular_telephone)|[Sample materials ](../../examples/#materials_specular_samples) | [Texturing spec/gloss channels](../../examples/#materials_specular_textures) | [Specular Vs. glossiness](../../examples/#materials_specular_specularVsGlossiness) |

 ## Overview

 * SpecularMaterial is usually used for insulators, such as ceramic, wood and plastic.
 * {{#crossLink "MetallicMaterial"}}{{/crossLink}} is usually used for conductive materials, such as metal.
 * {{#crossLink "PhongMaterial"}}{{/crossLink}} is usually used for non-realistic objects.

 <img src="../../../assets/images/SpecularMaterial.png"></img>

 For an introduction to PBR concepts, try these articles:

 * Joe Wilson's [Basic Theory of Physically-Based Rendering](https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/)
 * Jeff Russel's [Physically-based Rendering, and you can too!](https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/)
 * Sebastien Legarde's [Adapting a physically-based shading model](http://seblagarde.wordpress.com/tag/physically-based-rendering/)

 The following table summarizes SpecularMaterial properties:

 | Property | Type | Range | Default Value | Space | Description |
 |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 |  {{#crossLink "SpecularMaterial/diffuse:property"}}{{/crossLink}} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the diffuse color of the material. |
 |  {{#crossLink "SpecularMaterial/specular:property"}}{{/crossLink}} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the specular color of the material. |
 | {{#crossLink "SpecularMaterial/glossiness:property"}}{{/crossLink}} | Number | [0, 1] | 1 | linear | The glossiness the material. |
 | {{#crossLink "SpecularMaterial/specularF0:property"}}{{/crossLink}} | Number | [0, 1] | 1 | linear | The specularF0 of the material surface. |
 |  {{#crossLink "SpecularMaterial/emissive:property"}}{{/crossLink}} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the emissive color of the material. |
 | {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 | {{#crossLink "SpecularMaterial/diffuseMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | sRGB | Texture RGB components multiplying by {{#crossLink "SpecularMaterial/diffuse:property"}}{{/crossLink}}. If the fourth component (A) is present, it multiplies by {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}}. |
 | {{#crossLink "SpecularMaterial/specularMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | sRGB | Texture RGB components multiplying by {{#crossLink "SpecularMaterial/specular:property"}}{{/crossLink}}. If the fourth component (A) is present, it multiplies by {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}}. |
 | {{#crossLink "SpecularMaterial/glossinessMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with first component multiplying by {{#crossLink "SpecularMaterial/glossiness:property"}}{{/crossLink}}. |
 | {{#crossLink "SpecularMaterial/specularGlossinessMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with first three components multiplying by {{#crossLink "SpecularMaterial/specular:property"}}{{/crossLink}} and fourth component multiplying by {{#crossLink "SpecularMaterial/glossiness:property"}}{{/crossLink}}. |
 | {{#crossLink "SpecularMaterial/emissiveMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with RGB components multiplying by {{#crossLink "SpecularMaterial/emissive:property"}}{{/crossLink}}. |
 | {{#crossLink "SpecularMaterial/alphaMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with first component multiplying by {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}}. |
 | {{#crossLink "SpecularMaterial/occlusionMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Ambient occlusion texture multiplying by surface's reflected diffuse and specular light. |
 | {{#crossLink "SpecularMaterial/normalMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Tangent-space normal map. |
 | {{#crossLink "SpecularMaterial/alphaMode:property"}}{{/crossLink}} | String | "opaque", "blend", "mask" | "blend" |  | Alpha blend mode. |
 | {{#crossLink "SpecularMaterial/alphaCutoff:property"}}{{/crossLink}} | Number | [0..1] | 0.5 |  | Alpha cutoff value. |
 | {{#crossLink "SpecularMaterial/backfaces:property"}}{{/crossLink}} | Boolean |  | false |  | Whether to render {{#crossLink "Geometry"}}Geometry{{/crossLink}} backfaces. |
 | {{#crossLink "SpecularMaterial/frontface:property"}}{{/crossLink}} | String | "ccw", "cw" | "ccw" |  | The winding order for {{#crossLink "Geometry"}}Geometry{{/crossLink}} frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |

 ## Usage

 In the example below we'll create the plastered sphere shown in the [Sample Materials](../../examples/#materials_specular_textures) example (see screenshots above).

 Here's a closeup of the sphere we'll create:

 <a href="../../examples/#materials_specular_samples"><img src="../../assets/images/screenshots/SpecularMaterial/plaster.png"></img></a>

 Our plastered sphere {{#crossLink "Entity"}}{{/crossLink}} has:

 * a {{#crossLink "SphereGeometry"}}{{/crossLink}},
 * a SpecularMaterial with {{#crossLink "Texture"}}Textures{{/crossLink}} providing diffuse, glossiness, specular and normal maps.

 We'll also provide its {{#crossLink "Scene"}}{{/crossLink}}'s {{#crossLink "Lights"}}{{/crossLink}} with
 {{#crossLink "DirLight"}}DirLights{{/crossLink}}, plus {{#crossLink "CubeTexture"}}CubeTextures{{/crossLink}} for light
 and reflection maps.

 Note that in this example we're providing separate {{#crossLink "Texture"}}Textures{{/crossLink}} for the {{#crossLink "SpecularMaterial/specular:property"}}{{/crossLink}} and {{#crossLink "SpecularMaterial/glossiness:property"}}{{/crossLink}}
 channels, which allows us a little creative flexibility. Then, in the next example further down, we'll combine those channels
 within the same {{#crossLink "Texture"}}{{/crossLink}} for efficiency.

 ````javascript
 var plasteredSphere = new xeogl.Entity({

    geometry: new xeogl.SphereGeometry({
        center: [0,0,0],
        radius: 1.5,
        heightSegments: 60,
        widthSegments: 60
    }),

    material: new xeogl.SpecularMaterial({

        // Channels with default values, just to show them

        diffuse: [1.0, 1.0, 1.0],
        specular: [1.0, 1.0, 1.0],
        glossiness: 1.0,
        emissive: [0.0, 0.0, 0.0]
        alpha: 1.0,

        // Textures to multiply some of the channels

        diffuseMap: {       // RGB components multiply by diffuse
            src: "textures/materials/poligon/Plaster07_1k/Plaster07_COL_VAR1_1K.jpg"
        },
        specularMap: {      // RGB component multiplies by specular
            src: "textures/materials/poligon/Plaster07_1k/Plaster07_REFL_1K.jpg"
        },
        glossinessMap: {    // R component multiplies by glossiness
            src: "textures/materials/poligon/Plaster07_1k/Plaster07_GLOSS_1K.jpg"
        },
        normalMap: {
            src: "textures/materials/poligon/Plaster07_1k/Plaster07_NRM_1K.jpg"
        }
    })
 });

 var scene = plasteredSphere.scene;

 scene.lights.lights = [
     new xeogl.DirLight({
         dir: [0.8, -0.6, -0.8],
         color: [0.8, 0.8, 0.8],
         space: "view"
     }),
     new xeogl.DirLight({
         dir: [-0.8, -0.4, -0.4],
         color: [0.4, 0.4, 0.5],
         space: "view"
     }),
     new xeogl.DirLight({
         dir: [0.2, -0.8, 0.8],
         color: [0.8, 0.8, 0.8],
         space: "view"
     }
 ];

 scene.lights.lightMap = new xeogl.CubeTexture({
     src: [
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PX.png",
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NX.png",
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PY.png",
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NY.png",
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PZ.png",
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NZ.png"
     ]
 });

 scene.lights.reflectionMap = new xeogl.CubeTexture({
     src: [
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PX.png",
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NX.png",
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PY.png",
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NY.png",
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PZ.png",
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NZ.png"
     ]
 });
 ````

 ### Combining channels within the same textures

 In the previous example we provided separate {{#crossLink "Texture"}}Textures{{/crossLink}} for the {{#crossLink "SpecularMaterial/specular:property"}}{{/crossLink}} and
 {{#crossLink "SpecularMaterial/glossiness:property"}}{{/crossLink}} channels, but we can combine those channels into the same {{#crossLink "Texture"}}{{/crossLink}} to reduce download time, memory footprint and rendering time (and also for glTF compatibility).

 Here's our SpecularMaterial again with those channels combined in the
 {{#crossLink "SpecularMaterial/specularGlossinessMap:property"}}{{/crossLink}} {{#crossLink "Texture"}}Texture{{/crossLink}}, where the
 *RGB* component multiplies by {{#crossLink "SpecularMaterial/specular:property"}}{{/crossLink}} and *A* multiplies by {{#crossLink "SpecularMaterial/glossiness:property"}}{{/crossLink}}.

 ````javascript
 plasteredSphere.material = new xeogl.SpecularMaterial({

    // Default values
    diffuse: [1.0, 1.0, 1.0],
    specular: [1.0, 1.0, 1.0],
    glossiness: 1.0,
    emissive: [0.0, 0.0, 0.0]
    alpha: 1.0,

    diffuseMap: {
        src: "textures/materials/poligon/Plaster07_1k/Plaster07_COL_VAR1_1K.jpg"
    },
    specularGlossinessMap: { // RGB multiplies by specular, A by glossiness
        src: "textures/materials/poligon/Plaster07_1k/Plaster07_REFL_GLOSS_1K.jpg"
    },
    normalMap: {
        src: "textures/materials/poligon/Plaster07_1k/Plaster07_NRM_1K.jpg"
    }
 });
 ````

 Although not shown in this example, we can also texture {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}} with
 the *A* component of {{#crossLink "SpecularMaterial/diffuseMap:property"}}{{/crossLink}}'s {{#crossLink "Texture"}}{{/crossLink}},
 if required.

 ## Transparency

 ### Alpha Blending

 Let's make our plastered sphere transparent. We'll update its SpecularMaterial's {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}}
 and {{#crossLink "SpecularMaterial/alphaMode:property"}}{{/crossLink}}, causing it to blend 50% with the background:

 ````javascript
 plasteredSphere.material.alpha = 0.5;
 plasteredSphere.material.alphaMode = "blend";
 ````

 *TODO: Screenshot*

 ### Alpha Masking

 Now let's make holes in our plastered sphere. We'll give its SpecularMaterial an {{#crossLink "SpecularMaterial/alphaMap:property"}}{{/crossLink}}
 and configure {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}}, {{#crossLink "SpecularMaterial/alphaMode:property"}}{{/crossLink}},
 and {{#crossLink "SpecularMaterial/alphaCutoff:property"}}{{/crossLink}} to treat it as an alpha mask:

 ````javascript
 plasteredSphere.material.alphaMap = new xeogl.Texture({
     src: "textures/diffuse/crossGridColorMap.jpg"
 });

 plasteredSphere.material.alpha = 1.0;
 plasteredSphere.material.alphaMode = "mask";
 plasteredSphere.material.alphaCutoff = 0.2;
 ````

 *TODO: Screenshot*

 @class SpecularMaterial
 @module xeogl
 @submodule materials
 @constructor
 @extends Material

 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this SpecularMaterial within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted

 @param [cfg] {*} The SpecularMaterial configuration

 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.

 @param [cfg.meta=null] {String:Object} Metadata to attach to this SpecularMaterial.

 @param [cfg.diffuse=[1,1,1]] {Float32Array}  RGB diffuse color of this SpecularMaterial. Multiplies by the RGB
 components of {{#crossLink "SpecularMaterial/diffuseMap:property"}}{{/crossLink}}.

 @param [cfg.diffuseMap=undefined] {Texture} RGBA {{#crossLink "Texture"}}{{/crossLink}} containing the diffuse color
 of this SpecularMaterial, with optional *A* component for alpha. The RGB components multiply by the
 {{#crossLink "SpecularMaterial/diffuse:property"}}{{/crossLink}} property,
 while the *A* component, if present, multiplies by the {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}} property.

 @param [cfg.specular=[1,1,1]] {Number} RGB specular color of this SpecularMaterial. Multiplies by the
 {{#crossLink "SpecularMaterial/specularMap:property"}}{{/crossLink}} and the *RGB* components of
 {{#crossLink "SpecularMaterial/specularGlossinessMap:property"}}{{/crossLink}}.

 @param [cfg.specularMap=undefined] {Texture} RGB texture containing the specular color of this SpecularMaterial. Multiplies
 by the {{#crossLink "SpecularMaterial/specular:property"}}{{/crossLink}} property. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

 @param [cfg.glossiness=1.0] {Number} Factor in the range [0..1] indicating how glossy this SpecularMaterial is. 0 is
 no glossiness, 1 is full glossiness. Multiplies by the *R* component of {{#crossLink "SpecularMaterial/glossinessMap:property"}}{{/crossLink}}
 and the *A* component of {{#crossLink "SpecularMaterial/specularGlossinessMap:property"}}{{/crossLink}}.

 @param [cfg.specularGlossinessMap=undefined] {Texture} RGBA {{#crossLink "Texture"}}{{/crossLink}} containing this
 SpecularMaterial's specular color in its *RGB* component and glossiness in its *A* component. Its *RGB* components multiply by the
 {{#crossLink "SpecularMaterial/specular:property"}}{{/crossLink}} property, while its *A* component multiplies by the
 {{#crossLink "SpecularMaterial/glossiness:property"}}{{/crossLink}} property. Must be within the same
 {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

 @param [cfg.specularF0=0.0] {Number} Factor in the range 0..1 indicating how reflective this SpecularMaterial is.

 @param [cfg.emissive=[0,0,0]] {Float32Array}  RGB emissive color of this SpecularMaterial. Multiplies by the RGB
 components of {{#crossLink "SpecularMaterial/emissiveMap:property"}}{{/crossLink}}.

 @param [cfg.emissiveMap=undefined] {Texture} RGB {{#crossLink "Texture"}}{{/crossLink}} containing the emissive color of this
 SpecularMaterial. Multiplies by the {{#crossLink "SpecularMaterial/emissive:property"}}{{/crossLink}} property.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

 @param [cfg.occlusionMap=undefined] {Texture} RGB ambient occlusion {{#crossLink "Texture"}}{{/crossLink}}. Within shaders,
 multiplies by the specular and diffuse light reflected by surfaces. Must be within the same {{#crossLink "Scene"}}{{/crossLink}}
 as this SpecularMaterial.

 @param [cfg.normalMap=undefined] {Texture} RGB tangent-space normal {{#crossLink "Texture"}}{{/crossLink}}. Must be
 within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

 @param [cfg.alpha=1.0] {Number} Factor in the range 0..1 indicating how transparent this SpecularMaterial is.
 A value of 0.0 indicates fully transparent, 1.0 is fully opaque. Multiplies by the *R* component of
 {{#crossLink "SpecularMaterial/alphaMap:property"}}{{/crossLink}} and the *A* component, if present, of
 {{#crossLink "SpecularMaterial/diffuseMap:property"}}{{/crossLink}}.

 @param [cfg.alphaMap=undefined] {Texture} RGB {{#crossLink "Texture"}}{{/crossLink}} containing this SpecularMaterial's
 alpha in its *R* component. The *R* component multiplies by the {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}} property. Must
 be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

 @param [cfg.alphaMode="opaque"] {String} The alpha blend mode - accepted values are "opaque", "blend" and "mask".
 See the {{#crossLink "SpecularMaterial/alphaMode:property"}}{{/crossLink}} property for more info.

 @param [cfg.alphaCutoff=0.5] {Number} The alpha cutoff value.
 See the {{#crossLink "SpecularMaterial/alphaCutoff:property"}}{{/crossLink}} property for more info.

 @param [cfg.backfaces=false] {Boolean} Whether to render {{#crossLink "Geometry"}}Geometry{{/crossLink}} backfaces.

 @param [cfg.frontface="ccw"] {Boolean} The winding order for {{#crossLink "Geometry"}}Geometry{{/crossLink}} front faces - "cw" for clockwise, or "ccw" for counter-clockwise.

 @param [cfg.lineWidth=1] {Number} Scalar that controls the width of lines for {{#crossLink "Geometry"}}{{/crossLink}} with {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "lines".
 @param [cfg.pointSize=1] {Number} Scalar that controls the size of points for {{#crossLink "Geometry"}}{{/crossLink}} with {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "points".

 */
(function () {

    "use strict";

    xeogl.SpecularMaterial = xeogl.Material.extend({

        type: "xeogl.SpecularMaterial",

        _init: function (cfg) {

            this._super(cfg);

            this._state = new xeogl.renderer.SpecularMaterial({
                type: "SpecularMaterial",
                diffuse: xeogl.math.vec3([1.0, 1.0, 1.0]),
                emissive: xeogl.math.vec3([0.0, 0.0, 0.0]),
                specular: xeogl.math.vec3([1.0, 1.0, 1.0]),
                glossiness: null,
                specularF0: null,
                alpha: null,

                diffuseMap: null,
                emissiveMap: null,
                specularMap: null,
                glossinessMap: null,
                specularGlossinessMap: null,
                occlusionMap: null,
                alphaMap: null,
                normalMap: null,
                alphaMode: null,
                alphaCutoff: null,
                lineWidth: null,
                pointSize: null,
                backfaces: null,
                frontface: null, // Boolean for speed; true == "ccw", false == "cw"
                hash: null
            });

            this._hashDirty = true;

            this.on("dirty", function () {

                // This SpecularMaterial is flagged dirty when a
                // child component fires "dirty", which always
                // means that a shader recompile will be needed.

                this._hashDirty = true;
            }, this);

            this.diffuse = cfg.diffuse;
            this.specular = cfg.specular;
            this.glossiness = cfg.glossiness;
            this.specularF0 = cfg.specularF0;
            this.emissive = cfg.emissive;
            this.alpha = cfg.alpha;

            if (cfg.diffuseMap) {
                this.diffuseMap = cfg.diffuseMap;
            }

            if (cfg.emissiveMap) {
                this.emissiveMap = cfg.emissiveMap;
            }

            if (cfg.specularMap) {
                this.specularMap = cfg.specularMap;
            }

            if (cfg.glossinessMap) {
                this.glossinessMap = cfg.glossinessMap;
            }

            if (cfg.specularGlossinessMap) {
                this.specularGlossinessMap = cfg.specularGlossinessMap;
            }

            if (cfg.occlusionMap) {
                this.occlusionMap = cfg.occlusionMap;
            }

            if (cfg.alphaMap) {
                this.alphaMap = cfg.alphaMap;
            }

            if (cfg.normalMap) {
                this.normalMap = cfg.normalMap;
            }

            this.alphaMode = cfg.alphaMode;
            this.alphaCutoff = cfg.alphaCutoff;
            this.backfaces = cfg.backfaces;
            this.frontface = cfg.frontface;

            this.lineWidth = cfg.lineWidth;
            this.pointSize = cfg.pointSize;
        },

        _props: {


            /**
             RGB diffuse color of this SpecularMaterial.

             Multiplies by the *RGB* components of {{#crossLink "SpecularMaterial/diffuseMap:property"}}{{/crossLink}}.

             @property diffuse
             @default [1.0, 1.0, 1.0]
             @type Float32Array
             */
            diffuse: {

                set: function (value) {

                    var diffuse = this._state.diffuse;

                    if (!diffuse) {
                        diffuse = this._state.diffuse = new Float32Array(3);

                    } else if (value && diffuse[0] === value[0] && diffuse[1] === value[1] && diffuse[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        diffuse[0] = value[0];
                        diffuse[1] = value[1];
                        diffuse[2] = value[2];

                    } else {
                        diffuse[0] = 1;
                        diffuse[1] = 1;
                        diffuse[2] = 1;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.diffuse;
                }
            },

            /**
             RGB {{#crossLink "Texture"}}{{/crossLink}} containing the diffuse color of this SpecularMaterial, with optional *A* component for alpha.

             The *RGB* components multiply by the {{#crossLink "SpecularMaterial/diffuse:property"}}{{/crossLink}} property,
             while the *A* component, if present, multiplies by the {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

             @property diffuseMap
             @default undefined
             @type {Texture}
             */
            diffuseMap: {

                set: function (texture) {

                    /**
                     Fired whenever this SpecularMaterial's {{#crossLink "SpecularMaterial/diffuseMap:property"}}{{/crossLink}} property changes.

                     @event diffuseMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "diffuseMap", texture);
                },

                get: function () {
                    return this._attached.diffuseMap;
                }
            },

            /**
             RGB specular color of this SpecularMaterial.

             Multiplies by the {{#crossLink "SpecularMaterial/specularMap:property"}}{{/crossLink}}
             and the *A* component of {{#crossLink "SpecularMaterial/specularGlossinessMap:property"}}{{/crossLink}}.

             @property specular
             @default [1.0, 1.0, 1.0]
             @type Float32Array
             */
            specular: {

                set: function (value) {

                    var specular = this._state.specular;

                    if (!specular) {
                        specular = this._state.specular = new Float32Array(3);

                    } else if (value && specular[0] === value[0] && specular[1] === value[1] && specular[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        specular[0] = value[0];
                        specular[1] = value[1];
                        specular[2] = value[2];

                    } else {
                        specular[0] = 1;
                        specular[1] = 1;
                        specular[2] = 1;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.specular;
                }
            },

            /**
             RGB texture containing the specular color of this SpecularMaterial.

             Multiplies by the {{#crossLink "SpecularMaterial/specular:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

             @property specularMap
             @default undefined
             @type {Texture}
             */
            specularMap: {

                set: function (texture) {

                    /**
                     Fired whenever this SpecularMaterial's {{#crossLink "SpecularMaterial/specularGlossinessMap:property"}}{{/crossLink}} property changes.

                     @event specularMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "specularMap", texture);
                },

                get: function () {
                    return this._attached.specularMap;
                }
            },

            /**
             RGBA texture containing this SpecularMaterial's specular color in its *RGB* components and glossiness in its *A* component.

             The *RGB* components multiply by the {{#crossLink "SpecularMaterial/specular:property"}}{{/crossLink}} property, while
             the *A* component multiplies by the {{#crossLink "SpecularMaterial/glossiness:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

             @property specularGlossinessMap
             @default undefined
             @type {Texture}
             */
            specularGlossinessMap: {

                set: function (texture) {

                    /**
                     Fired whenever this SpecularMaterial's {{#crossLink "SpecularMaterial/specularGlossinessMap:property"}}{{/crossLink}} property changes.

                     @event specularGlossinessMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "specularGlossinessMap", texture);
                },

                get: function () {
                    return this._attached.specularGlossinessMap;
                }
            },

            /**
             Factor in the range [0..1] indicating how glossy this SpecularMaterial is.

             0 is no glossiness, 1 is full glossiness.

             Multiplies by the *R* component of {{#crossLink "SpecularMaterial/glossinessMap:property"}}{{/crossLink}}
             and the *A* component of {{#crossLink "SpecularMaterial/specularGlossinessMap:property"}}{{/crossLink}}.

             @property glossiness
             @default 1.0
             @type Number
             */
            glossiness: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 1.0;

                    if (this._state.glossiness === value) {
                        return;
                    }

                    this._state.glossiness = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.glossiness;
                }
            },

            /**
             RGB texture containing this SpecularMaterial's glossiness in its *R* component.

             The *R* component multiplies by the {{#crossLink "SpecularMaterial/glossiness:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

             @property glossinessMap
             @default undefined
             @type {Texture}
             */
            glossinessMap: {

                set: function (texture) {

                    /**
                     Fired whenever this SpecularMaterial's {{#crossLink "SpecularMaterial/glossinessMap:property"}}{{/crossLink}} property changes.

                     @event glossinessMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "glossinessMap", texture);
                },

                get: function () {
                    return this._attached.glossinessMap;
                }
            },

            /**
             Factor in the range [0..1] indicating amount of specular Fresnel.

             @property specularF0
             @default 0.0
             @type Number
             */
            specularF0: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 0.0;

                    if (this._state.specularF0 === value) {
                        return;
                    }

                    this._state.specularF0 = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.specularF0;
                }
            },

            /**
             RGB emissive color of this SpecularMaterial.

             Multiplies by {{#crossLink "SpecularMaterial/emissiveMap:property"}}{{/crossLink}}.

             @property emissive
             @default [0.0, 0.0, 0.0]
             @type Float32Array
             */
            emissive: {

                set: function (value) {

                    var emissive = this._state.emissive;

                    if (!emissive) {
                        emissive = this._state.emissive = new Float32Array(3);

                    } else if (value && emissive[0] === value[0] && emissive[1] === value[1] && emissive[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        emissive[0] = value[0];
                        emissive[1] = value[1];
                        emissive[2] = value[2];

                    } else {
                        emissive[0] = 0;
                        emissive[1] = 0;
                        emissive[2] = 0;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.emissive;
                }
            },

            /**
             RGB texture containing the emissive color of this SpecularMaterial.

             Multiplies by the {{#crossLink "SpecularMaterial/emissive:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

             @property emissiveMap
             @default undefined
             @type {Texture}
             */
            emissiveMap: {

                set: function (texture) {

                    /**
                     Fired whenever this SpecularMaterial's {{#crossLink "SpecularMaterial/emissiveMap:property"}}{{/crossLink}} property changes.

                     @event emissiveMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "emissiveMap", texture);
                },

                get: function () {
                    return this._attached.emissiveMap;
                }
            },

            /**
             Factor in the range [0..1] indicating how transparent this SpecularMaterial is.

             A value of 0.0 is fully transparent, while 1.0 is fully opaque.

             Multiplies by the *R* component of {{#crossLink "SpecularMaterial/alphaMap:property"}}{{/crossLink}} and
             the *A* component, if present, of {{#crossLink "SpecularMaterial/diffuseMap:property"}}{{/crossLink}}.

             @property alpha
             @default 1.0
             @type Number
             */
            alpha: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 1.0;

                    if (this._state.alpha === value) {
                        return;
                    }

                    this._state.alpha = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.alpha;
                }
            },

            /**
             RGB {{#crossLink "Texture"}}{{/crossLink}} with alpha in its *R* component.

             The *R* component multiplies by the {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

             @property alphaMap
             @default undefined
             @type {Texture}
             */
            alphaMap: {

                set: function (texture) {
                    this._attachComponent("xeogl.Texture", "alphaMap", texture);
                },

                get: function () {
                    return this._attached.alphaMap;
                }
            },

            /**
             RGB tangent-space normal {{#crossLink "Texture"}}{{/crossLink}} attached to this SpecularMaterial.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

             @property normalMap
             @default undefined
             @type {Texture}
             */
            normalMap: {

                set: function (texture) {
                    this._attachComponent("xeogl.Texture", "normalMap", texture);
                },

                get: function () {
                    return this._attached.normalMap;
                }
            },

            /**
             RGB ambient occlusion {{#crossLink "Texture"}}{{/crossLink}} attached to this SpecularMaterial.

             Within objectRenderers, multiplies by the specular and diffuse light reflected by surfaces.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this SpecularMaterial.

             @property occlusionMap
             @default undefined
             @type {Texture}
             */
            occlusionMap: {

                set: function (texture) {
                    this._attachComponent("xeogl.Texture", "occlusionMap", texture);
                },

                get: function () {
                    return this._attached.occlusionMap;
                }
            },

            /**
             The alpha rendering mode.

             This governs how alpha is treated. Alpha is the combined result of the
             {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}} and
             {{#crossLink "SpecularMaterial/alphaMap:property"}}{{/crossLink}} properties.

             * "opaque" - The alpha value is ignored and the rendered output is fully opaque.
             * "mask" - The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value.
             * "blend" - The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator)

             @property alphaMode
             @default "opaque"
             @type {String}
             */
            alphaMode: (function () {
                var modes = {"opaque": 0, "mask": 1, "blend": 2};
                var modeNames = ["opaque", "mask", "blend"];
                return {
                    set: function (alphaMode) {

                        alphaMode = alphaMode || "opaque";

                        var value = modes[alphaMode];

                        if (value === undefined) {
                            this.error("Unsupported value for 'alphaMode': " + alphaMode + " defaulting to 'opaque'");
                            value = "opaque";
                        }

                        if (this._state.alphaMode === value) {
                            return;
                        }

                        this._state.alphaMode = value;

                        this._renderer.imageDirty();
                    },
                    get: function () {
                        return modeNames[this._state.alphaMode];
                    }
                };
            })(),

            /**
             The alpha cutoff value.

             Specifies the cutoff threshold when {{#crossLink "SpecularMaterial/alphaMode:property"}}{{/crossLink}}
             equals "mask". If the alpha is greater than or equal to this value then it is rendered as fully
             opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire
             material as fully transparent. This value is ignored for other modes.

             Alpha is the combined result of the
             {{#crossLink "SpecularMaterial/alpha:property"}}{{/crossLink}} and
             {{#crossLink "SpecularMaterial/alphaMap:property"}}{{/crossLink}} properties.

             @property alphaCutoff
             @default 0.5
             @type {Number}
             */
            alphaCutoff: {
                set: function (alphaCutoff) {

                    if (alphaCutoff === null || alphaCutoff === undefined) {
                        alphaCutoff = 0.5;
                    }

                    if (this._state.alphaCutoff === alphaCutoff) {
                        return;
                    }

                    this._state.alphaCutoff = alphaCutoff;
                },
                get: function () {
                    return this._state.alphaCutoff;
                }
            },


            /**
             Whether backfaces are visible on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             The backfaces will belong to {{#crossLink "Geometry"}}{{/crossLink}} compoents that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             @property backfaces
             @default false
             @type Boolean
             */
            backfaces: {

                set: function (value) {

                    value = !!value;

                    if (this._state.backfaces === value) {
                        return;
                    }

                    this._state.backfaces = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.backfaces;
                }
            },

            /**
             Indicates the winding direction of front faces on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             The faces will belong to {{#crossLink "Geometry"}}{{/crossLink}} components that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             @property frontface
             @default "ccw"
             @type String
             */
            frontface: {

                set: function (value) {

                    value = value !== "cw";

                    if (this._state.frontface === value) {
                        return;
                    }

                    this._state.frontface = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.frontface ? "ccw" : "cw";
                }
            },

            /**
             The SpecularMaterial's line width.

             @property lineWidth
             @default 1.0
             @type Number
             */
            lineWidth: {

                set: function (value) {

                    this._state.lineWidth = value || 1.0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.lineWidth;
                }
            },

            /**
             The SpecularMaterial's point size.

             @property pointSize
             @default 1
             @type Number
             */
            pointSize: {

                set: function (value) {

                    this._state.pointSize = value || 1;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.pointSize;
                }
            }
        },

        _attachComponent: function (expectedType, name, component) {
            component = this._attach({
                name: name,
                type: expectedType,
                component: component,
                sceneDefault: false,
                on: {
                    destroyed: {
                        callback: function () {
                            this._state[name] = null;
                            this._hashDirty = true;
                        },
                        scope: this
                    }
                }
            });
            this._state[name] = component ? component._state : null; // FIXME: Accessing _state breaks encapsulation
            this._hashDirty = true;
        },

        _getState: function () {
            if (this._hashDirty) {
                this._makeHash();
                this._hashDirty = false;
            }
            return this._state;
        },

        _makeHash: function () {

            var state = this._state;

            var hash = ["/spe"];

            if (state.diffuseMap) {
                hash.push("/dm");
                if (state.diffuseMap.matrix) {
                    hash.push("/mat");
                }
                hash.push("/" + state.diffuseMap.encoding);
            }

            if (state.emissiveMap) {
                hash.push("/em");
                if (state.emissiveMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.glossinessMap) {
                hash.push("/gm");
                if (state.glossinessMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.specularMap) {
                hash.push("/sm");
                if (state.specularMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.specularGlossinessMap) {
                hash.push("/sgm");
                if (state.specularGlossinessMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.occlusionMap) {
                hash.push("/ocm");
                if (state.occlusionMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.normalMap) {
                hash.push("/nm");
                if (state.normalMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.alphaMap) {
                hash.push("/opm");
                if (state.alphaMap.matrix) {
                    hash.push("/mat");
                }
            }

            hash.push(";");

            state.hash = hash.join("");
        },

        _destroy: function () {
            this._super();
            this._state.destroy();
        }
    });

})();;/**
 A **MetallicMaterial** is a physically-based {{#crossLink "Material"}}{{/crossLink}} that defines the surface appearance of
 {{#crossLink "Entity"}}Entities{{/crossLink}} using the *metallic-roughness* workflow.

 ## Examples

 | <a href="../../examples/#importing_gltf_pbr_metallic_helmet"><img src="../../assets/images/screenshots/MetallicMaterial/helmet.png"></img></a> | <a href="../../examples/#materials_metallic_fireHydrant"><img src="../../assets/images/screenshots/MetallicMaterial/hydrant3.png"></img></a> | <a href="../../examples/#materials_metallic_samples_metals"><img src="../../assets/images/screenshots/MetallicMaterial/metals.png"></img></a> | <a href="../../examples/#materials_metallic_metallicVsRoughness"><img alt="Metallic Vs Roughness" src="../../assets/images/screenshots/MetallicMaterial/metalVsRough.png"></img></a> |
 |:------:|:----:|:-----:|:-----:|
 |[glTF models with PBR materials](../../examples/#importing_gltf_pbr_metallic_helmet)|[Fire hydrant model](../../examples/#materials_metallic_fireHydrant)| [Sample metal materials ](../../examples/#materials_metallic_samples_metals)|[Metallic Vs. roughness](../../examples/#materials_metallic_metallicVsRoughness)|

 ## Overview

 * MetallicMaterial is usually used for conductive materials, such as metal.
 * {{#crossLink "SpecularMaterial"}}{{/crossLink}} is usually used for insulators, such as wood, ceramics and plastic.
 * {{#crossLink "PhongMaterial"}}{{/crossLink}} is usually used for non-realistic objects.

 <img src="../../../assets/images/MetallicMaterial.png"></img>

 For an introduction to PBR concepts, try these articles:

 * Joe Wilson's [Basic Theory of Physically-Based Rendering](https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/)
 * Jeff Russel's [Physically-based Rendering, and you can too!](https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/)
 * Sebastien Legarde's [Adapting a physically-based shading model](http://seblagarde.wordpress.com/tag/physically-based-rendering/)

 The following table summarizes MetallicMaterial properties:

 | Property | Type | Range | Default Value | Space | Description |
 |:--------:|:----:|:-----:|:-------------:|:-----:|:-----------:|
 | {{#crossLink "MetallicMaterial/baseColor:property"}}{{/crossLink}} | Array | [0, 1] for all components | [1,1,1,1] | linear | The RGB components of the base color of the material. |
 | {{#crossLink "MetallicMaterial/metallic:property"}}{{/crossLink}} | Number | [0, 1] | 1 | linear | The metallic-ness the material (1 for metals, 0 for non-metals). |
 | {{#crossLink "MetallicMaterial/roughness:property"}}{{/crossLink}} | Number | [0, 1] | 1 | linear | The roughness of the material surface. |
 | {{#crossLink "MetallicMaterial/specularF0:property"}}{{/crossLink}} | Number | [0, 1] | 1 | linear | The specular Fresnel of the material surface. |
 | {{#crossLink "MetallicMaterial/emissive:property"}}{{/crossLink}} | Array | [0, 1] for all components | [0,0,0] | linear | The RGB components of the emissive color of the material. |
 | {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}} | Number | [0, 1] | 1 | linear | The transparency of the material surface (0 fully transparent, 1 fully opaque). |
 | {{#crossLink "MetallicMaterial/baseColorMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | sRGB | Texture RGB components multiplying by {{#crossLink "MetallicMaterial/baseColor:property"}}{{/crossLink}}. If the fourth component (A) is present, it multiplies by {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}}. |
 | {{#crossLink "MetallicMaterial/metallicMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with first component multiplying by {{#crossLink "MetallicMaterial/metallic:property"}}{{/crossLink}}. |
 | {{#crossLink "MetallicMaterial/roughnessMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with first component multiplying by {{#crossLink "MetallicMaterial/roughness:property"}}{{/crossLink}}. |
 | {{#crossLink "MetallicMaterial/metallicRoughnessMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with first component multiplying by {{#crossLink "MetallicMaterial/metallic:property"}}{{/crossLink}} and second component multiplying by {{#crossLink "MetallicMaterial/roughness:property"}}{{/crossLink}}. |
 | {{#crossLink "MetallicMaterial/emissiveMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with RGB components multiplying by {{#crossLink "MetallicMaterial/emissive:property"}}{{/crossLink}}. |
 | {{#crossLink "MetallicMaterial/alphaMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Texture with first component multiplying by {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}}. |
 | {{#crossLink "MetallicMaterial/occlusionMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Ambient occlusion texture multiplying by surface's reflected diffuse and specular light. |
 | {{#crossLink "MetallicMaterial/normalMap:property"}}{{/crossLink}} | {{#crossLink "Texture"}}{{/crossLink}} |  | null | linear | Tangent-space normal map. |
 | {{#crossLink "MetallicMaterial/alphaMode:property"}}{{/crossLink}} | String | "opaque", "blend", "mask" | "blend" |  | Alpha blend mode. |
 | {{#crossLink "MetallicMaterial/alphaCutoff:property"}}{{/crossLink}} | Number | [0..1] | 0.5 |  | Alpha cutoff value. |
 | {{#crossLink "MetallicMaterial/backfaces:property"}}{{/crossLink}} | Boolean |  | false |  | Whether to render {{#crossLink "Geometry"}}Geometry{{/crossLink}} backfaces. |
 | {{#crossLink "MetallicMaterial/frontface:property"}}{{/crossLink}} | String | "ccw", "cw" | "ccw" |  | The winding order for {{#crossLink "Geometry"}}Geometry{{/crossLink}} frontfaces - "cw" for clockwise, or "ccw" for counter-clockwise. |

 ## Usage

 In the example below we'll create the [yellow fire hydrant](../../examples/#materials_metallic_fireHydrant) shown in the example screen shots above. Our hydrant {{#crossLink "Entity"}}{{/crossLink}} has:

 * a {{#crossLink "OBJGeometry"}}{{/crossLink}} which loads the fire hydrant mesh from an .OBJ file,
 * a MetallicMaterial with {{#crossLink "Texture"}}Textures{{/crossLink}} providing diffuse, metallic, roughness, occlusion and normal maps.

 We'll also provide its {{#crossLink "Scene"}}{{/crossLink}}'s {{#crossLink "Lights"}}{{/crossLink}} with
 {{#crossLink "DirLight"}}DirLights{{/crossLink}}, plus {{#crossLink "CubeTexture"}}CubeTextures{{/crossLink}} for light
 and reflection maps.

 Note that in this example we're providing separate {{#crossLink "Texture"}}Textures{{/crossLink}} for the {{#crossLink "MetallicMaterial/metallic:property"}}{{/crossLink}} and {{#crossLink "MetallicMaterial/roughness:property"}}{{/crossLink}}
 channels, which allows us a little creative flexibility. Then, in the next example further down, we'll combine those channels
 within the same {{#crossLink "Texture"}}{{/crossLink}} for efficiency.

 ````javascript
 var hydrant = new xeogl.Entity({

    geometry: new xeogl.OBJGeometry({
        src: "models/obj/FireHydrantMesh.obj"
    }),

    material: new xeogl.MetallicMaterial({

        // Channels with default values, just to show them

        baseColor: [1.0, 1.0, 1.0],
        metallic: 1.0,
        roughness: 1.0,
        emissive: [0.0, 0.0, 0.0],
        alpha: 1.0,

        // Textures to multiply by some of the channels

        baseColorMap : new xeogl.Texture({  // Multiplies by baseColor
            src: "textures/diffuse/fire_hydrant_Base_Color.png"
        }),

        metallicMap : new xeogl.Texture({   // R component multiplies by metallic
            src: "textures/metallic/fire_hydrant_Metallic.png"
        }),

        roughnessMap : new xeogl.Texture({  // R component multiplies by roughness
            src: "textures/roughness/fire_hydrant_Roughness.png"
        }),

        occlusionMap : new xeogl.Texture({  // Multiplies by fragment alpha
            src: "textures/occlusion/fire_hydrant_Mixed_AO.png"
        }),

        normalMap : new xeogl.Texture({
            src: "textures/normal/fire_hydrant_Normal_OpenGL.png"
        })
    })
 });

 var scene = hydrant.scene;

 scene.lights.lights = [
     new xeogl.DirLight({
         dir: [0.8, -0.6, -0.8],
         color: [0.8, 0.8, 0.8],
         space: "view"
     }),
     new xeogl.DirLight({
         dir: [-0.8, -0.4, -0.4],
         color: [0.4, 0.4, 0.5],
         space: "view"
     }),
     new xeogl.DirLight({
         dir: [0.2, -0.8, 0.8],
         color: [0.8, 0.8, 0.8],
         space: "view"
     }
 ];

 scene.lights.lightMap = new xeogl.CubeTexture({
     src: [
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PX.png",
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NX.png",
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PY.png",
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NY.png",
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_PZ.png",
         "textures/light/Uffizi_Gallery/Uffizi_Gallery_Irradiance_NZ.png"
     ]
 });

 scene.lights.reflectionMap = new xeogl.CubeTexture({
     src: [
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PX.png",
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NX.png",
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PY.png",
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NY.png",
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_PZ.png",
         "textures/reflect/Uffizi_Gallery/Uffizi_Gallery_Radiance_NZ.png"
     ]
 });
 ````

 ### Combining channels within the same textures

 In the previous example we provided separate {{#crossLink "Texture"}}Textures{{/crossLink}} for the {{#crossLink "MetallicMaterial/metallic:property"}}{{/crossLink}} and
 {{#crossLink "MetallicMaterial/roughness:property"}}{{/crossLink}} channels, but we can combine those channels into the same {{#crossLink "Texture"}}{{/crossLink}} to reduce download time, memory footprint and rendering time (and also for glTF compatibility).

 Here's our MetallicMaterial again with those channels combined in the
 {{#crossLink "MetallicMaterial/metallicRoughnessMap:property"}}{{/crossLink}} {{#crossLink "Texture"}}Texture{{/crossLink}}, where the
 *R* component multiplies by {{#crossLink "MetallicMaterial/metallic:property"}}{{/crossLink}} and *G* multiplies by {{#crossLink "MetallicMaterial/roughness:property"}}{{/crossLink}}.

 ````javascript
 hydrant.material = new xeogl.MetallicMaterial({

    baseColor: [1,1,1], // Default value
    metallic: 1.0,      // Default value
    roughness: 1.0,     // Default value

    baseColorMap : new xeogl.Texture({
        src: "textures/diffuse/fire_hydrant_Base_Color.png"
    }),
    metallicRoughnessMap : new xeogl.Texture({
        src: "textures/metallicRoughness/fire_hydrant_MetallicRoughness.png"
    }),
    occlusionMap : new xeogl.Texture({
        src: "textures/occlusion/fire_hydrant_Mixed_AO.png"
    }),
    normalMap : new xeogl.Texture({
        src: "textures/normal/fire_hydrant_Normal_OpenGL.png"
    })
 });
 ````

 Although not shown in this example, we can also texture {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}} with
 the *A* component of {{#crossLink "MetallicMaterial/baseColorMap:property"}}{{/crossLink}}'s {{#crossLink "Texture"}}{{/crossLink}},
 if required.

 ## Transparency

 ### Alpha Blending

 Let's make our hydrant transparent.

 We'll update its MetallicMaterial's {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}}
 and {{#crossLink "MetallicMaterial/alphaMode:property"}}{{/crossLink}}, causing it to blend 50% with the background:

 ````javascript
 hydrant.material.alpha = 0.5;
 hydrant.material.alphaMode = "blend";
 ````

 <img src="../../../assets/images/screenshots/MetallicMaterial/alphaBlend.png"></img>

 ### Alpha Masking

 Let's apply an alpha mask to our hydrant.

 We'll give its MetallicMaterial an {{#crossLink "MetallicMaterial/alphaMap:property"}}{{/crossLink}}
 and configure {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}}, {{#crossLink "MetallicMaterial/alphaMode:property"}}{{/crossLink}},
 and {{#crossLink "MetallicMaterial/alphaCutoff:property"}}{{/crossLink}} to treat it as an alpha mask:

 ````javascript
 hydrant.material.alphaMap = new xeogl.Texture({
        src: "textures/diffuse/crossGridColorMap.jpg"
    });

 hydrant.material.alpha = 1.0;
 hydrant.material.alphaMode = "mask";
 hydrant.material.alphaCutoff = 0.2;
 ````

 <img src="../../../assets/images/screenshots/MetallicMaterial/alphaMask.png"></img>

 @class MetallicMaterial
 @module xeogl
 @submodule materials
 @constructor
 @extends Material

 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this MetallicMaterial within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.

 @param [cfg] {*} The MetallicMaterial configuration.

 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.

 @param [cfg.meta=null] {String:Object} Metadata to attach to this material.

 @param [cfg.baseColor=[1,1,1]] {Float32Array}  RGB diffuse color of this MetallicMaterial. Multiplies by the RGB
 components of {{#crossLink "MetallicMaterial/baseColorMap:property"}}{{/crossLink}}.

 @param [cfg.metallic=1.0] {Number} Factor in the range 0..1 indicating how metallic this MetallicMaterial is.
 1 is metal, 0 is non-metal. Multiplies by the *R* component of {{#crossLink "MetallicMaterial/metallicMap:property"}}{{/crossLink}} and the *A* component of
 {{#crossLink "MetallicMaterial/metalRoughnessMap:property"}}{{/crossLink}}.

 @param [cfg.roughness=1.0] {Number} Factor in the range 0..1 indicating the roughness of this MetallicMaterial.
 0 is fully smooth, 1 is fully rough. Multiplies by the *R* component of {{#crossLink "MetallicMaterial/roughnessMap:property"}}{{/crossLink}}.

 @param [cfg.specularF0=0.0] {Number} Factor in the range 0..1 indicating specular Fresnel.

 @param [cfg.emissive=[0,0,0]] {Float32Array}  RGB emissive color of this MetallicMaterial. Multiplies by the RGB
 components of {{#crossLink "MetallicMaterial/emissiveMap:property"}}{{/crossLink}}.

 @param [cfg.alpha=1.0] {Number} Factor in the range 0..1 indicating the alpha of this MetallicMaterial.
 Multiplies by the *R* component of {{#crossLink "MetallicMaterial/alphaMap:property"}}{{/crossLink}} and the *A* component,
 if present, of {{#crossLink "MetallicMaterial/baseColorMap:property"}}{{/crossLink}}. The value of
 {{#crossLink "MetallicMaterial/alphaMode:property"}}{{/crossLink}} indicates how alpha is interpreted when rendering.

 @param [cfg.baseColorMap=undefined] {Texture} RGBA {{#crossLink "Texture"}}{{/crossLink}} containing the diffuse color
 of this MetallicMaterial, with optional *A* component for alpha. The RGB components multiply by the
 {{#crossLink "MetallicMaterial/baseColor:property"}}{{/crossLink}} property,
 while the *A* component, if present, multiplies by the {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}} property.

 @param [cfg.alphaMap=undefined] {Texture} RGB {{#crossLink "Texture"}}{{/crossLink}} containing this MetallicMaterial's
 alpha in its *R* component. The *R* component multiplies by the {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}} property. Must
 be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

 @param [cfg.metallicMap=undefined] {Texture} RGB {{#crossLink "Texture"}}{{/crossLink}} containing this MetallicMaterial's
 metallic factor in its *R* component. The *R* component multiplies by the
 {{#crossLink "MetallicMaterial/metallic:property"}}{{/crossLink}} property. Must be within the same
 {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

 @param [cfg.roughnessMap=undefined] {Texture} RGB {{#crossLink "Texture"}}{{/crossLink}} containing this MetallicMaterial's
 roughness factor in its *R* component. The *R* component multiplies by the
 {{#crossLink "MetallicMaterial/roughness:property"}}{{/crossLink}} property. Must be within the same
 {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

 @param [cfg.metallicRoughnessMap=undefined] {Texture} RGB {{#crossLink "Texture"}}{{/crossLink}} containing this
 MetallicMaterial's metalness in its *R* component and roughness in its *G* component. Its *R* component multiplies by the
 {{#crossLink "MetallicMaterial/metallic:property"}}{{/crossLink}} property, while its *G* component multiplies by the
 {{#crossLink "MetallicMaterial/roughness:property"}}{{/crossLink}} property. Must be within the same
 {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

 @param [cfg.emissiveMap=undefined] {Texture} RGB {{#crossLink "Texture"}}{{/crossLink}} containing the emissive color of this
 MetallicMaterial. Multiplies by the {{#crossLink "MetallicMaterial/emissive:property"}}{{/crossLink}} property.
 Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

 @param [cfg.occlusionMap=undefined] {Texture} RGB ambient occlusion {{#crossLink "Texture"}}{{/crossLink}}. Within shaders,
 multiplies by the specular and diffuse light reflected by surfaces. Must be within the same {{#crossLink "Scene"}}{{/crossLink}}
 as this MetallicMaterial.

 @param [cfg.normalMap=undefined] {Texture} RGB tangent-space normal {{#crossLink "Texture"}}{{/crossLink}}. Must be
 within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

 @param [cfg.alphaMode="opaque"] {String} The alpha blend mode, which specifies how alpha is to be interpreted. Accepted
 values are "opaque", "blend" and "mask". See the {{#crossLink "MetallicMaterial/alphaMode:property"}}{{/crossLink}} property for more info.

 @param [cfg.alphaCutoff=0.5] {Number} The alpha cutoff value.
 See the {{#crossLink "MetallicMaterial/alphaCutoff:property"}}{{/crossLink}} property for more info.

 @param [cfg.backfaces=false] {Boolean} Whether to render {{#crossLink "Geometry"}}Geometry{{/crossLink}} backfaces.
 @param [cfg.frontface="ccw"] {Boolean} The winding order for {{#crossLink "Geometry"}}Geometry{{/crossLink}} front faces - "cw" for clockwise, or "ccw" for counter-clockwise.

 @param [cfg.lineWidth=1] {Number} Scalar that controls the width of lines for {{#crossLink "Geometry"}}{{/crossLink}} with {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "lines".
 @param [cfg.pointSize=1] {Number} Scalar that controls the size of points for {{#crossLink "Geometry"}}{{/crossLink}} with {{#crossLink "Geometry/primitive:property"}}{{/crossLink}} set to "points".

 */
(function () {

    "use strict";

    xeogl.MetallicMaterial = xeogl.Material.extend({

        type: "xeogl.MetallicMaterial",

        _init: function (cfg) {

            this._super(cfg);

            this._state = new xeogl.renderer.MetallicMaterial({
                type: "MetallicMaterial",
                baseColor: xeogl.math.vec4([1.0, 1.0, 1.0]),
                emissive: xeogl.math.vec4([0.0, 0.0, 0.0]),
                metallic: null,
                roughness: null,
                specularF0: null,
                alpha: null,
                baseColorMap: null,
                alphaMap: null,
                metallicMap: null,
                roughnessMap: null,
                metallicRoughnessMap: null,
                emissiveMap: null,
                occlusionMap: null,
                normalMap: null,
                alphaMode: null, // "opaque"
                alphaCutoff: null,
                lineWidth: null,
                pointSize: null,
                backfaces: null,
                frontface: null, // Boolean for speed; true == "ccw", false == "cw"
                hash: null
            });

            this._hashDirty = true;

            this.on("dirty", function () {

                // This MetallicMaterial is flagged dirty when a
                // child component fires "dirty", which always
                // means that a shader recompile will be needed.

                this._hashDirty = true;
            }, this);

            this.baseColor = cfg.baseColor;
            this.metallic = cfg.metallic;
            this.roughness = cfg.roughness;
            this.specularF0 = cfg.specularF0;
            this.emissive = cfg.emissive;
            this.alpha = cfg.alpha;

            if (cfg.baseColorMap) {
                this.baseColorMap = cfg.baseColorMap;
            }

            if (cfg.metallicMap) {
                this.metallicMap = cfg.metallicMap;
            }

            if (cfg.roughnessMap) {
                this.roughnessMap = cfg.roughnessMap;
            }

            if (cfg.metallicRoughnessMap) {
                this.metallicRoughnessMap = cfg.metallicRoughnessMap;
            }

            if (cfg.emissiveMap) {
                this.emissiveMap = cfg.emissiveMap;
            }

            if (cfg.occlusionMap) {
                this.occlusionMap = cfg.occlusionMap;
            }

            if (cfg.alphaMap) {
                this.alphaMap = cfg.alphaMap;
            }

            if (cfg.normalMap) {
                this.normalMap = cfg.normalMap;
            }

            this.alphaMode = cfg.alphaMode;
            this.alphaCutoff = cfg.alphaCutoff;
            this.backfaces = cfg.backfaces;
            this.frontface = cfg.frontface;

            this.lineWidth = cfg.lineWidth;
            this.pointSize = cfg.pointSize;
        },

        _props: {

            /**
             RGB diffuse color of this MetallicMaterial.

             Multiplies by the RGB components of {{#crossLink "MetallicMaterial/baseColorMap:property"}}{{/crossLink}}.

             @property baseColor
             @default [1.0, 1.0, 1.0]
             @type Float32Array
             */
            baseColor: {

                set: function (value) {

                    var baseColor = this._state.baseColor;

                    if (!baseColor) {
                        baseColor = this._state.baseColor = new Float32Array(3);

                    } else if (value && baseColor[0] === value[0] && baseColor[1] === value[1] && baseColor[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        baseColor[0] = value[0];
                        baseColor[1] = value[1];
                        baseColor[2] = value[2];

                    } else {
                        baseColor[0] = 1;
                        baseColor[1] = 1;
                        baseColor[2] = 1;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.baseColor;
                }
            },

            /**
             RGB {{#crossLink "Texture"}}{{/crossLink}} containing the diffuse color of this MetallicMaterial, with optional *A* component for alpha.

             The RGB components multiply by the {{#crossLink "MetallicMaterial/baseColor:property"}}{{/crossLink}} property,
             while the *A* component, if present, multiplies by the {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

             @property baseColorMap
             @default undefined
             @type {Texture}
             */
            baseColorMap: {

                set: function (texture) {
                    this._attachComponent("xeogl.Texture", "baseColorMap", texture);
                },

                get: function () {
                    return this._attached.baseColorMap;
                }
            },

            /**
             Factor in the range [0..1] indicating how metallic this MetallicMaterial is.

             1 is metal, 0 is non-metal.

             Multiplies by the *R* component of {{#crossLink "MetallicMaterial/metallicMap:property"}}{{/crossLink}}
             and the *A* component of {{#crossLink "MetallicMaterial/metalRoughnessMap:property"}}{{/crossLink}}.

             @property metallic
             @default 1.0
             @type Number
             */
            metallic: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 1.0;

                    if (this._state.metallic === value) {
                        return;
                    }

                    this._state.metallic = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.metallic;
                }
            },

            /**
             RGB {{#crossLink "Texture"}}{{/crossLink}} containing this MetallicMaterial's metallic factor in its *R* component.

             The *R* component multiplies by the {{#crossLink "MetallicMaterial/metallic:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

             @property metallicMap
             @default undefined
             @type {Texture}
             */
            metallicMap: {

                set: function (texture) {
                    this._attachComponent("xeogl.Texture", "metallicMap", texture);
                },

                get: function () {
                    return this._attached.metallicMap;
                }
            },

            /**
             Factor in the range [0..1] indicating the roughness of this MetallicMaterial.

             0 is fully smooth, 1 is fully rough.

             Multiplies by the *R* component of {{#crossLink "MetallicMaterial/roughnessMap:property"}}{{/crossLink}}.

             @property roughness
             @default 1.0
             @type Number
             */
            roughness: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 1.0;

                    if (this._state.roughness === value) {
                        return;
                    }

                    this._state.roughness = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.roughness;
                }
            },

            /**
             RGB {{#crossLink "Texture"}}{{/crossLink}} containing this MetallicMaterial's roughness factor in its *R* component.

             The *R* component multiplies by the {{#crossLink "MetallicMaterial/roughness:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

             @property roughnessMap
             @default undefined
             @type {Texture}
             */
            roughnessMap: {

                set: function (texture) {
                    this._attachComponent("xeogl.Texture", "roughnessMap", texture);
                },

                get: function () {
                    return this._attached.roughnessMap;
                }
            },

            /**
             RGB {{#crossLink "Texture"}}{{/crossLink}} containing this MetallicMaterial's metalness in its *R* component and roughness in its *G* component.

             Its *B* component multiplies by the {{#crossLink "MetallicMaterial/metallic:property"}}{{/crossLink}} property, while
             its *G* component multiplies by the {{#crossLink "MetallicMaterial/roughness:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

             @property metallicRoughnessMap
             @default undefined
             @type {Texture}
             */
            metallicRoughnessMap: {

                set: function (texture) {
                    this._attachComponent("xeogl.Texture", "metallicRoughnessMap", texture);
                },

                get: function () {
                    return this._attached.metallicRoughnessMap;
                }
            },

            /**
             Factor in the range [0..1] indicating specular Fresnel value.

             @property specularF0
             @default 0.0
             @type Number
             */
            specularF0: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 0.0;

                    if (this._state.specularF0 === value) {
                        return;
                    }

                    this._state.specularF0 = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.specularF0;
                }
            },

            /**
             RGB emissive color of this MetallicMaterial.

             Multiplies by {{#crossLink "MetallicMaterial/emissiveMap:property"}}{{/crossLink}}.
             @property emissive
             @default [0.0, 0.0, 0.0]
             @type Float32Array
             */
            emissive: {

                set: function (value) {

                    var emissive = this._state.emissive;

                    if (!emissive) {
                        emissive = this._state.emissive = new Float32Array(3);

                    } else if (value && emissive[0] === value[0] && emissive[1] === value[1] && emissive[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        emissive[0] = value[0];
                        emissive[1] = value[1];
                        emissive[2] = value[2];

                    } else {
                        emissive[0] = 0;
                        emissive[1] = 0;
                        emissive[2] = 0;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.emissive;
                }
            },

            /**
             RGB {{#crossLink "Texture"}}{{/crossLink}} containing the emissive color of this MetallicMaterial.

             Multiplies by the {{#crossLink "MetallicMaterial/emissive:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

             @property emissiveMap
             @default undefined
             @type {Texture}
             */
            emissiveMap: {

                set: function (texture) {

                    /**
                     Fired whenever this MetallicMaterial's {{#crossLink "MetallicMaterial/emissiveMap:property"}}{{/crossLink}} property changes.

                     @event emissiveMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "emissiveMap", texture);
                },

                get: function () {
                    return this._attached.emissiveMap;
                }
            },

            /**
             RGB ambient occlusion {{#crossLink "Texture"}}{{/crossLink}} attached to this MetallicMaterial.

             Within objectRenderers, multiplies by the specular and diffuse light reflected by surfaces.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

             @property occlusionMap
             @default undefined
             @type {Texture}
             */
            occlusionMap: {

                set: function (texture) {

                    /**
                     Fired whenever this MetallicMaterial's {{#crossLink "MetallicMaterial/occlusionMap:property"}}{{/crossLink}} property changes.

                     @event occlusionMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "occlusionMap", texture);
                },

                get: function () {
                    return this._attached.occlusionMap;
                }
            },

            /**
             Factor in the range [0..1] indicating the alpha value.

             Multiplies by the *R* component of {{#crossLink "MetallicMaterial/alphaMap:property"}}{{/crossLink}} and
             the *A* component, if present, of {{#crossLink "MetallicMaterial/baseColorMap:property"}}{{/crossLink}}.

             The value of {{#crossLink "MetallicMaterial/alphaMode:property"}}{{/crossLink}} indicates how alpha is
             interpreted when rendering.

             @property alpha
             @default 1.0
             @type Number
             */
            alpha: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 1.0;

                    if (this._state.alpha === value) {
                        return;
                    }

                    this._state.alpha = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.alpha;
                }
            },

            /**
             RGB {{#crossLink "Texture"}}{{/crossLink}} containing this MetallicMaterial's alpha in its *R* component.

             The *R* component multiplies by the {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}} property.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

             @property alphaMap
             @default undefined
             @type {Texture}
             */
            alphaMap: {

                set: function (texture) {

                    /**
                     Fired whenever this MetallicMaterial's {{#crossLink "MetallicMaterial/alphaMap:property"}}{{/crossLink}} property changes.

                     @event alphaMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "alphaMap", texture);
                },

                get: function () {
                    return this._attached.alphaMap;
                }
            },

            /**
             RGB tangent-space normal map {{#crossLink "Texture"}}{{/crossLink}}.

             Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this MetallicMaterial.

             @property normalMap
             @default undefined
             @type {Texture}
             */
            normalMap: {

                set: function (texture) {

                    /**
                     Fired whenever this MetallicMaterial's {{#crossLink "MetallicMaterial/normalMap:property"}}{{/crossLink}} property changes.

                     @event normalMap
                     @param value Number The property's new value
                     */
                    this._attachComponent("xeogl.Texture", "normalMap", texture);
                },

                get: function () {
                    return this._attached.normalMap;
                }
            },

            /**
             The alpha rendering mode.

             This specifies how alpha is interpreted. Alpha is the combined result of the
             {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}} and
             {{#crossLink "MetallicMaterial/alphaMap:property"}}{{/crossLink}} properties.

             * "opaque" - The alpha value is ignored and the rendered output is fully opaque.
             * "mask" - The rendered output is either fully opaque or fully transparent depending on the alpha and {{#crossLink "MetallicMaterial/alphaCutoff:property"}}{{/crossLink}}.
             * "blend" - The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator).

             @property alphaMode
             @default "opaque"
             @type {String}
             */
            alphaMode: (function () {
                var modes = {"opaque": 0, "mask": 1, "blend": 2};
                var modeNames = ["opaque", "mask", "blend"];
                return {
                    set: function (alphaMode) {

                        alphaMode = alphaMode || "opaque";

                        var value = modes[alphaMode];

                        if (value === undefined) {
                            this.error("Unsupported value for 'alphaMode': " + alphaMode + " defaulting to 'opaque'");
                            value = "opaque";
                        }

                        if (this._state.alphaMode === value) {
                            return;
                        }

                        this._state.alphaMode = value;

                        this._renderer.imageDirty();
                    },
                    get: function () {
                        return modeNames[this._state.alphaMode];
                    }
                };
            })(),

            /**
             The alpha cutoff value.

             Specifies the cutoff threshold when {{#crossLink "MetallicMaterial/alphaMode:property"}}{{/crossLink}}
             equals "mask". If the alpha is greater than or equal to this value then it is rendered as fully
             opaque, otherwise, it is rendered as fully transparent. A value greater than 1.0 will render the entire
             material as fully transparent. This value is ignored for other modes.

             Alpha is the combined result of the
             {{#crossLink "MetallicMaterial/alpha:property"}}{{/crossLink}} and
             {{#crossLink "MetallicMaterial/alphaMap:property"}}{{/crossLink}} properties.

             @property alphaCutoff
             @default 0.5
             @type {Number}
             */
            alphaCutoff: {
                set: function (alphaCutoff) {

                    if (alphaCutoff === null || alphaCutoff === undefined) {
                        alphaCutoff = 0.5;
                    }

                    if (this._state.alphaCutoff === alphaCutoff) {
                        return;
                    }

                    this._state.alphaCutoff = alphaCutoff;
                },
                get: function () {
                    return this._state.alphaCutoff;
                }
            },

            /**
             Whether backfaces are visible on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             The backfaces will belong to {{#crossLink "Geometry"}}{{/crossLink}} compoents that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             @property backfaces
             @default false
             @type Boolean
             */
            backfaces: {

                set: function (value) {

                    value = !!value;

                    if (this._state.backfaces === value) {
                        return;
                    }

                    this._state.backfaces = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.backfaces;
                }
            },

            /**
             Indicates the winding direction of front faces on attached {{#crossLink "Entity"}}Entities{{/crossLink}}.

             The faces will belong to {{#crossLink "Geometry"}}{{/crossLink}} components that are also attached to
             the {{#crossLink "Entity"}}Entities{{/crossLink}}.

             @property frontface
             @default "ccw"
             @type String
             */
            frontface: {

                set: function (value) {

                    value = value !== "cw";

                    if (this._state.frontface === value) {
                        return;
                    }

                    this._state.frontface = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.frontface ? "ccw" : "cw";
                }
            },

            /**
             The MetallicMaterial's line width.

             @property lineWidth
             @default 1.0
             @type Number
             */
            lineWidth: {

                set: function (value) {

                    this._state.lineWidth = value || 1.0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.lineWidth;
                }
            },

            /**
             The MetallicMaterial's point size.

             @property pointSize
             @default 1.0
             @type Number
             */
            pointSize: {

                set: function (value) {

                    this._state.pointSize = value || 1.0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.pointSize;
                }
            }
        },

        _attachComponent: function (expectedType, name, component) {
            component = this._attach({
                name: name,
                type: expectedType,
                component: component,
                sceneDefault: false,
                on: {
                    destroyed: {
                        callback: function () {
                            this._state[name] = null;
                            this._hashDirty = true;
                        },
                        scope: this
                    }
                }
            });
            this._state[name] = component ? component._state : null; // FIXME: Accessing _state breaks encapsulation
            this._hashDirty = true;
        },

        _getState: function () {
            if (this._hashDirty) {
                this._makeHash();
                this._hashDirty = false;
            }
            return this._state;
        },

        _makeHash: function () {

            var state = this._state;

            var hash = ["/met"];

            if (state.baseColorMap) {
                hash.push("/bm");
                if (state.baseColorMap.matrix) {
                    hash.push("/mat");
                }
                hash.push("/" + state.baseColorMap.encoding);
            }

            if (state.metallicMap) {
                hash.push("/mm");
                if (state.metallicMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.roughnessMap) {
                hash.push("/rm");
                if (state.roughnessMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.metallicRoughnessMap) {
                hash.push("/mrm");
                if (state.metallicRoughnessMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.emissiveMap) {
                hash.push("/em");
                if (state.emissiveMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.occlusionMap) {
                hash.push("/ocm");
                if (state.occlusionMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.alphaMap) {
                hash.push("/am");
                if (state.alphaMap.matrix) {
                    hash.push("/mat");
                }
            }

            if (state.normalMap) {
                hash.push("/nm");
                if (state.normalMap.matrix) {
                    hash.push("/mat");
                }
            }

            hash.push(";");

            state.hash = hash.join("");
        },

        _destroy: function () {
            this._super();
            this._state.destroy();
        }
    });

})();;/**
 An **EmphasisMaterial** is a {{#crossLink "Material"}}{{/crossLink}} that defines the appearance of attached
 {{#crossLink "Entity"}}Entities{{/crossLink}} when they are highlighted, selected or ghosted.

 ## Examples

 | <a href="../../examples/#effects_ghost"><img src="../../assets/images/screenshots/HighlightMaterial/teapot.png"></img></a> | <a href="../../examples/#effects_demo_housePlan"><img src="../../assets/images/screenshots/HighlightMaterial/house.png"></img></a> | <a href="../../examples/#effects_demo_gearbox"><img src="../../assets/images/screenshots/HighlightMaterial/gearbox.png"></img></a> | <a href="../../examples/#effects_demo_adam"><img src="../../assets/images/screenshots/HighlightMaterial/adam.png"></img></a>|
 |:------:|:------:|:----:|:-----:|:-----:|
 |[Example 1: Ghost effect](../../examples/#effects_ghost)|[Example 2: Ghost and highlight effects for architecture](../../examples/#effects_demo_housePlan)|[Example 3: Ghost and highlight effects for CAD](../../examples/#effects_demo_gearbox)| [Example 4: Ghost effect for CAD ](../../examples//#effects_demo_adam)|

 ## Overview

 * Ghost an {{#crossLink "Entity"}}{{/crossLink}} by setting its {{#crossLink "Entity/ghost:property"}}{{/crossLink}} property ````true````.
 * When ghosted, an Entity's appearance is controlled by its EmphasisMaterial.
 * An EmphasisMaterial provides several preset configurations that you can set it to. Select a preset by setting {{#crossLink "EmphasisMaterial/preset:property"}}{{/crossLink}} to the preset's ID. A map of available presets is provided in {{#crossLink "EmphasisMaterial/presets:property"}}xeogl.EmphasisMaterial.presets{{/crossLink}}.
 * By default, an Entity uses the {{#crossLink "Scene"}}{{/crossLink}}'s global EmphasisMaterials, but you can give each Entity its own EmphasisMaterial when you want to customize the effect per-Entity.
 * Ghost all Entities in a {{#crossLink "Model"}}{{/crossLink}} by setting the Model's {{#crossLink "Model/ghost:property"}}{{/crossLink}} property ````true````. Note that all Entities in a Model have the Scene's global EmphasisMaterial by default.
 * Modify the Scene's global EmphasisMaterial to customize it.

 ## Usage

 * [Ghosting](#ghosting)
 * [Highlighting](#highlighting)

 ### Ghosting

 In the usage example below, we'll create an Entity with a ghost effect applied to it. The Entity gets its own EmphasisMaterial for ghosting, and
 has its {{#crossLink "Entity/ghost:property"}}{{/crossLink}} property set ````true```` to activate the effect.

 <a href="../../examples/#effects_ghost"><img src="../../assets/images/screenshots/HighlightMaterial/teapot.png"></img></a>

 ````javascript
 var entity = new xeogl.Entity({
    geometry: new xeogl.TeapotGeometry({
        ghostEdgeThreshold: 1
    }),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    ghostMaterial: new xeogl.EmphasisMaterial({
        edges: true,
        edgeColor: [0.2, 1.0, 0.2],
        edgeAlpha: 1.0,
        edgeWidth: 2,
        vertices: true,
        vertexColor: [0.6, 1.0, 0.6],
        vertexAlpha: 1.0,
        vertexSize: 8,
        fill: true,
        fillColor: [0, 0, 0],
        fillAlpha: 0.7
    }),
    ghost: true
 });
 ````

 Note the **ghostEdgeThreshold** configuration on the {{#crossLink "Geometry"}}{{/crossLink}} we've created for our
 Entity. Our EmphasisMaterial is configured to draw a wireframe representation of the Geometry, which will have inner edges (ie. edges between
 adjacent co-planar triangles) removed for visual clarity. The ````ghostEdgeThreshold```` configuration indicates
 that, for this particular Geometry, an inner edge is one where the angle between the surface normals of adjacent triangles is not
 greater than ````5```` degrees. That's set to ````2```` by default, but we can override it to tweak the effect as needed for particular Geometries.

 Here's the example again, this time using the Scene's global EmphasisMaterial by default. We'll also modify that EmphasisMaterial
 to customize the effect.

 ````javascript
 var entity = new xeogl.Entity({
    geometry: new xeogl.TeapotGeometry({
        ghostEdgeThreshold: 5
    }),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    ghost: true
 });

 var ghostMaterial = entity.scene.ghostMaterial;

 ghostMaterial.edges = true;
 ghostMaterial.edgeColor = [0.2, 1.0, 0.2];
 ghostMaterial.edgeAlpha = 1.0;
 ghostMaterial.edgeWidth = 2;
 ghostMaterial.vertices = true;
 ghostMaterial.vertexColor = [0.6, 1.0, 0.6];
 ghostMaterial.vertexAlpha = 1.0;
 ghostMaterial.vertexSize = 8;
 ghostMaterial.fill = true;
 ghostMaterial.fillColor = [0, 0, 0];
 ghostMaterial.fillAlpha = 0.7;
 ````

 ### Highlighting

 In the next example, we'll use a ghosting in conjunction with highlighting, to emphasise a couple of objects within
 a gearbox {{#crossLink "Model"}}{{/crossLink}}. We'll load the Model from glTF, then ghost all of its Entities except for two gears, which we'll highlight instead. The ghosted
 Entities have the Scene's global ghosting EmphasisMaterial, which we'll modify. The  highlighted Entities also have the Scene's global highlighting EmphasisMaterial, which we'll modify as well.

 <a href="../../examples/#effects_demo_gearbox"><img src="../../assets/images/screenshots/HighlightMaterial/gearbox.png"></img></a>

 ````javascript
 var model = new xeogl.GLTFModel({
     src: "models/gltf/gearbox_conical/scene.gltf",
     ghostEdgeThreshold: 10
 });

 model.on("loaded", function() {

    model.ghost = true;

    model.entities["gearbox#77.0"].ghost = false;
    model.entities["gearbox#79.0"].ghost = false;

    model.entities["gearbox#77.0"].highlight = true;
    model.entities["gearbox#79.0"].highlight = true;

    var ghostMaterial = model.scene.ghostMaterial;

    ghostMaterial.edges = true;
    ghostMaterial.edgeColor = [0.4, 0.4, 1.6];
    ghostMaterial.edgeAlpha = 0.8;
    ghostMaterial.edgeWidth = 3;
    ghostMaterial.vertices = false;
    ghostMaterial.vertexColor = [0.7, 1.0, 0.7];
    ghostMaterial.vertexAlpha = 0.9;
    ghostMaterial.vertexSize = 4.0;
    ghostMaterial.fill = true;
    ghostMaterial.fillColor = [0.2, 0.2, 0.7];
    ghostMaterial.fillAlpha = 0.9;

    var highlightMaterial = model.scene.highlightMaterial;

    highlightMaterial.color = [1.0, 1.0, 1.0];
    highlightMaterial.alpha = 1.0;
 });
 ````

 ## Presets

 For convenience, an EmphasisMaterial provides several preset configurations that you can set it to, which are provided in
 {{#crossLink "EmphasisMaterial/presets:property"}}xeogl.EmphasisMaterial.presets{{/crossLink}}:

 ````javascript
 var presets = xeogl.EmphasisMaterial.presets;
 ````

 The presets look something like this:

 ````json
 {
        "default": {
            edges: true,
            edgeColor: [0.2, 0.2, 0.2],
            edgeAlpha: 0.5,
            edgeWidth: 1,
            vertices: false,
            vertexColor: [0.4, 0.4, 0.4],
            vertexAlpha: 0.7,
            vertexSize: 4.0,
            fill: true,
            fillColor: [0.4, 0.4, 0.4],
            fillAlpha: 0.2
        },

         "sepia": {
            edges: true,
            edgeColor: [0.52, 0.45, 0.41],
            edgeAlpha: 1.0,
            edgeWidth: 1,
            vertices: false,
            vertexColor: [0.7, 1.0, 0.7],
            vertexAlpha: 0.9,
            vertexSize: 4.0,
            fill: true,
            fillColor: [0.97, 0.79, 0.66],
            fillAlpha: 0.4
        },

        //...
 }
 ````

 Let's switch the Scene's global default  EmphasisMaterial over to the "sepia" preset used in <a href="/examples/#effects_demo_adam">Example 4: Ghost effect for CAD</a>.

 ````javascript
 scene.ghostMaterial.preset = "sepia";
 ````

 You can also just create an EmphasisMaterial from a preset:

 ````javascript
 var entity = new xeogl.Entity({
    geometry: new xeogl.TeapotGeometry({
        ghostEdgeThreshold: 5
    }),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    ghostMaterial: new xeogl.EmphasisMaterial({
        preset: "sepia"
    });
    ghost: true
 });
 ````

 Note that applying a preset just sets the EmphasisMaterial's property values, which you are then free to modify afterwards.

 @class EmphasisMaterial
 @module xeogl
 @submodule materials
 @constructor
 @extends Material
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this EmphasisMaterial within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The EmphasisMaterial configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta=null] {String:Object} Metadata to attach to this EmphasisMaterial.

 @param [cfg.edges=true] {Boolean} Indicates whether or not ghost edges are visible.
 @param [cfg.edgeColor=[0.2,0.2,0.2]] {Array of Number}  RGB color of ghost edges.
 @param [cfg.edgeAlpha=0.5] {Number} Transparency of ghost edges. A value of 0.0 indicates fully transparent, 1.0 is fully opaque.
 @param [cfg.edgeWidth=1] {Number}  Width of ghost edges, in pixels.

 @param [cfg.vertices=false] {Boolean} Indicates whether or not ghost vertices are visible.
 @param [cfg.vertexColor=[0.4,0.4,0.4]] {Array of Number} Color of ghost vertices.
 @param [cfg.vertexAlpha=0.7] {Number}  Transparency of ghost vertices. A value of 0.0 indicates fully transparent, 1.0 is fully opaque.
 @param [cfg.vertexSize=4.0] {Number} Pixel size of ghost vertices.

 @param [cfg.fill=true] {Boolean} Indicates whether or not ghost surfaces are filled with color.
 @param [cfg.fillColor=[0.4,0.4,0.4]] {Array of Number} EmphasisMaterial fill color.
 @param [cfg.fillAlpha=0.2] {Number}  Transparency of filled ghost faces. A value of 0.0 indicates fully transparent, 1.0 is fully opaque.

 @param [cfg.preset] {String} Selects a preset EmphasisMaterial configuration - see {{#crossLink "EmphasisMaterial/preset:method"}}preset(){{/crossLink}}.
 */
(function () {

    "use strict";

    xeogl.EmphasisMaterial = xeogl.Material.extend({

        type: "xeogl.EmphasisMaterial",

        _init: function (cfg) {

            this._super(cfg);

            this._state = new xeogl.renderer.EmphasisMaterial({

                type: "EmphasisMaterial",

                edges: null,
                edgeColor: null,
                edgeAlpha: null,
                edgeWidth: null,

                vertices: null,
                vertexColor: null,
                vertexAlpha: null,
                vertexSize: null,

                fill: null,
                fillColor: null,
                fillAlpha: null
            });

            this._preset = "default";

            if (cfg.preset) {

                this.preset = cfg.preset;

                if (cfg.edges !== undefined) this.edges = cfg.edges;
                if (cfg.edgeColor)  this.edgeColor = cfg.edgeColor;
                if (cfg.edgeAlpha !== undefined) this.edgeAlpha = cfg.edgeAlpha;
                if (cfg.edgeWidth !== undefined) this.edgeWidth = cfg.edgeWidth;
                if (cfg.vertices !== undefined) this.vertices = cfg.vertices;
                if (cfg.vertexColor) this.vertexColor = cfg.vertexColor;
                if (cfg.vertexAlpha !== undefined) this.vertexAlpha = cfg.vertexAlpha;
                if (cfg.vertexSize) this.vertexSize = cfg.vertexSize;
                if (cfg.fill !== undefined) this.fill = cfg.fill;
                if (cfg.fillColor) this.fillColor = cfg.fillColor;
                if (cfg.fillAlpha !== undefined) this.fillAlpha = cfg.fillAlpha;
            } else {
                this.edges = cfg.edges;
                this.edgeColor = cfg.edgeColor;
                this.edgeAlpha = cfg.edgeAlpha;
                this.edgeWidth = cfg.edgeWidth;
                this.vertices = cfg.vertices;
                this.vertexColor = cfg.vertexColor;
                this.vertexAlpha = cfg.vertexAlpha;
                this.vertexSize = cfg.vertexSize;
                this.fill = cfg.fill;
                this.fillColor = cfg.fillColor;
                this.fillAlpha = cfg.fillAlpha;
            }
        },

        _props: {

            /**
             Indicates whether or not ghost edges are visible.

             @property edges
             @default true
             @type Boolean
             */
            edges: {

                set: function (value) {
                    value = value !== false;
                    if (this._state.edges === value) {
                        return;
                    }
                    this._state.edges = value;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.edges;
                }
            },

            /**
             RGB color of ghost edges.

             @property edgeColor
             @default [0.2, 0.2, 0.2]
             @type Float32Array
             */
            edgeColor: {

                set: function (value) {

                    var edgeColor = this._state.edgeColor;

                    if (!edgeColor) {
                        edgeColor = this._state.edgeColor = new Float32Array(3);

                    } else if (value && edgeColor[0] === value[0] && edgeColor[1] === value[1] && edgeColor[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        edgeColor[0] = value[0];
                        edgeColor[1] = value[1];
                        edgeColor[2] = value[2];

                    } else {
                        edgeColor[0] = 0.2;
                        edgeColor[1] = 0.2;
                        edgeColor[2] = 0.2;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.edgeColor;
                }
            },

            /**
             Transparency of ghost edges.

             A value of 0.0 indicates fully transparent, 1.0 is fully opaque.

             @property edgeAlpha
             @default 0.5
             @type Number
             */
            edgeAlpha: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 0.5;

                    if (this._state.edgeAlpha === value) {
                        return;
                    }

                    this._state.edgeAlpha = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.edgeAlpha;
                }
            },

            /**
             Width of ghost edges, in pixels.

             @property edgeWidth
             @default 1.0
             @type Number
             */
            edgeWidth: {

                set: function (value) {

                    this._state.edgeWidth = value || 1.0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.edgeWidth;
                }
            },

            /**
             Indicates whether or not ghost vertices are visible.

             @property vertices
             @default false
             @type Boolean
             */
            vertices: {

                set: function (value) {
                    value = !!value;
                    if (this._state.vertices === value) {
                        return;
                    }
                    this._state.vertices = value;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.vertices;
                }
            },

            /**
             Color of ghost vertices.

             @property vertexColor
             @default [0.4,0.4,0.4]
             @type Float32Array
             */
            vertexColor: {

                set: function (value) {
                    var vertexColor = this._state.vertexColor;
                    if (!vertexColor) {
                        vertexColor = this._state.vertexColor = new Float32Array(3);
                    } else if (value && vertexColor[0] === value[0] && vertexColor[1] === value[1] && vertexColor[2] === value[2]) {
                        return;
                    }
                    if (value) {
                        vertexColor[0] = value[0];
                        vertexColor[1] = value[1];
                        vertexColor[2] = value[2];
                    } else {
                        vertexColor[0] = 0.4;
                        vertexColor[1] = 0.4;
                        vertexColor[2] = 0.4;
                    }
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.vertexColor;
                }
            },

            /**
             Transparency of ghost vertices.

             A value of 0.0 indicates fully transparent, 1.0 is fully opaque.

             @property vertexAlpha
             @default 0.7
             @type Number
             */
            vertexAlpha: {

                set: function (value) {
                    value = (value !== undefined && value !== null) ? value : 0.7;
                    if (this._state.vertexAlpha === value) {
                        return;
                    }
                    this._state.vertexAlpha = value;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.vertexAlpha;
                }
            },

            /**
             Pixel size of ghost vertices.

             @property vertexSize
             @default 4.0
             @type Number
             */
            vertexSize: {
                set: function (value) {
                    this._state.vertexSize = value || 4.0;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.vertexSize;
                }
            },

            /**
             Indicates whether or not ghost surfaces are filled with color.

             @property fill
             @default true
             @type Boolean
             */
            fill: {

                set: function (value) {
                    value = value !== false;
                    if (this._state.fill === value) {
                        return;
                    }
                    this._state.fill = value;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.fill;
                }
            },

            /**
             RGB color of filled ghost faces.

             @property fillColor
             @default [0.4, 0.4, 0.4]
             @type Float32Array
             */
            fillColor: {

                set: function (value) {

                    var fillColor = this._state.fillColor;

                    if (!fillColor) {
                        fillColor = this._state.fillColor = new Float32Array(3);

                    } else if (value && fillColor[0] === value[0] && fillColor[1] === value[1] && fillColor[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        fillColor[0] = value[0];
                        fillColor[1] = value[1];
                        fillColor[2] = value[2];

                    } else {
                        fillColor[0] = 0.4;
                        fillColor[1] = 0.4;
                        fillColor[2] = 0.4;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.fillColor;
                }
            },

            /**
             Transparency of filled ghost faces.

             A value of 0.0 indicates fully transparent, 1.0 is fully opaque.

             @property fillAlpha
             @default 0.2
             @type Number
             */
            fillAlpha: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 0.2;

                    if (this._state.fillAlpha === value) {
                        return;
                    }

                    this._state.fillAlpha = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.fillAlpha;
                }
            },


            /**
             Selects a preset EmphasisMaterial configuration.

             Available presets are:

             * "default" - grey wireframe with translucent fill, for light backgrounds.
             * "defaultLightBG" - grey wireframe with grey translucent fill, for light backgrounds.
             * "defaultDarkBG" - grey wireframe with grey translucent fill, for dark backgrounds.
             * "vectorscope" - green wireframe with glowing vertices and black translucent fill.
             * "battlezone" - green wireframe with black opaque fill, giving a solid hidden-lines-removed effect.
             * "sepia" - light red-grey wireframe with light sepia translucent fill - easy on the eyes.
             * "gamegrid" - light blue wireframe with dark blue translucent fill - reminiscent of Tron.
             * "yellowHighlight" - light yellow translucent fill - highlights while allowing underlying detail to show through.

             @property preset
             @default "default"
             @type String
             */
            preset: {

                set: function (value) {
                    value = value || "default";
                    if (this._preset === value) {
                        return;
                    }
                    var preset = xeogl.EmphasisMaterial.presets[value];
                    if (!preset) {
                        this.error("unsupported preset: '" + value + "' - supported values are " + Object.keys(xeogl.EmphasisMaterial.presets).join(", "));
                        return;
                    }
                    this.edges = preset.edges;
                    this.edgeColor = preset.edgeColor;
                    this.edgeAlpha = preset.edgeAlpha;
                    this.edgeWidth = preset.edgeWidth;
                    this.vertices = preset.vertices;
                    this.vertexColor = preset.vertexColor;
                    this.vertexAlpha = preset.vertexAlpha;
                    this.vertexSize = preset.vertexSize;
                    this.fill = preset.fill;
                    this.fillColor = preset.fillColor;
                    this.fillAlpha = preset.fillAlpha;
                    this._preset = value;
                },

                get: function () {
                    return this._preset;
                }
            }
        },

        _getState: function () {
            return this._state;
        },

        _destroy: function () {
            this._super();
            this._state.destroy();
        }
    });

    /**
     Available EmphasisMaterial presets.

     @property presets
     @type {Object}
     @static
     */
    xeogl.EmphasisMaterial.presets = {

        "default": {
            edges: true,
            edgeColor: [0.2, 0.2, 0.2],
            edgeAlpha: 0.5,
            edgeWidth: 1,
            vertices: false,
            vertexColor: [0.4, 0.4, 0.4],
            vertexAlpha: 0.7,
            vertexSize: 4.0,
            fill: true,
            fillColor: [0.4, 0.4, 0.4],
            fillAlpha: 0.2
        },

        "defaultWhiteBG": {
            edgeColor: [0.2, 0.2, 0.2],
            edgeAlpha: 1.0,
            edgeWidth: 1,
            vertices: false,
            vertexColor: [0.4, 0.4, 0.4],
            vertexAlpha: 0.7,
            vertexSize: 4.0,
            fill: true,
            fillColor: [1, 1, 1],
            fillAlpha: 0.6
        },

        "defaultLightBG": {
            edges: true,
            edgeColor: [0.2, 0.2, 0.2],
            edgeAlpha: 0.5,
            edgeWidth: 1,
            vertices: false,
            vertexColor: [0.4, 0.4, 0.4],
            vertexAlpha: 0.7,
            vertexSize: 4.0,
            fill: true,
            fillColor: [0.4, 0.4, 0.4],
            fillAlpha: 0.2
        },

        "defaultDarkBG": {
            edges: true,
            edgeColor: [0.5, 0.5, 0.5],
            edgeAlpha: 0.5,
            edgeWidth: 1,
            vertices: false,
            vertexColor: [0.4, 0.4, 0.4],
            vertexAlpha: 0.7,
            vertexSize: 4.0,
            fill: true,
            fillColor: [0.4, 0.4, 0.4],
            fillAlpha: 0.2
        },

        "phosphorous": {
            edges: true,
            edgeColor: [0.9, 0.9, 0.9],
            edgeAlpha: 0.5,
            edgeWidth: 2,
            vertices: false,
            vertexColor: [0.4, 0.4, 0.4],
            vertexAlpha: 0.7,
            vertexSize: 1.0,
            fill: true,
            fillColor: [0.0, 0.0, 0.0],
            fillAlpha: 0.4
        },

        "sunset": {
            edges: true,
            edgeColor: [0.9, 0.9, 0.9],
            edgeAlpha: 0.5,
            edgeWidth: 1,
            vertices: false,
            vertexColor: [0.4, 0.4, 0.4],
            vertexAlpha: 0.7,
            vertexSize: 1.0,
            fill: true,
            fillColor: [0.9, 0.9, 0.6],
            fillAlpha: 0.2
        },

        "vectorscope": {
            edges: true,
            edgeColor: [0.2, 1.0, 0.2],
            edgeAlpha: 1,
            edgeWidth: 2,
            vertices: true,
            vertexColor: [0.7, 1.0, 0.7],
            vertexAlpha: 0.9,
            vertexSize: 8.0,
            fill: true,
            fillColor: [0.0, 0.0, 0.0],
            fillAlpha: 0.7
        },

        "battlezone": {
            edges: true,
            edgeColor: [0.2, 1.0, 0.2],
            edgeAlpha: 1,
            edgeWidth: 3,
            vertices: false,
            vertexColor: [0.8, 1.0, 0.8],
            vertexAlpha: 0.9,
            vertexSize: 8.0,
            fill: true,
            fillColor: [0.0, 0.0, 0.0],
            fillAlpha: 1.0
        },

        "sepia": {
            edges: true,
            edgeColor: [0.529411792755127, 0.4577854573726654, 0.4100345969200134],
            edgeAlpha: 1.0,
            edgeWidth: 1,
            vertices: false,
            vertexColor: [0.7, 1.0, 0.7],
            vertexAlpha: 0.9,
            vertexSize: 4.0,
            fill: true,
            fillColor: [0.970588207244873, 0.7965892553329468, 0.6660899519920349],
            fillAlpha: 0.4
        },

        "yellowHighlight": {
            edges: true,
            edgeColor: [0.529411792755127, 0.4577854573726654, 0.4100345969200134],
            edgeAlpha: 1.0,
            edgeWidth: 1,
            vertices: false,
            vertexColor: [0.7, 1.0, 0.7],
            vertexAlpha: 0.9,
            vertexSize: 4.0,
            fill: true,
            fillColor: [1.0, 1.0, 0.0],
            fillAlpha: 0.5
        },

        "greenSelected": {
            edges: true,
            edgeColor: [0.4577854573726654, 0.529411792755127, 0.4100345969200134],
            edgeAlpha: 1.0,
            edgeWidth: 1,
            vertices: false,
            vertexColor: [0.7, 1.0, 0.7],
            vertexAlpha: 0.9,
            vertexSize: 4.0,
            fill: true,
            fillColor: [0.0, 1.0, 0.0],
            fillAlpha: 0.5
        },

        "gamegrid": {
            edges: true,
            edgeColor: [0.4, 0.4, 1.6],
            edgeAlpha: 0.8,
            edgeWidth: 3,
            vertices: false,
            vertexColor: [0.7, 1.0, 0.7],
            vertexAlpha: 0.9,
            vertexSize: 4.0,
            fill: true,
            fillColor: [0.2, 0.2, 0.7],
            fillAlpha: 0.9
        }
    };

    xeogl.GhostMaterial = xeogl.EmphasisMaterial; // Backward compatibility

})();;/**
 An **OutlineMaterial** is a {{#crossLink "Material"}}{{/crossLink}} that's applied to {{#crossLink "Entity"}}Entities{{/crossLink}}
 to render an outline around them.

 WIP

 @class OutlineMaterial
 @module xeogl
 @submodule materials
 @constructor
 @extends Material
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this OutlineMaterial within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted
 @param [cfg] {*} The OutlineMaterial configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta=null] {String:Object} Metadata to attach to this OutlineMaterial.
 @param [cfg.color=[1.0,0.2,0.2]] {Array of Number}  Outline RGB color.
 @param [cfg.alpha=1.0] {Number} Outline opacity. A value of 0.0 indicates fully transparent, 1.0 is fully opaque.
 @param [cfg.width=4] {Number}  Outline width, in pixels.
 */
(function () {

    "use strict";

    xeogl.OutlineMaterial = xeogl.Material.extend({

        type: "xeogl.OutlineMaterial",

        _init: function (cfg) {

            this._super(cfg);

            this._state = new xeogl.renderer.OutlineMaterial({

                type: "OutlineMaterial",

                color: null,
                alpha: null,
                width: null
            });

            this.color = cfg.color;
            this.alpha = cfg.alpha;
            this.width = cfg.width;
        },

        _props: {
            
            /**
             RGB outline color.

             @property color
             @default [1.0, 0.2, 0.2]
             @type Float32Array
             */
            color: {

                set: function (value) {

                    var color = this._state.color;

                    if (!color) {
                        color = this._state.color = new Float32Array(3);

                    } else if (value && color[0] === value[0] && color[1] === value[1] && color[2] === value[2]) {
                        return;
                    }

                    if (value) {
                        color[0] = value[0];
                        color[1] = value[1];
                        color[2] = value[2];

                    } else {
                        color[0] = 1.0;
                        color[1] = 0.2;
                        color[2] = 0.2;
                    }

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.color;
                }
            },

            /**
            Outline transparency.

             A value of 0.0 indicates fully transparent, 1.0 is fully opaque.

             @property alpha
             @default 1.0
             @type Number
             */
            alpha: {

                set: function (value) {

                    value = (value !== undefined && value !== null) ? value : 1.0;

                    if (this._state.alpha === value) {
                        return;
                    }

                    this._state.alpha = value;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.alpha;
                }
            },

            /**
             Outline width in pixels.

             @property width
             @default 4.0
             @type Number
             */
            width: {

                set: function (value) {

                    this._state.width = value || 4.0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.width;
                }
            }
        },

        _getState: function () {
            return this._state;
        },

        _destroy: function () {
            this._super();
            this._state.destroy();
        }
    });

})();;/**
 A **Texture** specifies a texture map.

 ## Overview

 * Textures are grouped within {{#crossLink "Material"}}Materials{{/crossLink}}, which are attached to
 {{#crossLink "Entity"}}Entities{{/crossLink}}.
 * To create a Texture from an image file, set the Texture's {{#crossLink "Texture/src:property"}}{{/crossLink}}
 property to the image file path.
 * To create a Texture from an HTMLImageElement, set the Texture's {{#crossLink "Texture/image:property"}}{{/crossLink}}
 property to the HTMLImageElement.

 ## Examples

 * [Textures on MetallicMaterials](../../examples/#materials_metallic_textures)
 * [Textures on SpecularMaterials](../../examples/#materials_specGloss_textures)
 * [Textures on PhongMaterials](../../examples/#materials_phong_textures)
 * [Video texture](../../examples/#materials_phong_textures_video)

 ## Usage

 In this example we have an Entity with

 * a {{#crossLink "PhongMaterial"}}{{/crossLink}} which applies diffuse and specular {{#crossLink "Texture"}}Textures{{/crossLink}}, and
 * a {{#crossLink "TorusGeometry"}}{{/crossLink}}.

 Note that xeogl will ignore the {{#crossLink "PhongMaterial"}}PhongMaterial's{{/crossLink}} {{#crossLink "PhongMaterial/diffuse:property"}}{{/crossLink}}
 and {{#crossLink "PhongMaterial/specular:property"}}{{/crossLink}} properties, since we assigned {{#crossLink "Texture"}}Textures{{/crossLink}} to the {{#crossLink "PhongMaterial"}}PhongMaterial's{{/crossLink}} {{#crossLink "PhongMaterial/diffuseMap:property"}}{{/crossLink}} and
 {{#crossLink "PhongMaterial/specularMap:property"}}{{/crossLink}} properties. The {{#crossLink "Texture"}}Textures'{{/crossLink}} pixel
 colors directly provide the diffuse and specular components for each fragment across the {{#crossLink "Geometry"}}{{/crossLink}} surface.

 ```` javascript
 var entity = new xeogl.Entity({

    material: new xeogl.PhongMaterial({
        ambient: [0.3, 0.3, 0.3],
        diffuse: [0.5, 0.5, 0.0],   // Ignored, since we have assigned a Texture to diffuseMap, below
        specular: [1.0, 1.0, 1.0],   // Ignored, since we have assigned a Texture to specularMap, below
        diffuseMap: new xeogl.Texture({
            src: "diffuseMap.jpg"
        }),
        specularMap: new xeogl.Fresnel({
            src: "diffuseMap.jpg"
        }),
        shininess: 80, // Default
        alpha: 1.0 // Default
    }),

    geometry: new xeogl.TorusGeometry()
});
 ````

 @class Texture
 @module xeogl
 @submodule materials
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Texture in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID for this Texture, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Texture.
 @param [cfg.src=null] {String} Path to image file to load into this Texture. See the {{#crossLink "Texture/src:property"}}{{/crossLink}} property for more info.
 @param [cfg.image=null] {HTMLImageElement} HTML Image object to load into this Texture. See the {{#crossLink "Texture/image:property"}}{{/crossLink}} property for more info.
 @param [cfg.minFilter="linearMipmapLinear"] {String} How the texture is sampled when a texel covers less than one pixel. See the {{#crossLink "Texture/minFilter:property"}}{{/crossLink}} property for more info.
 @param [cfg.magFilter="linear"] {String} How the texture is sampled when a texel covers more than one pixel. See the {{#crossLink "Texture/magFilter:property"}}{{/crossLink}} property for more info.
 @param [cfg.wrapS="repeat"] {String} Wrap parameter for texture coordinate *S*. See the {{#crossLink "Texture/wrapS:property"}}{{/crossLink}} property for more info.
 @param [cfg.wrapT="repeat"] {String} Wrap parameter for texture coordinate *S*. See the {{#crossLink "Texture/wrapT:property"}}{{/crossLink}} property for more info.
 @param [cfg.flipY=false] {Boolean} Flips this Texture's source data along its vertical axis when true.
 @param [cfg.translate=[0,0]] {Array of Number} 2D translation vector that will be added to texture's *S* and *T* coordinates.
 @param [cfg.scale=[1,1]] {Array of Number} 2D scaling vector that will be applied to texture's *S* and *T* coordinates.
 @param [cfg.rotate=0] {Number} Rotation, in degrees, that will be applied to texture's *S* and *T* coordinates.
 @param [cfg.encoding="linear"] {String} Encoding format.  See the {{#crossLink "Texture/encoding:property"}}{{/crossLink}} property for more info.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Texture = xeogl.Component.extend({

        type: "xeogl.Texture",

        _init: function (cfg) {

            // Rendering state

            this._state = new xeogl.renderer.Texture({

                texture: new xeogl.renderer.Texture2D(this.scene.canvas.gl),
                matrix: null,   // Float32Array

                // Texture properties

                minFilter: null,
                magFilter: null,
                wrapS: null,
                wrapT: null,
                flipY: false
            });

            // Data source

            this._src = null;   // URL string
            this._image = null; // HTMLImageElement

            // Transformation

            this._translate = xeogl.math.vec2([0, 0]);
            this._scale = xeogl.math.vec2([1, 1]);
            this._rotate = xeogl.math.vec2([0, 0]);

            // Dirty flags, processed in _buildTexture()

            this._matrixDirty = false;
            this._srcDirty = false;
            this._imageDirty = false;
            this._propsDirty = false;

            // Handle WebGL context restore

            this._webglContextRestored = this.scene.canvas.on("webglContextRestored", this._webglContextRestored, this);

            // Transform

            this.translate = cfg.translate;
            this.scale = cfg.scale;
            this.rotate = cfg.rotate;

            // Properties

            this.minFilter = cfg.minFilter;
            this.magFilter = cfg.magFilter;
            this.wrapS = cfg.wrapS;
            this.wrapT = cfg.wrapT;
            this.flipY = cfg.flipY;
            this.encoding = cfg.encoding;

            // Data source

            if (cfg.src) {
                this.src = cfg.src; // Image file

            } else if (cfg.image) {
                this.image = cfg.image; // Image object
            }

            xeogl.stats.memory.textures++;
        },

        _webglContextRestored: function () {

            this._state.texture = null;

            this._matrixDirty = true;
            this._propsDirty = true;

            if (this._image) {
                this._imageDirty = true;

            } else if (this._src) {
                this._srcDirty = true;
            }

            this._needUpdate();
        },

        _update: function () {

            var gl = this.scene.canvas.gl;

            var state = this._state;

            if (this._srcDirty) {

                if (this._src) {

                    this._loadSrc(this._src);

                    this._srcDirty = false;

                    // _imageDirty is set when the image has loaded

                    return;
                }
            }

            if (this._imageDirty) {

                if (this._image) {

                    if (!state.texture) {
                        state.texture = new xeogl.renderer.Texture2D(gl);
                    }

                    state.texture.setImage(this._image, state);

                    state.renderable = true;

                    this._imageDirty = false;
                    this._propsDirty = true; // May now need to regenerate mipmaps etc
                }
            }

            if (this._matrixDirty) {

                var matrix;

                var t;

                if (this._translate[0] !== 0 || this._translate[1] !== 0) {
                    matrix = xeogl.math.translationMat4v([this._translate[0], this._translate[1], 0]);
                }

                if (this._scale[0] !== 1 || this._scale[1] !== 1) {
                    t = xeogl.math.scalingMat4v([this._scale[0], this._scale[1], 1]);
                    matrix = matrix ? xeogl.math.mulMat4(matrix, t) : t;
                }

                if (this._rotate !== 0) {
                    t = xeogl.math.rotationMat4v(this._rotate * 0.0174532925, [0, 0, 1]);
                    matrix = matrix ? xeogl.math.mulMat4(matrix, t) : t;
                }

                var oldMatrix = state.matrix;

                state.matrix = matrix;

                this._matrixDirty = false;

                if (!!matrix !== !!oldMatrix) {

                    // Matrix has been lazy-created, now need
                    // to recompile xeogl objectRenderers to use the matrix

                    this.fire("dirty");
                }
            }

            if (this._propsDirty) {

                if (state.texture && state.texture.setProps) {
                    state.texture.setProps(state);
                }

                this._propsDirty = false;
            }

            this._renderer.imageDirty();
        },

        _loadSrc: function (src) {

            var self = this;

            var image = new Image();

            image.onload = function () {

                if (self._src === src) {

                    // Ensure data source was not changed while we were loading

                    // Keep self._src because that's where we loaded the image
                    // from, and we may need to save that in JSON later

                    self._image = xeogl.renderer.ensureImageSizePowerOfTwo(image);

                    self._imageDirty = true;
                    self._srcDirty = false;

                    self._needUpdate();

                    /**
                     * Fired whenever this Texture has loaded the
                     * image file that its {{#crossLink "Texture/src:property"}}{{/crossLink}} property currently points to.
                     * @event loaded
                     * @param value {HTML Image} The value of the {{#crossLink "Texture/src:property"}}{{/crossLink}} property
                     */
                    self.fire("loaded", self._src);
                }
            };

            image.onerror = function () {

                /**
                 * Fired when an error occurs that prevents this Texture from loading.
                 * @event error
                 */
                self.fire("error");
            };

            if (src.indexOf("data") === 0) {

                // Image data
                image.src = src;

            } else {

                // Image file
                image.crossOrigin = "Anonymous";
                image.src = src;
            }
        },

        _props: {

            /**
             * Indicates an HTML DOM Image object to source this Texture from.
             *
             * Sets the {{#crossLink "Texture/src:property"}}{{/crossLink}} property to null.
             *
             * @property image
             * @default null
             * @type {HTMLImageElement}
             */
            image: {

                set: function (value) {

                    this._image = xeogl.renderer.ensureImageSizePowerOfTwo(value);
                    this._src = null;

                    this._imageDirty = true;
                    this._srcDirty = false;

                    this._needUpdate();
                },

                get: function () {
                    return this._image;
                }
            },

            /**
             * Indicates a path to an image file to source this Texture from.
             *
             * Sets the {{#crossLink "Texture/image:property"}}{{/crossLink}} property to null.
             *
             * @property src
             * @default null
             * @type String
             */
            src: {

                set: function (value) {

                    this._image = null;
                    this._src = value;

                    this._imageDirty = false;
                    this._srcDirty = true;

                    this._needUpdate();
                },

                get: function () {
                    return this._src;
                }
            },

            /**
             * 2D translation vector that will be added to this Texture's *S* and *T* coordinates.
             *
             * @property translate
             * @default [0, 0]
             * @type Array(Number)
             */
            translate: {

                set: function (value) {

                    this._translate.set(value || [0, 0]);
                    this._matrixDirty = true;

                    this._needUpdate();
                },

                get: function () {
                    return this._translate;
                }
            },

            /**
             * 2D scaling vector that will be applied to this Texture's *S* and *T* coordinates.
             *
             * @property scale
             * @default [1, 1]
             * @type Array(Number)
             */
            scale: {

                set: function (value) {

                    this._scale.set(value || [1, 1]);
                    this._matrixDirty = true;

                    this._needUpdate();
                },

                get: function () {
                    return this._scale;
                }
            },

            /**
             * Rotation, in degrees, that will be applied to this Texture's *S* and *T* coordinates.
             *
             * @property rotate
             * @default 0
             * @type Number
             */
            rotate: {

                set: function (value) {

                    value = value || 0;

                    if (this._rotate === value) {
                        return;
                    }

                    this._rotate = value;
                    this._matrixDirty = true;

                    this._needUpdate();
                },

                get: function () {
                    return this._rotate;
                }
            },

            /**
             * How this Texture is sampled when a texel covers less than one pixel.
             *
             *
             * Options are:
             *
             *     * **"nearest"** - Uses the value of the texture element that is nearest
             *     (in Manhattan distance) to the center of the pixel being textured.
             *
             *     * **"linear"** - Uses the weighted average of the four texture elements that are
             *     closest to the center of the pixel being textured.
             *
             *     * **"nearestMipmapNearest"** - Chooses the mipmap that most closely matches the
             *     size of the pixel being textured and uses the "nearest" criterion (the texture
             *     element nearest to the center of the pixel) to produce a texture value.
             *
             *     * **"linearMipmapNearest"** - Chooses the mipmap that most closely matches the size of
             *     the pixel being textured and uses the "linear" criterion (a weighted average of the
             *     four texture elements that are closest to the center of the pixel) to produce a
             *     texture value.
             *
             *     * **"nearestMipmapLinear"** - Chooses the two mipmaps that most closely
             *     match the size of the pixel being textured and uses the "nearest" criterion
             *     (the texture element nearest to the center of the pixel) to produce a texture
             *     value from each mipmap. The final texture value is a weighted average of those two
             *     values.
             *
             *     * **"linearMipmapLinear"** - **(default)** - Chooses the two mipmaps that most closely match the size
             *     of the pixel being textured and uses the "linear" criterion (a weighted average
             *     of the four texture elements that are closest to the center of the pixel) to
             *     produce a texture value from each mipmap. The final texture value is a weighted
             *     average of those two values.
             *
             * @property minFilter
             * @default "linearMipmapLinear"
             * @type String
             */
            minFilter: {

                set: function (value) {

                    value = value || "linearMipmapLinear";

                    if (value !== "linear" &&
                        value !== "linearMipmapNearest" &&
                        value !== "linearMipmapLinear" &&
                        value !== "nearestMipmapLinear" &&
                        value !== "linearMipmapLinear") {

                        this.error("Unsupported value for 'minFilter': '" + value +
                            "' - supported values are 'linear', 'linearMipmapNearest', 'nearestMipmapLinear' " +
                            "and 'linearMipmapLinear'. Defaulting to 'linearMipmapLinear'.");

                        value = "linearMipmapLinear";
                    }

                    this._state.minFilter = value;
                    this._propsDirty = true;

                    this._needUpdate();
                },

                get: function () {
                    return this._state.minFilter;
                }
            },

            /**
             * How this Texture is sampled when a texel covers more than one pixel.
             *
             * Options are:
             *
             *
             *     * **"nearest"** - Uses the value of the texture element that is nearest
             *     (in Manhattan distance) to the center of the pixel being textured.
             *     * **"linear"** - **(default)** - Uses the weighted average of the four texture elements that are
             *     closest to the center of the pixel being textured.
             *
             * @property magFilter
             * @default "linear"
             * @type String
             */
            magFilter: {

                set: function (value) {

                    value = value || "linear";

                    if (value !== "linear" && value !== "nearest") {

                        this.error("Unsupported value for 'magFilter': '" + value +
                            "' - supported values are 'linear' and 'nearest'. Defaulting to 'linear'.");

                        value = "linear";
                    }

                    this._state.magFilter = value;
                    this._propsDirty = true;

                    this._needUpdate();
                },

                get: function () {
                    return this._state.magFilter;
                }
            },

            /**
             * Wrap parameter for this Texture's *S* coordinate.
             *
             * Options are:
             *
             *
             *     * **"clampToEdge"** -  causes *S* coordinates to be clamped to the size of the texture.
             *     * **"mirroredRepeat"** - causes the *S* coordinate to be set to the fractional part of the texture coordinate
             *     if the integer part of *S* is even; if the integer part of *S* is odd, then the *S* texture coordinate is
             *     set to *1 - frac ⁡ S* , where *frac ⁡ S* represents the fractional part of *S*.
             *     * **"repeat"** - **(default)** - causes the integer part of the *S* coordinate to be ignored; xeogl uses only the
             *     fractional part, thereby creating a repeating pattern.
             *
             * @property wrapS
             * @default "repeat"
             * @type String
             */
            wrapS: {

                set: function (value) {

                    value = value || "repeat";

                    if (value !== "clampToEdge" && value !== "mirroredRepeat" && value !== "repeat") {

                        this.error("Unsupported value for 'wrapS': '" + value +
                            "' - supported values are 'clampToEdge', 'mirroredRepeat' and 'repeat'. Defaulting to 'repeat'.");

                        value = "repeat";
                    }

                    this._state.wrapS = value;
                    this._propsDirty = true;

                    this._needUpdate();
                },

                get: function () {
                    return this._state.wrapS;
                }
            },

            /**
             * Wrap parameter for this Texture's *T* coordinate.
             *
             * Options are:
             *
             *
             *     * **"clampToEdge"** -  Causes *T* coordinates to be clamped to the size of the texture.
             *     * **"mirroredRepeat"** - Causes the *T* coordinate to be set to the fractional part of the texture coordinate
             *     if the integer part of *T* is even; if the integer part of *T* is odd, then the *T* texture coordinate is
             *     set to *1 - frac ⁡ S* , where *frac ⁡ S* represents the fractional part of *T*.
             *     * **"repeat"** - **(default)** - Causes the integer part of the *T* coordinate to be ignored; xeogl uses only the
             *     fractional part, thereby creating a repeating pattern.
             *
             * @property wrapT
             * @default "repeat"
             * @type String
             */
            wrapT: {

                set: function (value) {

                    value = value || "repeat";

                    if (value !== "clampToEdge" && value !== "mirroredRepeat" && value !== "repeat") {

                        this.error("Unsupported value for 'wrapT': '" + value +
                            "' - supported values are 'clampToEdge', 'mirroredRepeat' and 'repeat'. Defaulting to 'repeat'.");

                        value = "repeat";
                    }

                    this._state.wrapT = value;
                    this._propsDirty = true;

                    this._needUpdate();
                },

                get: function () {
                    return this._state.wrapT;
                }
            },

            /**
             * Flips this Texture's source data along its vertical axis when true.
             *
             * @property flipY
             * @default false
             * @type Boolean
             */
            flipY: {

                set: function (value) {

                    value = !!value;

                    if (this._state.flipY === value) {
                        return;
                    }

                    this._state.flipY = value;
                    this._imageDirty = true; // flipY is used when loading image data, not when post-applying props

                    this._needUpdate();
                },

                get: function () {
                    return this._state.flipY;
                }
            },

            /**
             The Texture's encoding format.

             Supported values are:

             * "linear" (default)
             * "sRGB"
             * "gamma"

             @property encoding
             @default "linear"
             @type String
             */
            encoding: {

                set: function (value) {

                    value = value || "linear";

                    if (value !== "linear" && value !== "sRGB" && value !== "gamma") {
                        this.error("Unsupported value for 'encoding': '" + value +  "' - supported values are 'linear', 'sRGB', 'gamma'. Defaulting to 'linear'.");

                        value = "linear";
                    }

                    this._state.encoding = value;

                    this.fire("dirty"); // Encoding/decoding is baked into shaders - need recompile of entities using this texture in their materials
                },

                get: function () {
                    return this._state.encoding;
                }
            }
        },

        _destroy: function () {

            this.scene.canvas.off(this._webglContextRestored);

            if (this._state.texture) {
                this._state.texture.destroy();
            }

            xeogl.stats.memory.textures--;
        }
    });

})();
;/**
 A **Fresnel** specifies a Fresnel effect for attached {{#crossLink "PhongMaterial"}}PhongMaterials{{/crossLink}}.

 <a href="../../examples/#materials_phong_fresnel"><img src="../../assets/images/screenshots/PhongMaterial/fresnelWide.png"></img></a>

 ## Overview

 * Fresnels are grouped within {{#crossLink "PhongMaterial"}}{{/crossLink}}s, which are attached to
 {{#crossLink "Entity"}}Entities{{/crossLink}}.

 ## Examples

 * [PhongMaterials with Fresnels](../../examples/#materials_phong_fresnel)

 <img src="../../../assets/images/Fresnel.png"></img>

 ## Usage

 ````javascript
 var entity = new xeogl.Entity({

     material: new xeogl.PhongMaterial({
         ambient: [0.3, 0.3, 0.3],
         shininess: 30,

         diffuseFresnel: new xeogl.Fresnel({
             edgeColor: [1.0, 1.0, 1.0],
             centerColor: [0.0, 0.0, 0.0],
             power: 4,
             bias: 0.6
         }),

         specularFresnel: new xeogl.Fresnel({
             edgeColor: [1.0, 1.0, 1.0],
             centerColor: [0.0, 0.0, 0.0],
             power: 4,
             bias: 0.2
         })
     }),

     new xeogl.TorusGeometry()
 });
 ````

 @class Fresnel
 @module xeogl
 @submodule materials
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Geometry in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Fresnel.
 @param [cfg.edgeColor=[ 0.0, 0.0, 0.0 ]] {Array of Number} Color used on edges.
 @param [cfg.centerColor=[ 1.0, 1.0, 1.0 ]] {Array of Number} Color used on center.
 @param [cfg.edgeBias=0] {Number} Bias at the edge.
 @param [cfg.centerBias=1] {Number} Bias at the center.
 @param [cfg.power=0] {Number} The power.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Fresnel = xeogl.Component.extend({

        type: "xeogl.Fresnel",

        _init: function (cfg) {

            this._state = new xeogl.renderer.Fresnel({
                edgeColor: xeogl.math.vec3([0, 0, 0]),
                centerColor: xeogl.math.vec3([1, 1, 1]),
                edgeBias: 0,
                centerBias: 1,
                power: 1
            });

            this.edgeColor = cfg.edgeColor;
            this.centerColor = cfg.centerColor;
            this.edgeBias = cfg.edgeBias;
            this.centerBias = cfg.centerBias;
            this.power = cfg.power;
        },

        _props: {

            /**
             This Fresnel's edge color.

             @property edgeColor
             @default [0.0, 0.0, 0.0]
             @type Float32Array
             */
            edgeColor: {

                set: function (value) {

                    this._state.edgeColor.set(value || [0.0, 0.0, 0.0]);

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.edgeColor;
                }
            },

            /**
             This Fresnel's center color.

             @property centerColor
             @default [1.0, 1.0, 1.0]
             @type Float32Array
             */
            centerColor: {

                set: function (value) {

                    this._state.centerColor.set(value || [1.0, 1.0, 1.0]);

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.centerColor;
                }
            },

            /**
             * Indicates this Fresnel's edge bias.
             *
             * @property edgeBias
             * @default 0
             * @type Number
             */
            edgeBias: {

                set: function (value) {

                    this._state.edgeBias = value || 0;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.edgeBias;
                }
            },

            /**
             * Indicates this Fresnel's center bias.
             *
             * @property centerBias
             * @default 1
             * @type Number
             */
            centerBias: {

                set: function (value) {

                    this._state.centerBias = (value !== undefined && value !== null) ? value : 1;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.centerBias;
                }
            },

            /**
             * Indicates this Fresnel's power.
             *
             * @property power
             * @default 1
             * @type Number
             */
            power: {

                set: function (value) {

                    this._state.power = (value !== undefined && value !== null) ? value : 1;

                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.power;
                }
            }
        },

        _destroy: function () {
            this._state.destroy();
        }
    });

})();
;/**
 * Entities.
 *
 * @module xeogl
 * @submodule entities
 */;/**
 An **Entity** is a 3D object within a {{#crossLink "Scene"}}Scene{{/crossLink}}.

 ## Overview

 * An Entity represents a WebGL draw call.
 * Each Entity has six components: {{#crossLink "Geometry"}}{{/crossLink}}, {{#crossLink "Material"}}{{/crossLink}},
 {{#crossLink "Transform"}}{{/crossLink}}, an {{#crossLink "EmphasisMaterial"}}{{/crossLink}} for ghosting, an {{#crossLink "EmphasisMaterial"}}{{/crossLink}} for highlighting,
 and an {{#crossLink "OutlineMaterial"}}{{/crossLink}} for outlining.
 * By default, Entities in the same Scene share the same "global" flyweight instances of those components amongst themselves. The default
 component instances are provided by the {{#crossLink "Scene"}}{{/crossLink}}'s {{#crossLink "Scene/geometry:property"}}{{/crossLink}},
 {{#crossLink "Scene/material:property"}}{{/crossLink}}, {{#crossLink "Scene/transform:property"}}{{/crossLink}},
 {{#crossLink "Scene/ghostMaterial:property"}}{{/crossLink}}, {{#crossLink "Scene/outlineMaterial:property"}}{{/crossLink}},
 {{#crossLink "Scene/highlightMaterial:property"}}{{/crossLink}} properties, respectively.
 * An Entity with all defaults is a white unit-sized box centered at the World-space origin.
 * Customize your Entities by attaching your own instances of those component types, to override the defaults as needed.
 * For best performance, reuse as many of the same component instances among your Entities as possible.

 ## Usage

 * [Creating an Entity](#creating-an-entity)
 * [Controlling visibility](#controlling-visibility)
 * [Controlling clipping](#controlling-clipping)
 * [Controlling rendering order](#controlling-rendering-order)
 * [Geometry](#geometry)
 * [Material](#material)
 * [Transforming](#transforming)
 * [Ghosting](#ghosting)
 * [Highlighting](#highlighting)
 * [Outlining](#outlining)
 * [Local-space boundary](#local-space-boundary)
 * [World-space boundary](#world-space-boundary)
 * [Skyboxing](#skyboxing)
 * [Billboarding](#billboarding)
 * [Shadows](#shadows) TODO

 ### Creating an Entity

 Creating a minimal Entity that has all the default components:

 <img src="../../assets/images/screenshots/Scene/defaultEntity.png"></img>

 ````javascript
 var entity = new xeogl.Entity(); // A white unit-sized box centered at the World-space origin
 ````

 Since our Entity has all the default components, we can get those off either the Entity or its Scene:

 ````javascript
 entity.material.diffuse = [1.0, 0.0, 0.0];  // This is the same Material component...

 var scene = entity.scene;
 scene.material.diffuse  = [1.0, 0.0, 0.0];  // ...as this one.
 ````

 In practice, we would provide (at least) our own Geometry and Material for the Entity:

 <a href="../../examples/#geometry_primitives_teapot"><img src="../../assets/images/screenshots/Scene/teapot.png"></img></a>

 ````javascript
 var entity = new xeogl.Entity({
     geometry: new xeogl.TeapotGeometry(),
     material: new xeogl.MetallicMaterial({
         baseColor: [1.0, 1.0, 1.0]
     })
 });
 ````

 ### Controlling visibility

 Show or hide an Entity by setting its {{#crossLink "Entity/visible:property"}}{{/crossLink}} property:

 ````javascript
 entity.visible = false; // Hide
 entity.visible = true; // Show (default)
 ````

 ### Controlling clipping

 By default, an Entity will be clipped by the
 Scene's {{#crossLink "Scene/clips:property"}}clipping planes{{/crossLink}} (if you've created some).

 Make an Entity unclippable by setting its {{#crossLink "Entity/clippable:property"}}{{/crossLink}} property false:

 ````javascript
 entity.clippable = false; // Default is true
 ````

 ### Controlling rendering order

 Control the order in which an Entity is rendered relative to others by setting its {{#crossLink "Entity/layer:property"}}{{/crossLink}}
 property. You would normally do this when you need to ensure that transparent Entities are rendered in back-to-front order for correct alpha blending.

 Assign entity to layer 0 (all Entities are in layer 0 by default):

 ````javascript
 entity.layer = 0;
 ````

 Create another Entity in a higher layer, that will get rendered after layer 0:

 ````javascript
 var entity2 = new xeogl.Entity({
     geometry: new xeogl.Sphere(),
     layer: 1
 });
 ````

 ### Geometry

 An Entity has a {{#crossLink "Geometry"}}{{/crossLink}} which describes its shape. When we don't provide it with a
 Geometry, it will have the Scene's {{#crossLink "Scene/geometry:property"}}{{/crossLink}} by default.

 Creating an Entity with its own Geometry:

 ````javascript
 var entity = new xeogl.Entity({
     geometry: new xeogl.TeapotGeometry()
 });
 ````

 Dynamically replacing the Geometry:

 ````javascript
 entity.geometry = new xeogl.CylinderGeometry();
 ````

 Getting geometry arrays:

 ````javascript
 ver geometry = entity.geometry;

 var primitive = geometry,primitive;        // Default is "triangles"
 var positions = geometry.positions;        // Local-space vertex positions
 var normals = geometry.normals;            // Local-space vertex Normals
 var uv = geometry.uv;                      // UV coordinates
 var indices = entity.geometry.indices;     // Vertex indices for pimitives
 ````

 The Entity also has a convenience property which provides the vertex positions in World-space, ie. after they have been
 transformed by the Entity's Transform:

 ````javascript
 // These are internally generated on-demand and cached. To free the cached
 // vertex World positions when you're done with them, set this property to null or undefined
 var worldPositions = entity.worldPositions;
 ````

 ### Material

 An Entity has a {{#crossLink "Material"}}{{/crossLink}}, which describes its appearance. When we don't provide it with
 a Material, it will have the Scene's {{#crossLink "Scene/material:property"}}{{/crossLink}} by default.

 Creating an Entity with its own custom Geometry and Material:

 ````javascript
 var entity = new xeogl.Entity({
     geometry: new xeogl.TeapotGeometry(),
     material: new xeogl.MetallicMaterial({
         baseColor: [0.0, 0.0, 1.0],
         metallic: 1.0,
         roughness: 1.0,
         emissive: [0.0, 0.0, 0.0],
         alpha: 1.0
     })
 });
 ````

 Dynamically replacing the Material:

 ````javascript
 entity.material = new xeogl.SpecularMaterial({
     diffuse: [1.0, 1.0, 1.0],
     specular: [1.0, 1.0, 1.0],
     glossiness: 1.0,
     emissive: [0.0, 0.0, 0.0]
     alpha: 1.0
 })
 ````

 Animating the Material's diffuse color - making the Entity rapidly pulse red:

 ````javascript
 entity.scene.on("tick", function(e) {
    var t = e.time - e.startTime; // Millisecs
    entity.material.diffuse = [0.5 + Math.sin(t * 0.01), 0.0, 0.0]; // RGB
 });
 ````

 ### Transforming

 An Entity has a {{#crossLink "Transform"}}{{/crossLink}}, which positions, sizes and orients it within the World-space
 coordinate system. When we don't provide it with a Transform, it will have the Scene's {{#crossLink "Scene/transform:property"}}{{/crossLink}}
 by default (which is the identity transform unless modified).

 Transforms can also be connected into hierarchies.

 Creating an Entity with its own Geometry and Transform hierarchy:

 ````javascript
 var entity = new xeogl.Entity({

     geometry: new xeogl.TeapotGeometry(),

     transform: new xeogl.Translate({eapot
        xyz: [-5, 0, 0],
        parent: new xeogl.Rotate({
            xyz: [0,1,0],
            angle: 45
        })
     })
 });
 ````

 Dynamically replacing the Entity's Transform hierarchy:

 ````javascript
 entity.transform = new xeogl.Rotate({
     xyz: [0,1,0],
     angle: 45
     parent: new xeogl.Rotate({
         xyz: [1,0,0],
         angle: 180
     })
 });
 ````

 Animating the Transform hierarchy:

 ````javascript
 entity.scene.on("tick", function() {
    entity.transform.angle += 0.5;
    entity.transform.parent.angle += 0.5;
 });
 ````

 ### Ghosting

 Ghost an Entity by setting its {{#crossLink "Entity/ghosted:property"}}{{/crossLink}} property true. The Entity's
 {{#crossLink "EmphasisMaterial"}}{{/crossLink}} then controls its appearance while ghosted.

 When we don't provide it with a EmphasisMaterial, it will have the Scene's {{#crossLink "Scene/ghostMaterial:property"}}{{/crossLink}}
 by default.

 In the example below, we'll create a ghosted Entity with its own EmphasisMaterial.

 <a href="../../examples/#effects_ghost"><img src="../../assets/images/screenshots/EmphasisMaterial/teapot.png"></img></a>

 ````javascript
 var entity = new xeogl.Entity({
    geometry: new xeogl.TeapotGeometry(),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    ghostMaterial: new xeogl.EmphasisMaterial({
        edges: true,
        edgeColor: [0.2, 1.0, 0.2],
        edgeAlpha: 1.0,
        edgeWidth: 2,
        vertices: true,
        vertexColor: [0.6, 1.0, 0.6],
        vertexAlpha: 1.0,
        vertexSize: 8,
        fill: true,
        fillColor: [0, 0, 0],
        fillAlpha: 0.7
    }),
    ghosted: true
 });
 ````

 #### Examples

 * [Ghosted teapot](../../examples/#effects_ghost)

 ### Highlighting

 Highlight an Entity by setting its {{#crossLink "Entity/highlighted:property"}}{{/crossLink}} property true. The Entity's
 highlighting {{#crossLink "EmphasisMaterial"}}{{/crossLink}} then controls its appearance while highlighted.

 When we don't provide it with a EmphasisMaterial for highlighting, it will have the Scene's {{#crossLink "Scene/highlightMaterial:property"}}{{/crossLink}}
 by default.

 In the example below, we'll create a highlighted Entity with its own EmphasisMaterial.

 <a href="../../examples/#effects_highlight"><img src="../../assets/images/screenshots/EmphasisMaterial/teapotHighlighted.png"></img></a>

 ````javascript
 var entity = new xeogl.Entity({
    geometry: new xeogl.TeapotGeometry(),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    highlightMaterial: new xeogl.EmphasisMaterial({
        color: [1.0, 1.0, 0.0],
        alpha: 0.6
    }),
    highlighted: true
 });
 ````

 #### Examples

 * [Ghost and highlight effects](../../examples/#effects_demo_gearbox)

 ### Outlining

 Outline an Entity by setting its {{#crossLink "Entity/outlined:property"}}{{/crossLink}} property true. The Entity's
 {{#crossLink "OutlineMaterial"}}{{/crossLink}} then controls its appearance while outlined.

 When we don't provide it with an OutlineMaterial, it will have the Scene's {{#crossLink "Scene/outlineMaterial:property"}}{{/crossLink}}
 by default.

 In the example below, we'll create a outlined Entity with its own OutlineMaterial.

 <a href="../../examples/#effects_outline"><img src="../../assets/images/screenshots/OutlineMaterial/teapot.png"></img></a>

 ````javascript
 var entity = new xeogl.Entity({
    geometry: new xeogl.TeapotGeometry(),
    material: new xeogl.PhongMaterial({
        diffuse: [0.2, 0.2, 1.0]
    }),
    outlineMaterial: new xeogl.OutlineMaterial({
        color: [1.0, 1.0, 0.0],
        alpha: 0.6,
        width: 5
    }),
    outlined: true
 });
 ````

 ### Local-space boundary

 We can get an Entity's Local-space boundary at any time, as both an axis-aligned bounding box (AABB) and
 an object-aligned bounding box (OBB).

 The Local-space boundary is the boundary of the Entity's Geometry, without any transforms applied.

 Getting the Local-space boundary as an AABB:

 ````
 var aabb = entity.geometry.aabb; // [xmin, ymin, zmin, xmax, ymax, zmax]
 ````

 Getting the Local-space boundary as an OBB:

 ```` javascript
 var obb = entity.geometry.obb; // Flat array containing eight 3D corner vertices of a box
 ````

 #### Examples

 * [Local-space Geometry AABB](../../examples/#boundaries_geometry_aabb)
 * [Local-space Geometry OBB](../../examples/#boundaries_geometry_obb)

 ### World-space boundary

 We can get an Entity's World-space boundary at any time, as both an axis-aligned bounding box (AABB) and
 an object-aligned bounding box (OBB).

 The World-space boundary is the boundary of the Entity's Geometry after the Entity's Transform has been applied to it.

 Getting the World-space boundary as an AABB:

 ````javascript
 var aabb = entity.aabb; // [xmin, ymin, zmin, xmax, ymax, zmax]
 ````

 Getting the World-space boundary as an OBB:

 ```` javascript
 var obb = entity.obb; // Flat array containing eight 3D corner vertices of a box
 ````

 Subscribing to updates of the World-space boundary, which occur whenever the Entity's Transform or Geometry have been updated.

 ````javascript
 entity.on("boundary", function() {
     var aabb = entity.aabb;
     var obb = entity.obb;
 });
 ````

 An Entity's {{#crossLink "Scene"}}{{/crossLink}} also has an {{#crossLink "Scene/getAABB:method"}}{{/crossLink}}, which returns
 the collective World-space axis-aligned boundary of the {{#crossLink "Entity"}}Entities{{/crossLink}}
 and/or {{#crossLink "Model"}}Models{{/crossLink}} with the given IDs:

 ````JavaScript
 var scene = entity.scene;

 scene.getAABB(); // Gets collective boundary of all entities in the viewer
 scene.getAABB("saw"); // Gets collective boundary of all entities in a model
 scene.getAABB(["saw", "gearbox"]); // Gets collective boundary of all entities in two models
 scene.getAABB("saw#0.1"); // Get boundary of an entity
 scene.getAABB(["saw#0.1", "saw#0.2"]); // Get collective boundary of two entities
 ````

 #### Excluding from boundary calculations

 The {{#crossLink "Scene/aabb:property"}}Scene aabb{{/crossLink}}
 and {{#crossLink "Model/aabb:property"}}Model aabb{{/crossLink}} properties provide AABBs that include the boundaries of all
 contained Entities, except those Entities that have their {{#crossLink "Entity/collidable:property"}}collidable{{/crossLink}} properties set ````false````.

 Toggle that inclusion like so:

 ````javascript
 entity.collidable = false; // Exclude entity from calculation of its Scene/Model boundary
 entity.collidable = true; // Include entity in calculation of its Scene/Model boundary
 ````
 Setting this false is useful when an Entity represents some object, such as a control gizmo, that you don't want to consider as
 being a contributor to a Scene or Model boundary. It also helps performance, since boundaries will not need dynamically re-calculated
 whenever the Entity's boundary changes after a Transform or Geometry update.

 #### Examples

 * [World-space Entity AABB](../../examples/#boundaries_entity_aabb)
 * [World-space Entity OBB](../../examples/#boundaries_entity_obb)

 ### Skyboxing

 An Entity has a {{#crossLink "Entity/stationary:property"}}{{/crossLink}} property
 that will cause it to never translate with respect to the viewpoint, while still rotationg, as if always far away.

 This is useful for using Entities as skyboxes, like this:

 ````javascript
 new xeogl.Entity({

     geometry: new xeogl.BoxGeometry({
         xSize: 1000,
         ySize: 1000,
         zSize: 1000
     }),

     material: new xeogl.PhongMaterial({
         diffuseMap: new xeogl.Texture({
            src: "textures/diffuse/uvGrid2.jpg"
         })
     }),

     stationary: true // Locks position with respect to viewpoint
 });
 ````

 #### Examples

 * [Skybox component](../../examples/#skyboxes_skybox)
 * [Custom skybox](../../examples/#skyboxes_skybox_custom)

 ### Billboarding

 An Entity has a {{#crossLink "Entity/billboard:property"}}{{/crossLink}} property
 that can make it behave as a billboard.

 Two billboard types are supported:

 * **Spherical** billboards are free to rotate their Entities in any direction and always face the {{#crossLink "Camera"}}{{/crossLink}} perfectly.
 * **Cylindrical** billboards rotate their Entities towards the {{#crossLink "Camera"}}{{/crossLink}}, but only about the Y-axis.

 Note that {{#crossLink "Scale"}}{{/crossLink}} transformations to have no effect on billboarded Entities.

 The example below shows a box that remains rotated directly towards the viewpoint, using spherical billboarding:

 ````javascript
 new xeogl.Entity({

     geometry: new xeogl.BoxGeometry(),

     material: new xeogl.PhongMaterial({
         diffuseMap: new xeogl.Texture({
            src: "textures/diffuse/uvGrid2.jpg"
         })
     }),

     billboard: "spherical" // Or "cylindrical"
 });
 ````

 #### Examples

 * [Spherical billboards](../../examples/#billboards_spherical)
 * [Cylindrical billboards](../../examples/#billboards_cylindrical)
 * [Clouds using billboards](../../examples/#billboards_spherical_clouds)


 ### Shadows

 [Work-in-progress]


 @class Entity
 @module xeogl
 @submodule entities
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Entity within xeogl's default {{#crossLink "xeogl/scene:property"}}scene{{/crossLink}} by default.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Entity.
 @param [cfg.geometry] {String|Geometry} ID or instance of a {{#crossLink "Geometry"}}Geometry{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/geometry:property"}}geometry{{/crossLink}}, which is a 2x2x2 box.
 @param [cfg.material] {String|Material} ID or instance of a {{#crossLink "Material"}}Material{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/material:property"}}material{{/crossLink}}.
 @param [cfg.transform] {String|Transform} ID or instance of a modelling transform to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance,
 {{#crossLink "Scene/transform:property"}}transform{{/crossLink}} (which is an identity matrix which performs no transformation).
 @param [cfg.visible=true] {Boolean}  Indicates if this Entity is visible.
 @param [cfg.culled=true] {Boolean}  Indicates if this Entity is culled from view.
 @param [cfg.pickable=true] {Boolean}  Indicates if this Entity is pickable.
 @param [cfg.clippable=true] {Boolean} Indicates if this Entity is clippable by {{#crossLink "Clips"}}{{/crossLink}}.
 @param [cfg.collidable=true] {Boolean} Whether this Entity is included in boundary calculations.
 @param [cfg.castShadow=true] {Boolean} Whether this Entity casts shadows.
 @param [cfg.receiveShadow=true] {Boolean} Whether this Entity receives shadows.
 @param [cfg.outlined=false] {Boolean} Whether an outline is rendered around this entity, as configured by the Entity's {{#crossLink "OutlineMaterial"}}{{/crossLink}} component.
 @param [cfg.outlineMaterial] {String|OutlineMaterial} ID or instance of an {{#crossLink "OutlineMaterial"}}{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/outlineMaterial:property"}}outlineMaterial{{/crossLink}}.
 @param [cfg.ghosted=false] {Boolean} Whether this entity is rendered ghosted, as configured by {{#crossLink "Entity/ghostMaterial:property"}}ghostMaterial{{/crossLink}}.
 @param [cfg.ghostMaterial] {String|EmphasisMaterial} ID or instance of an {{#crossLink "EmphasisMaterial"}}{{/crossLink}} to attach to this Entity. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/ghostMaterial:property"}}ghostMaterial{{/crossLink}}.
 @param [cfg.highlight=false] {Boolean} Whether this entity is rendered highlighted, as configured by {{#crossLink "Entity/highlightMaterial:property"}}highlightMaterial{{/crossLink}}.
 @param [cfg.highlightMaterial] {String|EmphasisMaterial} ID or instance of an {{#crossLink "EmphasisMaterial"}}{{/crossLink}} to attach to this Entity to define highlighted appearance. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/highlightMaterial:property"}}highlightMaterial{{/crossLink}}.
 @param [cfg.selected=false] {Boolean} Whether this entity is rendered selected, as configured by {{#crossLink "Entity/selectedMaterial:property"}}selectedMaterial{{/crossLink}}.
 @param [cfg.selectedMaterial] {String|EmphasisMaterial} ID or instance of an {{#crossLink "EmphasisMaterial"}}{{/crossLink}} to attach to this Entity to define selected appearance. Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the
 parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s default instance, {{#crossLink "Scene/selectedMaterial:property"}}selectedMaterial{{/crossLink}}.
 @param [cfg.layer=0] {Number} Indicates this Entity's rendering priority, typically used for transparency sorting,
 @param [cfg.stationary=false] {Boolean} Disables the effect of {{#crossLink "Lookat"}}view transform{{/crossLink}} translations for this Entity. This is useful for skybox Entities.
 @param [cfg.billboard="none"] {String} Specifies the billboarding behaviour for this Entity. Options are "none", "spherical" and "cylindrical".
 @param [cfg.loading=false] {Boolean} Flag which indicates that this Entity is freshly loaded.
 @extends Component
 */

/**
 * Fired when this Entity is *picked* via a call to the {{#crossLink "Canvas/pick:method"}}{{/crossLink}} method
 * on the parent {{#crossLink "Scene"}}Scene{{/crossLink}}'s {{#crossLink "Canvas"}}Canvas {{/crossLink}}.
 * @event picked
 * @param {String} entityId The ID of this Entity.
 * @param {Number} canvasX The X-axis Canvas coordinate that was picked.
 * @param {Number} canvasY The Y-axis Canvas coordinate that was picked.
 */
(function () {

    "use strict";

    xeogl.Entity = xeogl.Component.extend({

        type: "xeogl.Entity",

        _init: function (cfg) {

            this._state = new xeogl.renderer.Modes({
                translate: null,
                visible: true,
                culled: false,
                pickable: null,
                clippable: null,
                colorize: null,
                collidable: null,
                castShadow: null,
                receiveShadow: null,
                outlined: null,
                ghosted: false,
                highlighted: false,
                selected: false,
                layer: null,
                billboard: null,
                hash: ""
            });

            this._objectId = null; // Renderer object
            this._loading = cfg.loading !== false;

            this._aabbDirty = true;
            this._obbDirty = true;

            this._worldPositions = null;
            this._worldPositionsDirty = true;

            // Components

            this.geometry = cfg.geometry;
            this.material = cfg.material;
            this.transform = cfg.transform;
            this.ghostMaterial = cfg.ghostMaterial;
            this.outlineMaterial = cfg.outlineMaterial;
            this.highlightMaterial = cfg.highlightMaterial;
            this.selectedMaterial = cfg.selectedMaterial;

            // Properties

            this.translate = cfg.translate;
            this.visible = cfg.visible;
            this.culled = cfg.culled;
            this.pickable = cfg.pickable;
            this.clippable = cfg.clippable;
            this.collidable = cfg.collidable;
            this.castShadow = cfg.castShadow;
            this.receiveShadow = cfg.receiveShadow;
            this.outlined = cfg.outlined;
            this.layer = cfg.layer;
            this.stationary = cfg.stationary;
            this.billboard = cfg.billboard;
            this.solid = cfg.solid;
            this.ghosted = cfg.ghosted;
            this.highlighted = cfg.highlighted;
            this.selected = cfg.selected;
            this.colorize = cfg.colorize;
        },

        _props: {

            /**
             * The {{#crossLink "Geometry"}}Geometry{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/geometry:property"}}geometry{{/crossLink}}
             * (a simple box) when set to a null or undefined value.
             *
             * Updates {{#crossLink "Entity/boundary"}}{{/crossLink}},
             * {{#crossLink "Entity/worldObb"}}{{/crossLink}} and
             * {{#crossLink "Entity/center"}}{{/crossLink}}
             *
             * @property geometry
             * @type Geometry
             */
            geometry: {

                set: function (value) {

                    this._attach({
                        name: "geometry",
                        type: "xeogl.Component",  // HACK
                        component: value,
                        sceneDefault: true,
                        on: {
                            "boundary": {
                                callback: this._setBoundaryDirty,
                                scope: this
                            },
                            "destroyed": {
                                callback: this._setBoundaryDirty,
                                scope: this
                            }
                        }
                    });

                    this._setBoundaryDirty();
                },

                get: function () {
                    return this._attached.geometry;
                }
            },

            /**
             * The {{#crossLink "Material"}}Material{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/material:property"}}material{{/crossLink}} when set to
             * a null or undefined value.
             *
             * @property material
             * @type Material
             */
            material: {

                set: function (value) {

                    this._attach({
                        name: "material",
                        type: "xeogl.Material",
                        component: value,
                        sceneDefault: true
                    });
                },

                get: function () {
                    return this._attached.material;
                }
            },

            /**
             * The {{#crossLink "EmphasisMaterial"}}EmphasisMaterial{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/ghostMaterial:property"}}ghostMaterial{{/crossLink}} when set to
             * a null or undefined value.
             *
             * @property ghostMaterial
             * @type EmphasisMaterial
             */
            ghostMaterial: {

                set: function (value) {

                    this._attach({
                        name: "ghostMaterial",
                        type: "xeogl.EmphasisMaterial",
                        component: value,
                        sceneDefault: true
                    });
                },

                get: function () {
                    return this._attached.ghostMaterial;
                }
            },

            /**
             * The {{#crossLink "EmphasisMaterial"}}EmphasisMaterial{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/highlightMaterial:property"}}highlightMaterial{{/crossLink}} when set to
             * a null or undefined value.
             *
             * @property highlightMaterial
             * @type EmphasisMaterial
             */
            highlightMaterial: {

                set: function (value) {

                    this._attach({
                        name: "highlightMaterial",
                        type: "xeogl.EmphasisMaterial",
                        component: value,
                        sceneDefault: true
                    });
                },

                get: function () {
                    return this._attached.highlightMaterial;
                }
            },

            /**
             * The {{#crossLink "EmphasisMaterial"}}EmphasisMaterial{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/selectedMaterial:property"}}selectedMaterial{{/crossLink}} when set to
             * a null or undefined value.
             *
             * @property selectedMaterial
             * @type EmphasisMaterial
             */
            selectedMaterial: {

                set: function (value) {

                    this._attach({
                        name: "selectedMaterial",
                        type: "xeogl.EmphasisMaterial",
                        component: value,
                        sceneDefault: true
                    });
                },

                get: function () {
                    return this._attached.selectedMaterial;
                }
            },

            /**
             * The {{#crossLink "OutlineMaterial"}}OutlineMaterial{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/outlineMaterial:property"}}outlineMaterial{{/crossLink}} when set to
             * a null or undefined value.
             *
             * @property outlineMaterial
             * @type OutlineMaterial
             */
            outlineMaterial: {

                set: function (value) {

                    this._attach({
                        name: "outlineMaterial",
                        type: "xeogl.OutlineMaterial",
                        component: value,
                        sceneDefault: true
                    });
                },

                get: function () {
                    return this._attached.outlineMaterial;
                }
            },

            /**
             * The Local-to-World-space (modelling) {{#crossLink "Transform"}}{{/crossLink}} attached to this Entity.
             *
             * Must be within the same {{#crossLink "Scene"}}Scene{{/crossLink}} as this Entity. Defaults to the parent
             * {{#crossLink "Scene"}}Scene{{/crossLink}}'s default {{#crossLink "Scene/transform:property"}}transform{{/crossLink}}
             * (an identity matrix) when set to a null or undefined value.
             *
             * Updates {{#crossLink "Entity/boundary"}}{{/crossLink}},
             * {{#crossLink "Entity/worldObb"}}{{/crossLink}} and
             * {{#crossLink "Entity/center"}}{{/crossLink}}
             *
             * @property transform
             * @type Transform
             */
            transform: {

                set: function (value) {

                    this._setBoundaryDirty();

                    this._attach({
                        name: "transform",
                        type: "xeogl.Transform",
                        component: value,
                        sceneDefault: true,
                        on: {
                            updated: {
                                callback: function () {
                                    if (this._transformDirty) {
                                        return;
                                    }
                                    this._transformDirty = true;
                                    // Assumes worst case: many repeated "updated" events within the transform hierarchy per frame
                                    xeogl.scheduleTask(this._transformUpdated, this);
                                },
                                scope: this
                            },

                            destroyed: {
                                callback: this._setBoundaryDirty,
                                scope: this
                            }
                        }
                    });
                },

                get: function () {
                    return this._attached.transform;
                }
            },

            /**
             Indicates whether this Entity is visible or not.

             The Entity is only rendered when {{#crossLink "Entity/visible:property"}}{{/crossLink}} is true and
             {{#crossLink "Entity/culled:property"}}{{/crossLink}} is false.

             @property visible
             @default true
             @type Boolean
             */
            visible: {

                set: function (value) {
                    this._state.visible = value !== false;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.visible;
                }
            },

            /**
             Indicates whether or not this Entity is currently culled from view.

             The Entity is only rendered when {{#crossLink "Entity/visible:property"}}{{/crossLink}} is true and
             {{#crossLink "Entity/culled:property"}}{{/crossLink}} is false.

             @property culled
             @default false
             @type Boolean
             */
            culled: {

                set: function (value) {
                    this._state.culled = !!value;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.culled;
                }
            },

            /**
             Indicates whether this entity is pickable or not.

             Picking is done via calls to {{#crossLink "Canvas/pick:method"}}Canvas#pick{{/crossLink}}.

             @property pickable
             @default true
             @type Boolean
             */
            pickable: {

                set: function (value) {
                    value = value !== false;
                    if (this._state.pickable === value) {
                        return;
                    }
                    this._state.pickable = value;

                    // No need to trigger a render;
                    // state is only used when picking
                },

                get: function () {
                    return this._state.pickable;
                }
            },

            /**
             Indicates whether this Entity is clippable by {{#crossLink "Clips"}}{{/crossLink}} components.

             @property clippable
             @default true
             @type Boolean
             */
            clippable: {

                set: function (value) {
                    value = value !== false;
                    if (this._state.clippable === value) {
                        return;
                    }
                    this._state.clippable = value;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.clippable;
                }
            },

            /**
             Indicates whether this Entity is included in boundary calculations.

             @property collidable
             @default true
             @type Boolean
             */
            collidable: {

                set: function (value) {
                    value = value !== false;
                    if (value === this._state.collidable) {
                        return;
                    }
                    this._state.collidable = value;
                },

                get: function () {
                    return this._state.collidable;
                }
            },


            /**
             Indicates whether this Entity casts shadows.

             @property castShadow
             @default true
             @type Boolean
             */
            castShadow: {

                set: function (value) {
                    value = value !== false;
                    if (value === this._state.castShadow) {
                        return;
                    }
                    this._state.castShadow = value;
                    this._renderer.imageDirty(); // Re-render in next shadow map generation pass
                },

                get: function () {
                    return this._state.castShadow;
                }
            },

            /**
             Indicates whether this Entity receives shadows.

             @property receiveShadow
             @default true
             @type Boolean
             */
            receiveShadow: {

                set: function (value) {
                    value = value !== false;
                    if (value === this._state.receiveShadow) {
                        return;
                    }
                    this._state.receiveShadow = value;
                    this._state.hash = value ? "/mod/rs;" : "/mod;";
                    this.fire("dirty", this); // Now need to (re)compile objectRenderers to include/exclude shadow mapping
                },

                get: function () {
                    return this._state.receiveShadow;
                }
            },

            /**
             Indicates whether this Entity is rendered with an outline.

             The outline effect is configured via the Entity's {{#crossLink "Entity/outlineMaterial:property"}}outlineMaterial{{/crossLink}} component.

             @property outlined
             @default false
             @type Boolean
             */
            "outlined,outline": {

                set: function (value) {
                    value = !!value;
                    if (value === this._state.outlined) {
                        return;
                    }
                    this._state.outlined = value;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.outlined;
                }
            },

            /**
             Indicates whether this Entity is highlighted.

             The highlight effect is configured via the Entity's {{#crossLink "Entity/highlightMaterial:property"}}highlightMaterial{{/crossLink}}.

             @property highlighted
             @default false
             @type Boolean
             */
            "highlight,highlighted": {

                set: function (value) {
                    value = !!value;
                    if (value === this._state.highlighted) {
                        return;
                    }
                    this._state.highlighted = value;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.highlighted;
                }
            },

            /**
             Indicates whether this Entity is selected.

             The selected effect is configured via the Entity's {{#crossLink "Entity/selectedMaterial:property"}}selectedMaterial{{/crossLink}}.

             @property selected
             @default false
             @type Boolean
             */
            selected: {

                set: function (value) {
                    value = !!value;
                    if (value === this._state.selected) {
                        return;
                    }
                    this._state.selected = value;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.selected;
                }
            },

            /**
             RGBA colorize color, multiplies by the outgoing fragment color and transparency.

             @property colorize
             @default [1.0, 1.0, 1.0, 1.0]
             @type Float32Array
             */
            colorize: {

                set: function (value) {
                    var colorize = this._state.colorize;
                    if (!colorize) {
                        colorize = this._state.colorize = new Float32Array(4);
                    }
                    if (value) {
                        colorize[0] = value[0];
                        colorize[1] = value[1];
                        colorize[2] = value[2];
                        colorize[3] = value[3];
                    } else {
                        colorize[0] = 1;
                        colorize[1] = 1;
                        colorize[2] = 1;
                        colorize[3] = 1;
                    }
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.colorize;
                }
            },

            /**
             * Indicates this Entity's rendering order.
             *
             * This can be set on multiple transparent Entities, to make them render in a specific order
             * for correct alpha blending.
             *
             * @property layer
             * @default 0
             * @type Number
             */
            layer: {

                set: function (value) {
                    // TODO: Only accept rendering layer in range [0...MAX_layer]
                    value = value || 0;
                    value = Math.round(value);
                    if (value === this._state.layer) {
                        return;
                    }
                    this._state.layer = value;
                    this._renderer.needStateSort();
                },

                get: function () {
                    return this._state.layer;
                }
            },

            /**
             * Flag which indicates whether this Entity is stationary or not.
             *
             * Setting this true will disable the effect of {{#crossLink "Lookat"}}view transform{{/crossLink}}
             * translations for this Entity, while still alowing it to rotate. This is useful for skybox Entities.
             *
             * @property stationary
             * @default false
             * @type Boolean
             */
            stationary: {

                set: function (value) {
                    value = !!value;
                    if (this._state.stationary === value) {
                        return;
                    }
                    this._state.stationary = value;
                    this.fire("dirty", this);
                },

                get: function () {
                    return this._state.stationary;
                }
            },

            /**
             Specifies the billboarding behaviour for this Entity.

             Options are:

             * **"none"** -  **(default)** - No billboarding.
             * **"spherical"** - Entity is billboarded to face the viewpoint, rotating both vertically and horizontally.
             * **"cylindrical"** - Entity is billboarded to face the viewpoint, rotating only about its vertically
             axis. Use this mode for things like trees on a landscape.

             @property billboard
             @default "none"
             @type String
             */
            billboard: {

                set: function (value) {
                    value = value || "none";
                    if (value !== "spherical" && value !== "cylindrical" && value !== "none") {
                        this.error("Unsupported value for 'billboard': " + value + " - accepted values are " +
                            "'spherical', 'cylindrical' and 'none' - defaulting to 'none'.");
                        value = "none";
                    }
                    if (this._state.billboard === value) {
                        return;
                    }
                    this._state.billboard = value;
                    this.fire("dirty", this);
                },

                get: function () {
                    return this._state.billboard;
                }
            },

            /**
             * Flag which indicates if this Entity is rendered with ghost effect.
             *
             * The ghost effect is configured via the Entity's {{#crossLink "Entity/ghostMaterial:property"}}ghostMaterial{{/crossLink}}.
             *
             * @property ghosted
             * @default false
             * @type Boolean
             */
            "ghosted,ghost": {

                set: function (value) {
                    value = !!value;
                    if (this._state.ghosted === value) {
                        return;
                    }
                    this._state.ghosted = value;
                    this._renderer.imageDirty();
                },

                get: function () {
                    return this._state.ghosted;
                }
            },


            /**
             * World-space 3D center of this Entity.
             *
             * @property center
             * @final
             * @type {Float32Array}
             */
            center: {
                get: function () {
                    if (this._aabbDirty) {
                        if (!this._center) {
                            this._center = xeogl.math.AABB3();
                        }
                        var aabb = this.aabb;
                        this._center[0] = (aabb[0] + aabb[3] ) / 2;
                        this._center[1] = (aabb[1] + aabb[4] ) / 2;
                        this._center[2] = (aabb[2] + aabb[5] ) / 2;
                    }
                    return this._center;
                }
            },

            /**
             * World-space axis-aligned 3D boundary (AABB) of this Entity.
             *
             * The AABB is represented by a six-element Float32Array containing the min/max extents of the
             * axis-aligned volume, ie. ````[xmin, ymin,zmin,xmax,ymax, zmax]````.
             *
             * @property aabb
             * @final
             * @type {Float32Array}
             */
            aabb: {
                get: function () {
                    if (this._aabbDirty) {
                        this._aabbDirty = false;
                        var math = xeogl.math;
                        var transform = this._attached.transform;
                        var geometry = this._attached.geometry;
                        if (!transform) {
                            return geometry.aabb;
                        }
                        if (!this._aabb) {
                            this._aabb = math.AABB3();
                        }
                        if (!this._obb) {
                            this._obb = math.OBB3();
                        }
                        math.transformOBB3(transform.leafMatrix, geometry.obb, this._obb);
                        math.OBB3ToAABB3(this._obb, this._aabb);
                    }
                    return this._aabb;
                }
            },

            /**
             * World-space oriented 3D boundary (OBB) of this Entity.
             *
             * The OBB is represented by a 32-element Float32Array containing the eight vertices of the box,
             * where each vertex is a homogeneous coordinate having [x,y,z,w] elements.
             *
             * @property obb
             * @final
             * @type {Float32Array}
             */
            obb: {
                get: function () {
                    if (this._obbDirty) {
                        this._obbDirty = false;
                        var transform = this._attached.transform;
                        var geometry = this._attached.geometry;
                        if (!transform) {
                            return geometry.obb;
                        }
                        if (!this._obb) {
                            this._obb = xeogl.math.OBB3();
                        }
                        xeogl.math.transformOBB3(transform.leafMatrix, geometry.obb, this._obb);
                    }
                    return this._obb;
                }
            },

            /**
             * World-space vertex positions of this Entity.
             *
             * These are internally generated on-demand and cached. To free the cached
             * vertex World positions when you're done with them, set this property to null or undefined.
             *
             * @property worpdPositions
             * @type Float32Array
             * @final
             */
            worldPositions: {

                get: function () {
                    if (this._worldPositionsDirty) {
                        var positions = this.geometry.positions;
                        if (!this._worldPositions) {
                            this._worldPositions = new Float32Array(positions.length);
                        }
                        if (!this._attached.transform) {
                            this._worldPositions.set(positions);
                        } else {
                            xeogl.math.transformPositions3(this._attached.transform.leafMatrix, positions, this._worldPositions);
                        }
                        this._worldPositionsDirty = false;
                    }
                    return this._worldPositions;
                },

                set: function (value) {
                    if (value = undefined || value === null) {
                        this._worldPositions = null; // Release memory
                        this._worldPositionsDirty = true;
                    }
                }
            }
        },

        // Callbacks as members, to avoid GC churn

        _transformUpdated: function () {
            if (!this._transformDirty) {
                return;
            }
            this._attached.transform._buildLeafMatrix();
            this._setBoundaryDirty();
            this._transformDirty = false;
        },

        _setBoundaryDirty: function () {
            this._aabbDirty = true;
            this._obbDirty = true;
            this._worldPositionsDirty = true;

            //var lights = this._attached.lights;
            //if (lights) {
            //    lights._shadowsDirty(); // Need to re-render shadow maps
            //}

            /**
             Fired whenever this Entity's World-space boundary changes.

             Get the latest boundary from the Entity's {{#crossLink "Entity/aabb:property"}}{{/crossLink}}
             and {{#crossLink "Entity/obb:property"}}{{/crossLink}} properties.

             @event boundary
             */
            this.fire("boundary");
        },

        // Returns true if there is enough on this Entity to render something.
        _valid: function () {
            if (this.destroyed) {
                return false;
            }
            var geometry = this._attached.geometry;
            if (!geometry) {
                return false;
            }
            if (!geometry.created) {
                return false;
            }
            return true;
        },

        _compile: function () {

            if (this._objectId) {
                this._renderer.destroyObject(this._objectId);
                this._objectId = null;
            }

            var material = this.material._getState();
            var ghostMaterial = this.ghostMaterial._state;
            var outlineMaterial = this.outlineMaterial._state;
            var highlightMaterial = this.highlightMaterial._state;
            var selectedMaterial = this.selectedMaterial._state;
            var vertexBufs = this.geometry._getVertexBufs();
            var geometry = this.geometry._state;
            var modelTransform = this.transform._state;
            var modes = this._getState();

            var result = this._renderer.createObject(this.id, material, ghostMaterial, outlineMaterial, highlightMaterial, selectedMaterial,  vertexBufs, geometry, modelTransform, modes);

            if (this._loading) {
                this._loading = false;
                this.fire("loaded", true);
            }

            if (result.objectId) {
                this._objectId = result.objectId;

            } else if (result.errors) {
                var errors = result.errors.join("\n");
                this.error(errors);
                this.fire("error", errors);
            }
        },

        _getState: function () {
            this._makeHash();
            return this._state;
        },

        _makeHash: function () {
            var hash = [];
            var state = this._state;
            if (state.stationary) {
                hash.push("/s");
            }
            if (state.billboard === "none") {
                hash.push("/n");
            } else if (state.billboard === "spherical") {
                hash.push("/s");
            } else if (state.billboard === "cylindrical") {
                hash.push("/c");
            }
            if (state.receiveShadow) {
                hash.push("/rs");
            }
            hash.push(";");
            this._state.hash = hash.join("");
        },

        _destroy: function () {
            if (this._objectId) {
                this._renderer.destroyObject(this._objectId);
                this._objectId = null;
            }
        }
    });
})();
;/**
 * Components that influence the way entities are rendered with WebGL.
 *
 * @module xeogl
 * @submodule rendering
 */;/**
 A **Viewport** controls the canvas viewport for a {{#crossLink "Scene"}}{{/crossLink}}.

 <a href="../../examples/#effects_stereo_custom"><img src="../../../assets/images/screenshots/StereoEffect.png"></img></a>

 ## Overview

 * One Viewport per scene.
 * You can configure a Scene to render multiple times per frame, while setting the Viewport to different extents on each render.
 * Make a Viewport automatically size to its {{#crossLink "Scene"}}Scene's{{/crossLink}} {{#crossLink "Canvas"}}{{/crossLink}}
 by setting its {{#crossLink "Viewport/autoBoundary:property"}}{{/crossLink}} property ````true```` (default is ````false````).

 ## Examples

 * [Stereo effect using alternating viewports](../../examples/#effects_stereo_custom)

 ## Usage

 Configuring the Scene to render twice on each frame, each time to a separate viewport:

 ````Javascript
 // Load glTF model
 var model = new xeogl.GLTFModel({
    src: "models/gltf/GearboxAssy/glTF-MaterialsCommon/GearboxAssy.gltf"
 });

 var scene = model.scene;
 var viewport = scene.viewport;

 // Configure Scene to render twice for each frame
 scene.passes = 2; // Default is 1
 scene.clearEachPass = false; // Default is false

 // Render to a separate viewport on each render

 var viewport = scene.viewport;
 viewport.autoBoundary = false;

 scene.on("rendering", function (e) {
     switch (e.pass) {
         case 0:
             viewport.boundary = [0, 0, 200, 200]; // xmin, ymin, width, height
             break;

         case 1:
             viewport.boundary = [200, 0, 200, 200];
             break;
     }
 });
 ````

 @class Viewport
 @module xeogl
 @submodule rendering
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}{{/crossLink}}, creates this Viewport within the
 default {{#crossLink "Scene"}}{{/crossLink}} when omitted.
 @param [cfg] {*} Viewport configuration
 @param [cfg.id] {String} Optional ID, unique among all components in the parent
 {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Viewport.
 @param [cfg.boundary] {Array of Number} Canvas-space Viewport boundary, given as
 (min, max, width, height). Defaults to the size of the parent
 {{#crossLink "Scene"}}Scene's{{/crossLink}} {{#crossLink "Canvas"}}{{/crossLink}}.
 @param [cfg.autoBoundary=false] {Boolean} Indicates whether this Viewport's {{#crossLink "Viewport/boundary:property"}}{{/crossLink}}
 automatically synchronizes with the size of the parent {{#crossLink "Scene"}}Scene's{{/crossLink}} {{#crossLink "Canvas"}}{{/crossLink}}.

 @extends Component
 */
(function () {

    "use strict";

    xeogl.Viewport = xeogl.Component.extend({

        type: "xeogl.Viewport",

        _init: function (cfg) {

            this._state = new xeogl.renderer.Viewport({
                boundary: [0, 0, 100, 100]
            });

            this.boundary = cfg.boundary;
            this.autoBoundary = cfg.autoBoundary;
        },

        _props: {

            /**
             The canvas-space boundary of this Viewport, indicated as [min, max, width, height].

             Defaults to the size of the parent
             {{#crossLink "Scene"}}Scene's{{/crossLink}} {{#crossLink "Canvas"}}{{/crossLink}}.

             Ignores attempts to set value when {{#crossLink "Viewport/autoBoundary:property"}}{{/crossLink}} is ````true````.

             Fires a {{#crossLink "Viewport/boundary:event"}}{{/crossLink}} event on change.

             @property boundary
             @default [size of Scene Canvas]
             @type {Array of Number}
             */
            boundary: {

                set: function (value) {

                    if (this._autoBoundary) {
                        return;
                    }

                    if (!value) {

                        var canvasBoundary = this.scene.canvas.boundary;

                        var width = canvasBoundary[2];
                        var height = canvasBoundary[3];

                        value = [0, 0, width, height];
                    }

                    this._state.boundary = value;

                    this._renderer.imageDirty();

                    /**
                     Fired whenever this Viewport's {{#crossLink "Viewport/boundary:property"}}{{/crossLink}} property changes.

                     @event boundary
                     @param value {Boolean} The property's new value
                     */
                    this.fire("boundary", this._state.boundary);
                },

                get: function () {
                    return this._state.boundary;
                }
            },

            /**
             Indicates whether this Viewport's {{#crossLink "Viewport/boundary:property"}}{{/crossLink}} automatically
             synchronizes with the size of the parent {{#crossLink "Scene"}}Scene's{{/crossLink}} {{#crossLink "Canvas"}}{{/crossLink}}.

             When set true, then this Viewport will fire a {{#crossLink "Viewport/boundary/event"}}{{/crossLink}} whenever
             the {{#crossLink "Canvas"}}{{/crossLink}} resizes. Also fires that event as soon as this ````autoBoundary````
             property is changed.

             Fires a {{#crossLink "Viewport/autoBoundary:event"}}{{/crossLink}} event on change.

             @property autoBoundary
             @default false
             @type Boolean
             */
            autoBoundary: {

                set: function (value) {

                    value = !!value;

                    if (value === this._autoBoundary) {
                        return;
                    }

                    this._autoBoundary = value;

                    if (this._autoBoundary) {
                        this._onCanvasSize = this.scene.canvas.on("boundary",
                            function (boundary) {

                                var width = boundary[2];
                                var height = boundary[3];

                                this._state.boundary = [0, 0, width, height];

                                this._renderer.imageDirty();

                                /**
                                 Fired whenever this Viewport's {{#crossLink "Viewport/boundary:property"}}{{/crossLink}} property changes.

                                 @event boundary
                                 @param value {Boolean} The property's new value
                                 */
                                this.fire("boundary", this._state.boundary);

                            }, this);

                    } else if (this._onCanvasSize) {
                        this.scene.canvas.off(this._onCanvasSize);
                        this._onCanvasSize = null;
                    }

                    /**
                     Fired whenever this Viewport's {{#crossLink "autoBoundary/autoBoundary:property"}}{{/crossLink}} property changes.

                     @event autoBoundary
                     @param value The property's new value
                     */
                    this.fire("autoBoundary", this._autoBoundary);
                },

                get: function () {
                    return this._autoBoundary;
                }
            }
        },

        _getState: function () {
            return this._state;
        }
    });

})();
;/**
 * Modelling transform components.
 *
 * @module xeogl
 * @submodule transforms
 */;/**
 A **Transform** is a modelling, viewing or projection transformation.

 ## Overview

 * Sub-classes of Transform include: {{#crossLink "Translate"}}{{/crossLink}},
 {{#crossLink "Scale"}}{{/crossLink}}, {{#crossLink "Rotate"}}{{/crossLink}}, {{#crossLink "Quaternion"}}{{/crossLink}},
 {{#crossLink "Lookat"}}{{/crossLink}}, {{#crossLink "Perspective"}}{{/crossLink}}, {{#crossLink "Frustum"}}{{/crossLink}}
 and {{#crossLink "Ortho"}}{{/crossLink}}.
 * Instances of {{#crossLink "Transform"}}{{/crossLink}} and its sub-classes may be connected into hierarchies.

 * When an {{#crossLink "Entity"}}{{/crossLink}} or {{#crossLink "Model"}}{{/crossLink}} is connected to a leaf {{#crossLink "Transform"}}{{/crossLink}}
 within a {{#crossLink "Transform"}}{{/crossLink}} hierarchy, it will be transformed by each {{#crossLink "Transform"}}{{/crossLink}}
 on the path up to the root, in that order.

 <img src="../../../assets/images/Transform.png"></img>

 ## Examples

 * [Modelling transform hierarchy](../../examples/#transforms_entity_hierarchy)
 * [Attaching transforms to Models, via constructor](../../examples/#transforms_model_configureTransform)
 * [Attaching transforms to Models, via property](../../examples/#transforms_model_attachTransform)

 ## Usage

 In this example we'll create the table shown below, which consists of five {{#crossLink "Entity"}}Entities{{/crossLink}}
 that share a {{#crossLink "BoxGeometry"}}{{/crossLink}} and each connect to a different leaf within a hierarchy of
 {{#crossLink "Translate"}}{{/crossLink}}, {{#crossLink "Rotate"}}{{/crossLink}} and {{#crossLink "Scale"}}{{/crossLink}}
 components. Each {{#crossLink "Entity"}}{{/crossLink}} also has its own {{#crossLink "PhongMaterial"}}{{/crossLink}} to
 give it a distinct color.

 <img src="../../../assets/images/transformHierarchy.png"></img>

 ````javascript
 // Shared Geometry
 var boxGeometry = new xeogl.BoxGeometry();

 // Position of entire table
 var tablePos = new xeogl.Translate({
    xyz: [0, 6, 0]
 });

 // Orientation of entire table
 var tableRotate = new xeogl.Rotate({
    xyz: [1, 1, 1],
    angle: 0,
    parent: tablePos
 });

 // Red table leg
 var tableLeg1 = new xeogl.Entity({
    geometry: boxGeometry,
    transform: new xeogl.Scale({
        xyz: [1, 3, 1],
        parent: new xeogl.Translate({
            xyz: [-4, -6, -4],
            parent: tableRotate
        })
    }),
    material: new xeogl.PhongMaterial({
        diffuse: [1, 0.3, 0.3]
    })
 });

 // Green table leg
 var tableLeg2 = new xeogl.Entity({
    geometry: boxGeometry,
    transform: new xeogl.Scale({
        xyz: [1, 3, 1],
        parent: new xeogl.Translate({
            xyz: [4, -6, -4],
            parent: tableRotate
        })
    }),
    material: new xeogl.PhongMaterial({
        diffuse: [0.3, 1.0, 0.3]
    })
 });

 // Blue table leg
 var tableLeg3 = new xeogl.Entity({
    geometry: boxGeometry,
    transform: new xeogl.Scale({
        xyz: [1, 3, 1],
        parent: new xeogl.Translate({
            xyz: [4, -6, 4],
            parent: tableRotate
        })
    }),
    material: new xeogl.PhongMaterial({
        diffuse: [0.3, 0.3, 1.0]
    })
 });

 // Yellow table leg
 var tableLeg4 = new xeogl.Entity({
    geometry: boxGeometry,
    transform: new xeogl.Scale({
        xyz: [1, 3, 1],
        parent: new xeogl.Translate({
            xyz: [-4, -6, 4],
            parent: tableRotate
        })
    }),
    material: new xeogl.PhongMaterial({
        diffuse: [1.0, 1.0, 0.0]
    })
 });

 // Purple table top
 var tableTop = new xeogl.Entity({
    geometry: boxGeometry,
    transform: new xeogl.Scale({
        xyz: [6, 0.5, 6],
        parent: new xeogl.Translate({
            xyz: [0, -3, 0],
            parent: tableRotate
        })
    }),
    material: new xeogl.PhongMaterial({
        diffuse: [1.0, 0.3, 1.0]
    })
 });

 // Zoom camera out a bit
 // Get the Camera from one of the Entities
 tableTop.camera.view.zoom(10);

 // Spin the entire table

 var angle = 0;

 scene.on("tick", function () {
    angle += 0.5;
    tableRotate.angle = angle;
 });
 ````

 @class Transform
 @module xeogl
 @submodule transforms
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Transform in the
 default {{#crossLink "Scene"}}Scene{{/crossLink}}  when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 You only need to supply an ID if you need to be able to find the Transform by ID within the {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Transform.
 @param [cfg.parent] {String|Transform} ID or instance of a parent Transform within the same {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.postMultiply=true] {Boolean} Flag that indicates whether this Transform is post-multiplied (default) or
 pre-multiplied by its {{#crossLink "Transform/parent:property"}}{{/crossLink}} Transform.
 @param [cfg.matrix=[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]] {Float32Array} One-dimensional, sixteen element array of elements for the Transform, an identity matrix by default.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Transform = xeogl.Component.extend({

        type: "xeogl.Transform",

        _init: function (cfg) {

            this._onParentUpdated = null;
            this._onParentDestroyed = null;

            this._matrix = xeogl.math.identityMat4(xeogl.math.mat4());
            this._leafMatrix = null;
            this._leafNormalMatrix = null;

            this._leafMatrixDirty = true;
            this._leafNormalMatrixDirty = true;

            var self = this;

            this._state = new xeogl.renderer.Transform({

                // Lazy-generate leaf matrices as we render because it's only
                // at this point that we actually know that we need them.

                getMatrix: function () {
                    if (self._leafMatrixDirty) { // TODO: Or schedule matrix rebuild to task queue if not urgent?
                        self._buildLeafMatrix();
                    }
                    return self._leafMatrix;
                },

                getNormalMatrix: function () {
                    if (self._leafNormalMatrixDirty) {
                        self._buildLeafNormalMatrix();
                    }
                    return self._leafNormalMatrix;
                }
            });

            this.parent = cfg.parent;
            this.matrix = cfg.matrix;
            this.postMultiply = cfg.postMultiply;

            xeogl.stats.memory.transforms++;
        },

        _parentUpdated: function () {

            this._leafMatrixDirty = true;

            /**
             * Fired whenever this Transform's {{#crossLink "Transform/leafMatrix:property"}}{{/crossLink}} property changes.
             *
             * This event does not carry the updated property value. Instead, subscribers will need to read
             * that property again to get its updated value (which may be lazy-computed then).
             *
             * @event updated
             */
            this.fire("updated", true);
        },

        // This is called if necessary when reading "leafMatrix", to update that property.
        // It's also called by Entity when the Transform is the leaf to which the
        // Entity is attached, in response to an "updated" event from the Transform.

        _buildLeafMatrix: function () {

            if (!this._leafMatrixDirty) {
                return;
            }

            if (!this._leafMatrix) {
                this._leafMatrix = xeogl.math.mat4();
            }

            if (this._build && this._buildScheduled) {
                this._build();
                this._buildScheduled = false;
            }

            if (!this._parent) {

                // No parent Transform

                for (var i = 0, len = this._matrix.length; i < len; i++) {
                    this._leafMatrix[i] = this._matrix[i];
                }

            } else {

                // Multiply parent's leaf matrix by this matrix,
                // store result in this leaf matrix

                if (this._postMultiply) {
                    xeogl.math.mulMat4(this._parent.leafMatrix, this._matrix, this._leafMatrix);
                } else {
                    xeogl.math.mulMat4(this._matrix, this._parent.leafMatrix, this._leafMatrix);
                }
            }

            this._renderer.imageDirty();

            this._leafMatrixDirty = false;
            this._leafNormalMatrixDirty = true;
        },

        _buildLeafNormalMatrix: function () {

            if (this._leafMatrixDirty) {
                this._buildLeafMatrix();
            }

            if (!this._leafNormalMatrix) {
                this._leafNormalMatrix = xeogl.math.mat4();
            }

            xeogl.math.inverseMat4(this._leafMatrix, this._leafNormalMatrix);
            xeogl.math.transposeMat4(this._leafNormalMatrix);

            // this._renderer.imageDirty();

            this._leafNormalMatrixDirty = false;
        },

        _props: {

            /**
             * The parent Transform.
             *
             * @property parent
             * @type Transform
             */
            parent: {

                set: function (value) {

                    // Disallow cycle

                    if (value) {

                        var id = this.id;

                        for (var value2 = value; value2; value2 = value2._parent) {

                            if (id === value2.id) {
                                this.error("Not allowed to attach Transform as parent of itself - ignoring");
                                return;
                            }
                        }
                    }

                    // Unsubscribe from old parent's events

                    if (this._parent && (!value || value.id !== this._parent.id)) {
                        this._parent.off(this._onParentUpdated);
                        this._parent.off(this._onParentDestroyed);
                    }

                    this._parent = value;

                    if (this._parent) {
                        this._onParentUpdated = this._parent.on("updated", this._parentUpdated, this);
                        this._onParentDestroyed = this._parent.on("destroyed", this._parentUpdated, this);
                    }

                    this._parentUpdated();
                },

                get: function () {
                    return this._parent;
                }
            },

            /**
             * Flag that indicates whether this Transform is post-multiplied (default) or pre-multiplied by
             * its {{#crossLink "Transform/parent:property"}}{{/crossLink}} Transform.
             *
             * @property postMultiply
             * @default true
             * @type Boolean
             */
            postMultiply: {

                set: function (value) {

                    value = value !== false;

                    if (this._postMultiply === value) {
                        return;
                    }

                    this._postMultiply = value;

                    this._leafMatrixDirty = true;

                    this._renderer.imageDirty();

                    this.fire("updated", true);
                },

                get: function () {
                    return this._postMultiply;
                }
            },

            /**
             * The Transform's local matrix.
             *
             * Fires a {{#crossLink "Transform/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property matrix
             * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
             * @type {Float32Array}
             */
            matrix: {

                set: function (value) {

                    this._matrix.set(value || xeogl.math.identityMat4());

                    this._leafMatrixDirty = true;

                    this._renderer.imageDirty();

                    /**
                     * Fired whenever this Transform's {{#crossLink "Transform/matrix:property"}}{{/crossLink}} property changes.
                     * @event matrix
                     * @param value The property's new value
                     */
                    this.fire("matrix", this._matrix);

                    this.fire("updated", true);
                },

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._matrix;
                }
            },

            /**
             * Returns the product of all {{#crossLink "Transform/matrix:property"}}{{/crossLink}}'s on Transforms
             * on the path via {{#crossLink "Transform/parent:property"}}{{/crossLink}} up to the root.
             *
             * The value of this property will have a fresh value after each
             * {{#crossLink "Transform/updated:property"}}{{/crossLink}} event, which is fired whenever any Transform
             * on the path receives an update for its {{#crossLink "Transform/matrix:property"}}{{/crossLink}} or
             * {{#crossLink "Transform/matrix:property"}}{{/crossLink}} property.
             *
             * @property leafMatrix
             * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
             * @type {Float32Array}
             */
            leafMatrix: {

                get: function () {

                    if (this._leafMatrixDirty) {
                        this._buildLeafMatrix();
                    }

                    return this._leafMatrix;
                }
            },

            /**
             * Returns the product of all {{#crossLink "Transform/normalMatrix:property"}}{{/crossLink}}'s on Transforms
             * on the path via {{#crossLink "Transform/parent:property"}}{{/crossLink}} up to the root.
             *
             * The value of this property will have a fresh value after each
             * {{#crossLink "Transform/updated:property"}}{{/crossLink}} event, which is fired whenever any Transform
             * on the path receives an update for its {{#crossLink "Transform/matrix:property"}}{{/crossLink}} or
             * {{#crossLink "Transform/matrix:property"}}{{/crossLink}} property.
             *
             * @property leafNormalMatrix
             * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
             * @type {Float32Array}
             */
            leafNormalMatrix: {

                get: function () {

                    if (this._leafMatrixDirty) {
                        this._buildLeafNormalMatrix();
                    }

                    return this._leafNormalMatrix;
                }
            }
        },

        _destroy: function () {
            if (this._parent) {
                this._parent.off(this._onParentUpdated);
                this._parent.off(this._onParentDestroyed);
            }
            xeogl.stats.memory.transforms--;
        }
    });

})();
;/**
 A **Rotate** is a {{#crossLink "Transform"}}{{/crossLink}} that rotates associated {{#crossLink "Entity"}}Entities{{/crossLink}} or {{#crossLink "Model"}}Models{{/crossLink}} about an axis vector.

 ## Overview

 * Instances of {{#crossLink "Transform"}}{{/crossLink}} and its sub-classes may be connected into hierarchies.
 * When an {{#crossLink "Entity"}}{{/crossLink}} or {{#crossLink "Model"}}{{/crossLink}} is connected to a leaf {{#crossLink "Transform"}}{{/crossLink}}
 within a {{#crossLink "Transform"}}{{/crossLink}} hierarchy, it will be transformed by each {{#crossLink "Transform"}}{{/crossLink}}
 on the path up to the root, in that order.


 <img src="../../../assets/images/Rotate.png"></img>

 ## Examples

 * [Modeling transform hierarchy](../../examples/#transforms_entity_hierarchy)

 ## Usage

 In this example we have two {{#crossLink "Entity"}}Entities{{/crossLink}} that are transformed by a hierarchy that contains
 Rotate, {{#crossLink "Translate"}}{{/crossLink}} and {{#crossLink "Scale"}}{{/crossLink}} transforms.
 The Entities share the same {{#crossLink "BoxGeometry"}}{{/crossLink}}.<br>

 ````javascript
 var rotate = new xeogl.Rotate({
    xyz: [0, 1, 0], // Rotate 30 degrees about Y axis
    angle: 30
 });

 var translate1 = new xeogl.Translate({
    parent: rotate,
    xyz: [-5, 0, 0] // Translate along -X axis
 });

 var translate2 = new xeogl.Translate({
    parent: rotate,
    xyz: [5, 0, 0] // Translate along +X axis
 });

 var scale = new xeogl.Scale({
    parent: translate2,
    xyz: [1, 2, 1] // Scale x2 on Y axis
 });

 var geometry = new xeogl.Geometry(scene); // Defaults to a 2x2x2 box

 var Entity1 = new xeogl.Entity({
    transform: translate1,
    geometry: geometry
 });

 var Entity2 = new xeogl.Entity({
    transform: scale,
    geometry: geometry
 });
 ````

 Since everything in xeogl is dynamically editable, we can restructure the transform hierarchy at any time.

 Let's insert a {{#crossLink "Scale"}}{{/crossLink}} between the first Translate and the first {{#crossLink "Entity"}}{{/crossLink}}:

 ````javascript
 var scale2 = new xeogl.Scale({
    parent: translate1,
    xyz: [1, 1, 2] // Scale x2 on Z axis
 });

 Entity2.transform = scale2;
 ````

 Let's start spinning the {{#crossLink "Rotate"}}{{/crossLink}}:

 ````javascript
 // Rotate 0.2 degrees on each frame
 scene.on("tick", function(e) {
    rotate.angle += 0.2;
 });
 ````
 @class Rotate
 @module xeogl
 @submodule transforms
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Rotate in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Rotate.
 @param [cfg.parent] {String|Transform} ID or instance of a parent {{#crossLink "Transform"}}{{/crossLink}} within the same {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.xyz=[0,1,0]] {Float32Array} Axis of rotation.
 @param [cfg.angle=0] {Number} Angle of rotation in degrees.
 @extends Transform
 */
(function () {

    "use strict";

    xeogl.Rotate = xeogl.Transform.extend({

        type: "xeogl.Rotate",

        _init: function (cfg) {

            this._super(cfg);

            this.xyz = cfg.xyz;
            this.angle = cfg.angle;
        },

        _update: function () {
            if (this._xyz[0] === 0 && this._xyz[1] === 0 && this._xyz[2] === 0) {
                this.warn("Rotation axis is [0,0,0] - won't build matrix.");
                return;
            }
            this.matrix = xeogl.math.rotationMat4v(this._angle * xeogl.math.DEGTORAD, this._xyz, this._matrix);
        },

        _props: {

            /**
             * Vector indicating the axis of rotation.
             *
             * @property xyz
             * @default [0,1,0]
             * @type {Float32Array}
             */
            xyz: {

                set: function (value) {
                    (this._xyz = this._xyz || new xeogl.math.vec3()).set(value || [0, 1, 0]);
                    this._needUpdate(0);
                },

                get: function () {
                    return this._xyz;
                }
            },

            /**
             * Angle of rotation in degrees.
             *
             * @property angle
             * @default 0
             * @type {Number}
             */
            angle: {

                set: function (value) {
                    this._angle = value || 0;
                    this._needUpdate(0);
                },

                get: function () {
                    return this._angle;
                }
            }
        }
    });

})();
;/**
 A **Quaternion** is a {{#crossLink "Transform"}}{{/crossLink}} that rotates associated {{#crossLink "Entity"}}Entities{{/crossLink}} or {{#crossLink "Model"}}Models{{/crossLink}}.

 ## Overview

 * Instances of {{#crossLink "Transform"}}{{/crossLink}} and its sub-classes may be connected into hierarchies.
 * When an {{#crossLink "Entity"}}{{/crossLink}} or {{#crossLink "Model"}}{{/crossLink}} is connected to a
 leaf {{#crossLink "Transform"}}{{/crossLink}} within a {{#crossLink "Transform"}}{{/crossLink}} hierarchy, it will be
 transformed by each {{#crossLink "Transform"}}{{/crossLink}} on the path up to the root, in that order.

 <img src="../../../assets/images/Quaternion.png"></img>

 ## Usage

 In this example we have two {{#crossLink "Entity"}}Entities{{/crossLink}} that are transformed by a hierarchy that contains
 Quaternion, {{#crossLink "Translate"}}{{/crossLink}} and {{#crossLink "Scale"}}{{/crossLink}} transforms.
 The Entities share the same {{#crossLink "BoxGeometry"}}{{/crossLink}}.<br>

 ````javascript
 var quaternion = new xeogl.Quaternion({
    xyzw: [0, 0, 0, 1], // Unit quaternion
 });

 var translate1 = new xeogl.Translate({
   parent: quaternion,
   xyz: [-5, 0, 0] // Translate along -X axis
 });

 var translate2 = new xeogl.Translate({
   parent: quaternion,
   xyz: [5, 0, 0] // Translate along +X axis
 });

 var scale = new xeogl.Scale({
   parent: translate2,
   xyz: [1, 2, 1] // Scale x2 on Y axis
 });

 var geometry = new xeogl.BoxGeometry();

 var entity1 = new xeogl.Entity(scene, {
   transform: translate1,
   geometry: geometry
 });

 var entity2 = new xeogl.Entity({
   transform: scale,
   geometry: geometry
 });
 ````

 Since everything in xeogl is dynamically editable, we can restructure the transform hierarchy at any time.

 Let's insert a {{#crossLink "Scale"}}{{/crossLink}} between the first Translate and the first {{#crossLink "Entity"}}{{/crossLink}}:

 ````javascript
 var scale2 = new xeogl.Scale({
   parent: translate1,
   xyz: [1, 1, 2] // Scale x2 on Z axis
 });

 Entity2.transform = scale2;
 ````

 Let's spin the Quaternion:

 ````javascript
 // Rotate 0.2 degrees about Y-axis on each frame
 scene.on("tick", function(e) {
        quaternion.rotate([0, 1, 0, 0.2]);
    });
 ````
 @class Quaternion
 @module xeogl
 @submodule transforms
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Quaternion in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Quaternion.
 @param [cfg.parent] {String|Transform} ID or instance of a parent {{#crossLink "Transform"}}{{/crossLink}} within the same {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.xyzw=[0,0,0,1]] {Array(Number)} The initial Quaternion elements.
 @extends Transform
 */
(function () {

    "use strict";

    xeogl.Quaternion = xeogl.Transform.extend({

        type: "xeogl.Quaternion",

        _init: function (cfg) {

            this._super(cfg);

            this.xyzw = cfg.xyzw;
        },

        _props: {

            /**

             The quaternion elements.

             @property xyzw
             @default [0,0,0,1]
             @type {Float32Array}
             */
            xyzw: {

                set: function (value) {
                    var math = xeogl.math;
                    (this._xyzw = this._xyzw || new math.vec4()).set(value || math.identityQuaternion());
                    this.matrix = math.quaternionToMat4(this._xyzw, this._matrix || (this._matrix = xeogl.math.identityMat4()));
                },

                get: function () {
                    return this._xyzw;
                }
            }
        },

        /**
         Rotates this Quaternion.
         @method rotate
         @param {Float32Array} angleAxis Rotation in angle-axis form.
         */
        rotate: (function () {
            var math = xeogl.math;
            var tempAngleAxis = math.vec4();
            var tempQuat = math.vec4();
            return function (angleAxis) {
                // TODO: Make API work in radians so we don't have to do this?:
                tempAngleAxis[0] = angleAxis[0];
                tempAngleAxis[1] = angleAxis[1];
                tempAngleAxis[2] = angleAxis[2];
                tempAngleAxis[3] = angleAxis[3] * math.DEGTORAD;
                math.angleAxisToQuaternion(tempAngleAxis, tempQuat);
                this.xyzw = math.mulQuaternions(this._xyzw, tempQuat, this._xyzw);
            };
        })()
    });
})();;/**
 A **Scale** is a {{#crossLink "Transform"}}{{/crossLink}} that scales associated {{#crossLink "Entity"}}Entities{{/crossLink}} or {{#crossLink "Model"}}Models{{/crossLink}}.

 ## Overview

 * Instances of {{#crossLink "Transform"}}{{/crossLink}} and its sub-classes may be connected into hierarchies.
 * When an {{#crossLink "Entity"}}{{/crossLink}} or {{#crossLink "Model"}}{{/crossLink}} is connected to a leaf {{#crossLink "Transform"}}{{/crossLink}}
 within a {{#crossLink "Transform"}}{{/crossLink}} hierarchy, it will be transformed by each {{#crossLink "Transform"}}{{/crossLink}}
 on the path up to the root, in that order.

 <img src="../../../assets/images/Scale.png"></img>

 ## Examples

 * [Modeling transform hierarchy](../../examples/#transforms_entity_hierarchy)

 ## Usage

 In this example we have two {{#crossLink "Entity"}}Entities{{/crossLink}} that are transformed by a hierarchy that contains
 {{#crossLink "Rotate"}}{{/crossLink}}, {{#crossLink "Translate"}}{{/crossLink}} and Scale transforms.
 The Entities share the same {{#crossLink "BoxGeometry"}}{{/crossLink}}.<br>

 ````javascript
 var rotate = new xeogl.Rotate({
    xyz: [0, 1, 0], // Rotate 30 degrees about Y axis
    angle: 30
 });

 var translate1 = new xeogl.Translate({
    parent: rotate,
    xyz: [-5, 0, 0] // Translate along -X axis
 });

 var translate2 = new xeogl.Translate({
    parent: rotate,
    xyz: [5, 0, 0] // Translate along +X axis
 });

 var scale = new xeogl.Scale({
    parent: translate2,
    xyz: [1, 2, 1] // Scale x2 on Y axis
 });

 var geometry = new xeogl.BoxGeometry();

 var entity1 = new xeogl.Entity({
    transform: translate1,
    geometry: geometry
 });

 var entity2 = new xeogl.Entity({
    transform: scale,
    geometry: geometry
 });
 ````

 Since everything in xeogl is dynamically editable, we can restructure the transform hierarchy at any time.

 Let's insert a {{#crossLink "Scale"}}{{/crossLink}} between the first Translate and the first {{#crossLink "Entity"}}{{/crossLink}}:

 ````javascript
 var scale2 = new xeogl.Scale({
    parent: translate1,
    xyz: [1, 1, 2] // Scale x2 on Z axis
 });

 entity2.transform = scale2;
 ````

 And just for fun, we'll start spinning the {{#crossLink "Rotate"}}{{/crossLink}}:

 ````javascript
 // Rotate 0.2 degrees on each frame
 scene.on("tick", function(e) {
    rotate.angle += 0.2;
 });
 ````

 @class Scale
 @module xeogl
 @submodule transforms
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Scale in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Scale.
 @param [cfg.parent] {String|Transform} ID or instance of a parent {{#crossLink "Transform"}}{{/crossLink}} within the same {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.xyz=[1,1,1]] {Float32Array} Scale factors.
 @extends Transform
 */
(function () {

    "use strict";

    xeogl.Scale = xeogl.Transform.extend({

        type: "xeogl.Scale",

        _init: function (cfg) {
            this._super(cfg);
            this.xyz = cfg.xyz;
        },

        _props: {

            /**
             * Vector indicating a scale factor for each axis.
             * @property xyz
             * @default [1,1,1]
             * @type {Float32Array}
             */
            xyz: {

                set: function (value) {
                    (this._xyz = this._xyz || new xeogl.math.vec3()).set(value || [1, 1, 1]);
                    this.matrix = xeogl.math.scalingMat4v(this._xyz, this._matrix);
                },

                get: function () {
                    return this._xyz;
                }
            }
        }
    });

})();
;/**
 A **Translate** is a {{#crossLink "Transform"}}{{/crossLink}} that translates associated {{#crossLink "Entity"}}Entities{{/crossLink}} or {{#crossLink "Model"}}Models{{/crossLink}}.

 ## Overview

 * Instances of {{#crossLink "Transform"}}{{/crossLink}} and its sub-classes may be connected into hierarchies.
 * When an {{#crossLink "Entity"}}{{/crossLink}} or {{#crossLink "Model"}}{{/crossLink}} is connected to a leaf {{#crossLink "Transform"}}{{/crossLink}}
 within a {{#crossLink "Transform"}}{{/crossLink}} hierarchy, it will be transformed by each {{#crossLink "Transform"}}{{/crossLink}}
 on the path up to the root, in that order.

 <img src="../../../assets/images/Translate.png"></img>

 ## Examples

 * [Modeling transform hierarchy](../../examples/#transforms_entity_hierarchy)

 ## Usage

 This example has two {{#crossLink "Entity"}}Entities{{/crossLink}} that are transformed by a hierarchy that contains
 {{#crossLink "Rotate"}}{{/crossLink}}, Translate and {{#crossLink "Scale"}}{{/crossLink}} transforms.
 The Entities share the same {{#crossLink "BoxGeometry"}}{{/crossLink}}.<br>

 ````javascript
 var rotate = new xeogl.Rotate({
    xyz: [0, 1, 0], // Rotate 30 degrees about Y axis
    angle: 30
 });

 var translate1 = new xeogl.Translate({
    parent: rotate,
    xyz: [-5, 0, 0] // Translate along -X axis
 });

 var translate2 = new xeogl.Translate({
    parent: rotate,
    xyz: [5, 0, 0] // Translate along +X axis
 });

 var scale = new xeogl.Scale({
    parent: translate2,
    xyz: [1, 2, 1] // Scale x2 on Y axis
 });

 var geometry = new xeogl.BoxGeometry();

 var entity1 = new xeogl.Entity({
    transform: translate1,
    geometry: geometry
 });

 var entity2 = new xeogl.Entity({
    transform: scale,
    geometry: geometry
 });
 ````

 Since everything in xeogl is dynamically editable, we can restructure the transform hierarchy at any time.

 Let's insert a {{#crossLink "Scale"}}{{/crossLink}} between the first Translate and the first {{#crossLink "Entity"}}{{/crossLink}}:

 ````javascript
 var scale2 = new xeogl.Scale({
    parent: translate1,
    xyz: [1, 1, 2] // Scale x2 on Z axis
 });

 entity2.transform = scale2;
 ````

 And just for fun, we'll start updating the second {{#crossLink "Translate"}}{{/crossLink}}:

 ````javascript
 // Rotate 0.2 degrees on each frame
 scene.on("tick", function(e) {
    var xyz = translate2.xyz;
    xyz[0] += 0.2;
    translate2.xyz = xyz;
 });
 ````

 @class Translate
 @module xeogl
 @submodule transforms
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}} - creates this Translate in the default
 {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Translate.
 @param [cfg.parent] {String|Transform} ID or instance of a parent {{#crossLink "Transform"}}{{/crossLink}} within the same {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.xyz=[0,0,0]] {Float32Array} The translation vector
 @extends Transform
 */
(function () {

    "use strict";

    xeogl.Translate = xeogl.Transform.extend({

        type: "xeogl.Translate",

        _init: function (cfg) {

            this._super(cfg);

            this.xyz = cfg.xyz;
        },

        _props: {

            /**
             * Vector indicating a translation amount for each axis.
             *
             * @property xyz
             * @default [0,0,0]
             * @type {Float32Array}
             */
            xyz: {

                set: function (value) {
                    (this._xyz = this._xyz || new xeogl.math.vec3()).set(value || [0, 0, 0]);
                    this.matrix = xeogl.math.translationMat4v(this._xyz, this._matrix);
                },

                get: function () {
                    return this._xyz;
                }
            }
        }
    });
})();
;/**
 A **Camera** defines viewing and projection transforms for its {{#crossLink "Scene"}}{{/crossLink}}.

 ## Overview

 * One Camera per Scene
 * Controls viewing and projection transforms
 * Has methods to pan, zoom and orbit (or first-person rotation)
 * Dynamically configurable World-space "up" direction
 * Switchable between perspective, frustum and orthographic projections
 * Switchable gimbal lock
 * Can be "flown" to look at targets using a {{#crossLink "CameraFlightAnimation"}}{{/crossLink}}
 * Can be animated along a path using a {{#crossLink "CameraPathAnimation"}}{{/crossLink}}
 * Can follow a target using a {{#crossLink "CameraFollowAnimation"}}{{/crossLink}}

 ## Examples

 * [Perspective projection](../../examples/#camera_perspective)
 * [Orthographic projection](../../examples/#camera_orthographic)
 * [Frustum projection](../../examples/#camera_frustum)
 * [Camera with world Z-axis as "up"](../../examples/#camera_zAxisUp)
 * [Camera with world Y-axis as "up"](../../examples/#camera_yAxisUp)
 * [Automatically following an Entity with a Camera](../../examples/#camera_follow)
 * [Animating a Camera along a path](../../examples/#camera_path_interpolation)
 * [Architectural fly-through](../../examples/#importing_gltf_ModernOffice)

 ## Usage

 * [Getting the Camera](#getting)
 * [Moving around](#moving-around)
 * [Projection](#projection)
 * [Configuring World up direction](#configuring-world-up-direction)
 * [Gimbal locking](#gimbal-locking)

 ### Getting the Camera

 There is exactly one Camera per Scene:

 ````javascript
 var camera = myScene.camera;
 ````

 ### Moving around

 Get and set the Camera's absolute position at any time via its {{#crossLink "Camera/eye:property"}}{{/crossLink}},
 {{#crossLink "Camera/look:property"}}{{/crossLink}} and {{#crossLink "Camera/up:property"}}{{/crossLink}} properties:

 ````javascript
 camera.eye = [-10,0,0];
 camera.look = [-10,0,0];
 camera.up = [0,1,0];
 ````

 Get the view matrix:

 ````javascript
 var viewMatrix = camera.viewMatrix;
 var viewNormalMatrix = camera.normalMatrix;
 ````

 Listen for view matrix updates:

 ````javascript
 camera.on("matrix", function(matrix) { ... });
 ````

 Orbiting the {{#crossLink "Camera/look:property"}}{{/crossLink}} position:

 ````javascript
 camera.orbitYaw(20.0);
 camera.orbitPitch(10.0);
 ````

 First-person rotation, rotates {{#crossLink "Camera/look:property"}}{{/crossLink}}
 and {{#crossLink "Camera/up:property"}}{{/crossLink}} about {{#crossLink "Camera/eye:property"}}{{/crossLink}}:

 ````javascript
 camera.yaw(5.0);
 camera.pitch(-10.0);
 ````

 Panning along the Camera's local axis (ie. left/right, up/down, forward/backward):

 ````javascript
 camera.pan([-20, 0, 10]);
 ````

 Zoom to vary distance between {{#crossLink "Camera/eye:property"}}{{/crossLink}} and {{#crossLink "Camera/look:property"}}{{/crossLink}}:

 ````javascript
 camera.zoom(-5); // Move five units closer
 ````

 Get the current distance between {{#crossLink "Camera/eye:property"}}{{/crossLink}} and {{#crossLink "Camera/look:property"}}{{/crossLink}}:

 ````javascript
 var distance = camera.eyeLookDist;
 ````

 ### Projection

 For each projection type, the Camera has a Component to manage that projection's configuration. You can hot-switch the Camera
 between those projection types, while updating the properties of each projection component at any time.

 ````javascript
 camera.perspective.near = 0.4;
 camera.perspective.fov = 45;
 //...

 camera.ortho.near = 0.8;
 camera.ortho.far = 1000;
 //...

 camera.frustum.left = -1.0;
 camera.frustum.right = 1.0;
 camera.frustum.far = 1000.0;
 //...

 camera.projection = "perspective"; // Switch to perspective
 camera.projection = "frustum"; // Switch to frustum
 camera.projection = "ortho"; // Switch to ortho
 ````

 Get the projection matrix:

 ````javascript
 var projMatrix = camera.projMatrix;
 ````

 Listen for projection matrix updates:

 ````javascript
 camera.on("projMatrix", function(matrix) { ... });
 ````

 ### Configuring World up direction

 We can dynamically configure the direction that we consider to be "up" in the World-space coordinate system.

 Set the +Y axis as World "up" (convention in some modeling software):

 ````javascript
 camera.worldAxis = [
 1, 0, 0,    // Right
 0, 1, 0,    // Up
 0, 0,-1     // Forward
 ];
 ````

 Set the +Z axis as World "up" (convention in most CAD and BIM viewers):

 ````javascript
 camera.worldAxis = [
 1, 0, 0, // Right
 0, 0, 1, // Up
 0,-1, 0  // Forward
 ];
 ````

 The Camera has read-only convenience properties that provide each axis individually:

 ````javascript
 var worldRight = camera.worldRight;
 var worldForward = camera.worldForward;
 var worldUp = camera.worldUp;
 ````

 ### Gimbal locking

 By default, the Camera locks yaw rotation to pivot about the World-space "up" axis. We can dynamically lock and unlock that
 at any time:

 ````javascript
 camera.gimbalLock = false; // Yaw rotation now happens about Camera's local Y-axis
 camera.gimbalLock = true; // Yaw rotation now happens about World's "up" axis
 ````

 See: <a href="https://en.wikipedia.org/wiki/Gimbal_lock">https://en.wikipedia.org/wiki/Gimbal_lock</a>

 @class Camera
 @module xeogl
 @submodule camera
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this Camera within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent {{#crossLink "Scene"}}Scene{{/crossLink}}, generated automatically when omitted.
 You only need to supply an ID if you need to be able to find the Camera by ID within its parent {{#crossLink "Scene"}}Scene{{/crossLink}} later.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Camera.
 @extends Component
 */
(function () {

    "use strict";

    var math = xeogl.math;

    var tempVec3 = math.vec3();
    var tempVec3b = math.vec3();
    var tempVec3c = math.vec3();
    var tempVec3d = math.vec3();
    var tempVec3e = math.vec3();
    var tempVec3f = math.vec3();

    xeogl.Camera = xeogl.Component.extend({

        type: "xeogl.Camera",

        _init: function (cfg) {

            this._state = new xeogl.renderer.ViewTransform({
                matrix: math.mat4(),
                normalMatrix: math.mat4()
            });

            this._perspective = new xeogl.Perspective(this);
            this._ortho = new xeogl.Ortho(this);
            this._frustum = new xeogl.Frustum(this);
            this._project = this._perspective;

            var self = this;

            this._eye = math.vec3([0, 0, 10.0]);
            this._look = math.vec3([0, 0, 0]);
            this._up = math.vec3([0, 1, 0]);

            this._worldUp = math.vec3([0, 1, 0]);
            this._worldRight = math.vec3([1, 0, 0]);
            this._worldForward = math.vec3([0, 0, -1]);

            this.eye = cfg.eye;
            this.look = cfg.look;
            this.up = cfg.up;
            this.worldAxis = cfg.worldAxis;
            this.gimbalLock = cfg.gimbalLock;

            this.projection = cfg.projection;

            this._perspective.on("matrix", function () {
                if (self._projectionType === "perspective") {
                    self.fire("projMatrix", self._perspective.matrix);
                }
            });

            this._ortho.on("matrix", function () {
                if (self._projectionType === "ortho") {
                    self.fire("projMatrix", self._ortho.matrix);
                }
            });

            this._frustum.on("matrix", function () {
                if (self._projectionType === "frustum") {
                    self.fire("projMatrix", self._frustum.matrix);
                }
            });
        },

        _update: (function () {

            var eyeLookVec = math.vec3();
            var eyeLookVecNorm = math.vec3();
            var eyeLookOffset = math.vec3();
            var offsetEye = math.vec3();

            return function () {

                // In ortho mode, build the view matrix with an eye position that's translated
                // well back from look, so that the front clip plane doesn't unexpectedly cut
                // the front off the view (not a problem with perspective, since objects close enough
                // to be clipped by the front plane are usually too big to see anything of their cross-sections).

                var eye;
                if (this.projection === "ortho") {
                    math.subVec3(this._eye, this._look, eyeLookVec);
                    math.normalizeVec3(eyeLookVec, eyeLookVecNorm);
                    math.mulVec3Scalar(eyeLookVecNorm, 1000.0, eyeLookOffset);
                    math.addVec3(this._look, eyeLookOffset, offsetEye);
                    eye = offsetEye;
                } else {
                    eye = this._eye;
                }

                math.lookAtMat4v(eye, this._look, this._up, this._state.matrix);
                math.inverseMat4(this._state.matrix, this._state.normalMatrix);
                math.transposeMat4(this._state.normalMatrix);

                this._renderer.imageDirty();

                this.fire("matrix", this._state.matrix);
                this.fire("viewMatrix", this._state.matrix);
            };
        })(),

        /**
         * Rotates {{#crossLink "Camera/eye:property"}}{{/crossLink}} about {{#crossLink "Camera/look:property"}}{{/crossLink}}, around the {{#crossLink "Camera/up:property"}}{{/crossLink}} vector
         *
         * @method orbitYaw
         * @param {Number} angle Angle of rotation in degrees
         */
        orbitYaw: (function () {
            var mat = math.mat4();
            return function (angle) {

                var lookEyeVec = math.subVec3(this._eye, this._look, tempVec3);
                math.rotationMat4v(angle * 0.0174532925, this._gimbalLock ? this._worldUp : this._up, mat);
                lookEyeVec = math.transformPoint3(mat, lookEyeVec, tempVec3b);

                this.eye = math.addVec3(this._look, lookEyeVec, tempVec3c); // Set eye position as 'look' plus 'eye' vector
                this.up = math.transformPoint3(mat, this._up, tempVec3d); // Rotate 'up' vector
            };
        })(),

        /**
         * Rotates {{#crossLink "Camera/eye:property"}}{{/crossLink}} about {{#crossLink "Camera/look:property"}}{{/crossLink}} around the right axis (orthogonal to {{#crossLink "Camera/up:property"}}{{/crossLink}} and "look").
         *
         * @method orbitPitch
         * @param {Number} angle Angle of rotation in degrees
         */
        orbitPitch: (function () {
            var mat = math.mat4();
            return function (angle) {

                var eye2 = math.subVec3(this._eye, this._look, tempVec3);
                var left = math.cross3Vec3(math.normalizeVec3(eye2, tempVec3b), math.normalizeVec3(this._up, tempVec3c));
                math.rotationMat4v(angle * 0.0174532925, left, mat);
                eye2 = math.transformPoint3(mat, eye2, tempVec3d);

                this.eye = math.addVec3(eye2, this._look, tempVec3e);
                this.up = math.transformPoint3(mat, this._up, tempVec3f);
            };
        })(),

        /**
         * Rotates {{#crossLink "Camera/look:property"}}{{/crossLink}} about {{#crossLink "Camera/eye:property"}}{{/crossLink}}, around the {{#crossLink "Camera/up:property"}}{{/crossLink}} vector.
         *
         * @method yaw
         * @param {Number} angle Angle of rotation in degrees
         */
        yaw: (function () {
            var mat = math.mat4();
            return function (angle) {

                var look2 = math.subVec3(this._look, this._eye, tempVec3);
                math.rotationMat4v(angle * 0.0174532925, this._gimbalLock ? this._worldUp : this._up, mat);
                look2 = math.transformPoint3(mat, look2, tempVec3b);

                this.look = math.addVec3(look2, this._eye, tempVec3c);

                if (this._gimbalLock) {
                    this.up = math.transformPoint3(mat, this._up, tempVec3d);
                }
            };
        })(),

        /**
         * Rotates {{#crossLink "Camera/look:property"}}{{/crossLink}} about {{#crossLink "Camera/eye:property"}}{{/crossLink}}, around the right axis (orthogonal to {{#crossLink "Camera/up:property"}}{{/crossLink}} and "look").
         *
         * @method pitch
         * @param {Number} angle Angle of rotation in degrees
         */
        pitch: (function () {
            var mat = math.mat4();
            return function (angle) {

                var look2 = math.subVec3(this._look, this._eye, tempVec3);
                var left = math.cross3Vec3(math.normalizeVec3(look2, tempVec3b), math.normalizeVec3(this._up, tempVec3c));
                math.rotationMat4v(angle * 0.0174532925, left, mat);
                look2 = math.transformPoint3(mat, look2, tempVec3d);

                this.look = math.addVec3(look2, this._eye, tempVec3e);
                this.up = math.transformPoint3(mat, this._up, tempVec3f);
            };
        })(),

        /**
         * Pans the camera along the camera's local X, Y and Z axis.
         *
         * @method pan
         * @param pan The pan vector
         */
        pan: function (pan) {

            var eye2 = math.subVec3(this._eye, this._look, tempVec3);
            var vec = [0, 0, 0];
            var v;

            if (pan[0] !== 0) {
                var left = math.cross3Vec3(math.normalizeVec3(eye2, []), math.normalizeVec3(this._up, tempVec3b));
                v = math.mulVec3Scalar(left, pan[0]);
                vec[0] += v[0];
                vec[1] += v[1];
                vec[2] += v[2];
            }

            if (pan[1] !== 0) {
                v = math.mulVec3Scalar(math.normalizeVec3(this._up, tempVec3c), pan[1]);
                vec[0] += v[0];
                vec[1] += v[1];
                vec[2] += v[2];
            }

            if (pan[2] !== 0) {
                v = math.mulVec3Scalar(math.normalizeVec3(eye2, tempVec3d), pan[2]);
                vec[0] += v[0];
                vec[1] += v[1];
                vec[2] += v[2];
            }

            this.eye = math.addVec3(this._eye, vec, tempVec3e);
            this.look = math.addVec3(this._look, vec, tempVec3f);
        },

        /**
         * Increments/decrements zoom factor, ie. distance between {{#crossLink "Camera/eye:property"}}{{/crossLink}}
         * and {{#crossLink "Camera/look:property"}}{{/crossLink}}.
         *
         * @method zoom
         * @param delta
         */
        zoom: function (delta) {

            var vec = math.subVec3(this._eye, this._look, tempVec3);
            var lenLook = Math.abs(math.lenVec3(vec, tempVec3b));
            var newLenLook = Math.abs(lenLook + delta);

            if (newLenLook < 0.5) {
                return;
            }

            var dir = math.normalizeVec3(vec, tempVec3c);

            this.eye = math.addVec3(this._look, math.mulVec3Scalar(dir, newLenLook), tempVec3d);
        },

        _props: {

            /**
             * Position of this Camera's eye.
             *
             * Fires an {{#crossLink "Camera/eye:event"}}{{/crossLink}} event on change.
             *
             * @property eye
             * @default [0,0,10]
             * @type Float32Array
             */
            eye: {

                set: function (value) {

                    this._eye.set(value || [0, 0, 10]);
                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Camera's {{#crossLink "Camera/eye:property"}}{{/crossLink}} property changes.
                     *
                     * @event eye
                     * @param value The property's new value
                     */
                    this.fire("eye", this._eye);
                },

                get: function () {
                    return this._eye;
                }
            },

            /**
             * Position of this Camera's point-of-interest.
             *
             * Fires a {{#crossLink "Camera/look:event"}}{{/crossLink}} event on change.
             *
             * @property look
             * @default [0,0,0]
             * @type Float32Array
             */
            look: {

                set: function (value) {

                    this._look.set(value || [0, 0, 0]);
                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Camera's {{#crossLink "Camera/look:property"}}{{/crossLink}} property changes.
                     *
                     * @event look
                     * @param value The property's new value
                     */
                    this.fire("look", this._look);
                },

                get: function () {
                    return this._look;
                }
            },

            /**
             * Direction of this Camera's {{#crossLink "Camera/up:property"}}{{/crossLink}} vector.
             *
             * Fires an {{#crossLink "Camera/up:event"}}{{/crossLink}} event on change.
             *
             * @property up
             * @default [0,1,0]
             * @type Float32Array
             */
            up: {

                set: function (value) {

                    this._up.set(value || [0, 1, 0]);
                    this._needUpdate(0);

                    /**
                     * Fired whenever this Camera's {{#crossLink "Camera/up:property"}}{{/crossLink}} property changes.
                     *
                     * @event up
                     * @param value The property's new value
                     */
                    this.fire("up", this._up);
                },

                get: function () {
                    return this._up;
                }
            },

            /**
             * Indicates the up, right and forward axis of the World coordinate system.
             *
             * Has format: ````[rightX, rightY, rightZ, upX, upY, upZ, forwardX, forwardY, forwardZ]````
             *
             * @property worldAxis
             * @default [1, 0, 0, 0, 1, 0, 0, 0, 1]
             * @type Float32Array
             */
            worldAxis: {

                set: function (value) {

                    value = value || [1, 0, 0, 0, 1, 0, 0, 0, 1];

                    if (!this._worldAxis) {
                        this._worldAxis = new Float32Array(value);

                    } else {
                        this._worldAxis.set(value);
                    }

                    this._worldRight[0] = this._worldAxis[0];
                    this._worldRight[1] = this._worldAxis[1];
                    this._worldRight[2] = this._worldAxis[2];

                    this._worldUp[0] = this._worldAxis[3];
                    this._worldUp[1] = this._worldAxis[4];
                    this._worldUp[2] = this._worldAxis[5];

                    this._worldForward[0] = this._worldAxis[6];
                    this._worldForward[1] = this._worldAxis[7];
                    this._worldForward[2] = this._worldAxis[8];

                    /**
                     * Fired whenever this Camera's {{#crossLink "Camera/worldAxis:property"}}{{/crossLink}} property changes.
                     *
                     * @event worldAxis
                     * @param value The property's new value
                     */
                    this.fire("worldAxis", this._worldAxis);
                },

                get: function () {
                    return this._worldAxis;
                }
            },

            /**
             * Direction of World-space "up".
             *
             * @property worldUp
             * @default [0,1,0]
             * @type Float32Array
             * @final
             */
            worldUp: {

                get: function () {
                    return this._worldUp;
                }
            },

            /**
             * Direction of World-space "right".
             *
             * @property worldRight
             * @default [1,0,0]
             * @type Float32Array
             * @final
             */
            worldRight: {

                get: function () {
                    return this._worldRight;
                }
            },

            /**
             * Direction of World-space "forwards".
             *
             * @property worldForward
             * @default [0,0,-1]
             * @type Float32Array
             * @final
             */
            worldForward: {

                get: function () {
                    return this._worldForward;
                }
            },

            /**
             * Whether to lock yaw rotation to pivot about the World-space "up" axis.
             *
             * Fires a {{#crossLink "Camera/gimbalLock:event"}}{{/crossLink}} event on change.
             *
             * @property gimbalLock
             * @default true
             * @type Boolean
             */
            gimbalLock: {

                set: function (value) {

                    this._gimbalLock = value !== false;

                    /**
                     * Fired whenever this Camera's  {{#crossLink "Camera/gimbalLock:property"}}{{/crossLink}} property changes.
                     *
                     * @event gimbalLock
                     * @param value The property's new value
                     */
                    this.fire("gimbalLock", this._gimbalLock);
                },

                get: function () {
                    return this._gimbalLock;
                }
            },

            /**
             * Distance from "look" to "eye".
             * @property eyeLookDist
             * @type Number
             */
            eyeLookDist: {

                get: (function () {
                    var vec = new Float32Array(3);
                    return function () {
                        return math.lenVec3(math.subVec3(this._look, this._eye, vec));
                    };
                })()
            },

            /**
             * The Camera's viewing transformation matrix.
             *
             * Fires a {{#crossLink "Camera/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property matrix
             * @type {Float32Array}
             * @deprecated
             */
            matrix: {

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._state.matrix;
                }
            },

            /**
             * The Camera's viewing transformation matrix.
             *
             * Fires a {{#crossLink "Camera/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property viewMatrix
             * @type {Float32Array}
             */
            viewMatrix: {

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._state.matrix;
                }
            },

            /**
             * The Camera's viewing normal transformation matrix.
             *
             * Fires a {{#crossLink "Camera/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property normalMatrix
             * @type {Float32Array}
             * @deprecated
             */
            normalMatrix: {

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._state.normalMatrix;
                }
            },

            /**
             * The Camera's viewing normal transformation matrix.
             *
             * Fires a {{#crossLink "Camera/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property viewNormalMatrix
             * @type {Float32Array}
             */
            viewNormalMatrix: {

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._state.normalMatrix;
                }
            },

            /**
             * Camera's projection transformation projMatrix.
             *
             * Fires a {{#crossLink "Camera/projMatrix:event"}}{{/crossLink}} event on change.
             *
             * @property projMatrix
             * @type {Float32Array}
             */
            projMatrix: {

                get: function () {

                    return this[this.projection].matrix;
                }
            },

            /**
             * The perspective projection transform for this Camera.
             *
             * This is used while {{#crossLink "Camera/projection:property"}}{{/crossLink}} equals "perspective".
             *
             * @property perspective
             * @type Perspective
             * @final
             */
            perspective: {

                get: function () {
                    return this._perspective;
                }
            },

            /**
             * The orthographic projection transform for this Camera.
             *
             * This is used while {{#crossLink "Camera/projection:property"}}{{/crossLink}} equals "ortho".
             *
             * @property ortho
             * @type Ortho
             * @final
             */
            ortho: {

                get: function () {
                    return this._ortho;
                }
            },

            /**
             * The frustum projection transform for this Camera.
             *
             * This is used while {{#crossLink "Camera/projection:property"}}{{/crossLink}} equals "frustum".
             *
             * @property frustum
             * @type Frustum
             * @final
             */
            frustum: {

                get: function () {
                    return this._frustum;
                }
            },

            /**
             The active projection type.

             Accepted values are "perspective", "ortho" and "frustum".

             @property projection
             @default "perspective"
             @type {String}
             */
            projection: {

                set: function (value) {

                    value = value || "perspective";

                    if (this._projectionType === value) {
                        return;
                    }

                    if (value === "perspective") {
                        this._project = this._perspective;

                    } else if (value === "ortho") {
                        this._project = this._ortho;

                    } else if (value === "frustum") {
                        this._project = this._frustum;

                    } else {
                        this.error("Unsupported value for 'projection': " + value + " defaulting to 'perspective'");
                        this._project = this._perspective;
                        value = "perspective";
                    }

                    this._projectionType = value;

                    this._renderer.imageDirty();

                    this._update(); // Need to rebuild lookat matrix with full eye, look & up

                    this.fire("dirty");
                },

                get: function () {
                    return this._projectionType;
                }
            },

            /**
             * The active projection transform for this Camera.
             *
             * @property project
             * @type Transform
             * @final
             */
            project: {

                get: function () {
                    return this._project;
                }
            },

            view: { // Baackwards compat
                get: function () {
                    return this;
                }
            }
        }
    });
})();
;/**
 A **Frustum** defines a perspective projection as a frustum-shaped view volume for a {{#crossLink "Camera"}}Camera{{/crossLink}}.

 ## Overview

 * A {{#crossLink "Camera"}}Camera{{/crossLink}} has a Frustum to configure its frustum-based perspective projection mode.
 * A Frustum lets us explicitly set the positions of the left, right, top, bottom, near and far planes, which is useful
 for asymmetrical view volumes, such as those used for stereo viewing.
 * A Frustum's {{#crossLink "Frustum/near:property"}}{{/crossLink}} and {{#crossLink "Frustum/far:property"}}{{/crossLink}} properties
 specify the distances to the WebGL clipping planes.

 ## Examples

 * [Camera with frustum projection](../../examples/#camera_frustum)
 * [Stereo viewing with frustum projection](../../examples/#effects_stereo)

 ## Usage

 * See {{#crossLink "Camera"}}{{/crossLink}}

 @class Frustum
 @module xeogl
 @submodule camera
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this Frustum within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Frustum.
 @param [cfg.left=-1] {Number} Position of the Frustum's left plane on the View-space X-axis.
 @param [cfg.right=1] {Number} Position of the Frustum's right plane on the View-space X-axis.
 @param [cfg.bottom=-1] {Number} Position of the Frustum's bottom plane on the View-space Y-axis.
 @param [cfg.top=1] {Number} Position of the Frustum's top plane on the View-space Y-axis.
 @param [cfg.near=0.1] {Number} Position of the Frustum's near plane on the View-space Z-axis.
 @param [cfg.far=1000] {Number} Position of the Frustum's far plane on the positive View-space Z-axis.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Frustum = xeogl.Component.extend({

        type: "xeogl.Frustum",

        _init: function (cfg) {

            this._state = new xeogl.renderer.ProjTransform({
                matrix: xeogl.math.mat4()
            });

            this._left = -1.0;
            this._right = 1.0;
            this._bottom = -1.0;
            this._top = 1.0;
            this._near = 0.1;
            this._far = 10000.0;

            // Set component properties

            this.left = cfg.left;
            this.right = cfg.right;
            this.bottom = cfg.bottom;
            this.top = cfg.top;
            this.near = cfg.near;
            this.far = cfg.far;
        },

        _update: function () {

            xeogl.math.frustumMat4(this._left, this._right, this._bottom, this._top, this._near, this._far, this._state.matrix);

            this._renderer.imageDirty();

            this.fire("matrix", this._state.matrix);
        },

        _props: {

            /**
             Position of this Frustum's left plane on the View-space X-axis.

             Fires a {{#crossLink "Frustum/left:event"}}{{/crossLink}} event on change.

             @property left
             @default -1.0
             @type Number
             */
            left: {

                set: function (value) {

                    this._left = (value !== undefined && value !== null) ? value : -1.0;

                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Frustum's {{#crossLink "Frustum/left:property"}}{{/crossLink}} property changes.
                     *
                     * @event left
                     * @param value The property's new value
                     */
                    this.fire("left", this._left);
                },

                get: function () {
                    return this._left;
                }
            },

            /**
             * Position of this Frustum's right plane on the View-space X-axis.
             *
             * Fires a {{#crossLink "Frustum/right:event"}}{{/crossLink}} event on change.
             *
             * @property right
             * @default 1.0
             * @type Number
             */
            right: {

                set: function (value) {

                    this._right = (value !== undefined && value !== null) ? value : 1.0;

                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Frustum's {{#crossLink "Frustum/right:property"}}{{/crossLink}} property changes.
                     *
                     * @event right
                     * @param value The property's new value
                     */
                    this.fire("right", this._right);
                },

                get: function () {
                    return this._right;
                }
            },

            /**
             * Position of this Frustum's top plane on the View-space Y-axis.
             *
             * Fires a {{#crossLink "Frustum/top:event"}}{{/crossLink}} event on change.
             *
             * @property top
             * @default 1.0
             * @type Number
             */
            top: {

                set: function (value) {

                    this._top = (value !== undefined && value !== null) ? value : 1.0;

                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Frustum's   {{#crossLink "Frustum/top:property"}}{{/crossLink}} property changes.
                     *
                     * @event top
                     * @param value The property's new value
                     */
                    this.fire("top", this._top);
                },

                get: function () {
                    return this._top;
                }
            },

            /**
             * Position of this Frustum's bottom plane on the View-space Y-axis.
             *
             * Fires a {{#crossLink "Frustum/bottom:event"}}{{/crossLink}} event on change.
             *
             * @property bottom
             * @default -1.0
             * @type Number
             */
            bottom: {

                set: function (value) {

                    this._bottom = (value !== undefined && value !== null) ? value : -1.0;

                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Frustum's   {{#crossLink "Frustum/bottom:property"}}{{/crossLink}} property changes.
                     *
                     * @event bottom
                     * @param value The property's new value
                     */
                    this.fire("bottom", this._bottom);
                },

                get: function () {
                    return this._bottom;
                }
            },

            /**
             * Position of this Frustum's near plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Frustum/near:event"}}{{/crossLink}} event on change.
             *
             * @property near
             * @default 0.1
             * @type Number
             */
            near: {

                set: function (value) {

                    this._near = (value !== undefined && value !== null) ? value : 0.1;

                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Frustum's {{#crossLink "Frustum/near:property"}}{{/crossLink}} property changes.
                     *
                     * @event near
                     * @param value The property's new value
                     */
                    this.fire("near", this._near);
                },

                get: function () {
                    return this._near;
                }
            },

            /**
             * Position of this Frustum's far plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Frustum/far:event"}}{{/crossLink}} event on change.
             *
             * @property far
             * @default 10000.0
             * @type Number
             */
            far: {

                set: function (value) {

                    this._far = (value !== undefined && value !== null) ? value : 10000.0;

                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Frustum's  {{#crossLink "Frustum/far:property"}}{{/crossLink}} property changes.
                     *
                     * @event far
                     * @param value The property's new value
                     */
                    this.fire("far", this._far);
                },

                get: function () {
                    return this._far;
                }
            },

            /**
             * The Frustum's projection transform matrix.
             *
             * Fires a {{#crossLink "Frustum/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property matrix
             * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
             * @type {Float32Array}
             */
            matrix: {

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._state.matrix;
                }
            }
        }
    });
})();
;/**
 An **Ortho** defines an orthographic projection transform for a {{#crossLink "Camera"}}Camera{{/crossLink}}.

 ## Overview

 * A {{#crossLink "Camera"}}Camera{{/crossLink}} has an Ortho to configure its orthographic projection mode.
 * An Ortho works like Blender's orthographic projection, where the positions of the left, right, top and bottom planes are
 implicitly specified with a single {{#crossLink "Ortho/scale:property"}}{{/crossLink}} property, which causes the frustum to be symmetrical on X and Y axis, large enough to
 contain the number of units given by {{#crossLink "Ortho/scale:property"}}{{/crossLink}}.
 * An Ortho's {{#crossLink "Ortho/near:property"}}{{/crossLink}} and {{#crossLink "Ortho/far:property"}}{{/crossLink}} properties
 specify the distances to the WebGL clipping planes.


 ## Examples

 * [Camera with orthographic projection](../../examples/#camera_orthographic)

 ## Usage

 * See {{#crossLink "Camera"}}{{/crossLink}}

 @class Ortho
 @module xeogl
 @submodule camera
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this Ortho within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Ortho.
 @param [cfg.parent] {String|Transform} ID or instance of a parent {{#crossLink "Transform"}}{{/crossLink}} within the same {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.scale=1.0] {Number} Scale factor for this Ortho's extents on X and Y axis.
 @param [cfg.near=0.1] {Number} Position of the near plane on the View-space Z-axis.
 @param [cfg.far=10000] {Number} Position of the far plane on the positive View-space Z-axis.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Ortho = xeogl.Component.extend({

        type: "xeogl.Ortho",

        _init: function (cfg) {

            this._state = new xeogl.renderer.ProjTransform({
                matrix: xeogl.math.mat4()
            });

            this.scale = cfg.scale;
            this.near = cfg.near;
            this.far = cfg.far;

            this._onCanvasBoundary = this.scene.canvas.on("boundary", this._needUpdate, this);
        },

        _update: function () {

            var scene = this.scene;
            var scale = this._scale;
            var canvas = scene.canvas.canvas;
            var canvasWidth = canvas.clientWidth;
            var canvasHeight = canvas.clientHeight;
            var halfSize = 0.5 * scale;
            var aspect = canvasWidth / canvasHeight;

            var left;
            var right;
            var top;
            var bottom;

            if (canvasWidth > canvasHeight) {
                left = -halfSize;
                right = halfSize;
                top = halfSize / aspect;
                bottom = -halfSize / aspect;

            } else {
                left = -halfSize * aspect;
                right = halfSize * aspect;
                top = halfSize;
                bottom = -halfSize;
            }

            xeogl.math.orthoMat4c(left, right, bottom, top, this._near, this._far, this._state.matrix);

            this._renderer.imageDirty();

            this.fire("matrix", this._state.matrix);
        },

        _props: {

            /**
             * Scale factor for this Ortho's extents on X and Y axis.
             *
             * Clamps to minimum value of ````0.01```.
             *
             * Fires a {{#crossLink "Ortho/scale:event"}}{{/crossLink}} event on change.
             *
             * @property scale
             * @default 1.0
             * @type Number
             */
            scale: {

                set: function (value) {

                    if (value === undefined || value === null) {
                        value = 1.0;
                    }

                    if (value <= 0) {
                        value = 0.01;
                    }

                    this._scale = value;

                    this._needUpdate(0);

                    /**
                     * Fired whenever this Ortho's {{#crossLink "Ortho/scale:property"}}{{/crossLink}} property changes.
                     *
                     * @event scale
                     * @param value The property's new value
                     */
                    this.fire("scale", this._scale);
                },

                get: function () {
                    return this._scale;
                }
            },

            /**
             * Position of this Ortho's near plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Ortho/near:event"}}{{/crossLink}} event on change.
             *
             * @property near
             * @default 0.1
             * @type Number
             */
            near: {

                set: function (value) {

                    this._near = (value !== undefined && value !== null) ? value : 0.1;

                    this._needUpdate(0);

                    /**
                     * Fired whenever this Ortho's  {{#crossLink "Ortho/near:property"}}{{/crossLink}} property changes.
                     *
                     * @event near
                     * @param value The property's new value
                     */
                    this.fire("near", this._near);
                },

                get: function () {
                    return this._near;
                }
            },

            /**
             * Position of this Ortho's far plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Ortho/far:event"}}{{/crossLink}} event on change.
             *
             * @property far
             * @default 10000.0
             * @type Number
             */
            far: {

                set: function (value) {

                    this._far = (value !== undefined && value !== null) ? value : 10000.0;

                    this._needUpdate(0);

                    /**
                     * Fired whenever this Ortho's {{#crossLink "Ortho/far:property"}}{{/crossLink}} property changes.
                     *
                     * @event far
                     * @param value The property's new value
                     */
                    this.fire("far", this._far);
                },

                get: function () {
                    return this._far;
                }
            },

            /**
             * The Ortho's projection transform matrix.
             *
             * Fires a {{#crossLink "Ortho/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property matrix
             * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
             * @type {Float32Array}
             */
            matrix: {

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._state.matrix;
                }
            }
        },

        _destroy: function () {
            this._super();
            this.scene.canvas.off(this._onCanvasBoundary);
        }
    });

})();
;/**
 A **Perspective** defines a perspective projection transform for a {{#crossLink "Camera"}}Camera{{/crossLink}}.

 ## Overview

 * A {{#crossLink "Camera"}}Camera{{/crossLink}} has a Perspective to configure its perspective projection mode.

 ## Examples

 * [Camera with perspective projection](../../examples/#camera_perspective)

 ## Usage

 * See {{#crossLink "Camera"}}{{/crossLink}}

 @class Perspective
 @module xeogl
 @submodule camera
 @constructor
 @param [scene] {Scene} Parent {{#crossLink "Scene"}}Scene{{/crossLink}}, creates this Perspective within the
 default {{#crossLink "Scene"}}Scene{{/crossLink}} when omitted.
 @param [cfg] {*} Configs
 @param [cfg.id] {String} Optional ID, unique among all components in the parent scene, generated automatically when omitted.
 @param [cfg.meta] {String:Object} Optional map of user-defined metadata to attach to this Perspective.
 @param [cfg.parent] {String|Transform} ID or instance of a parent {{#crossLink "Transform"}}{{/crossLink}} within the same {{#crossLink "Scene"}}Scene{{/crossLink}}.
 @param [cfg.fov=60.0] {Number} Field-of-view angle, in degrees.
 @param [cfg.fovAxis="min"] {String} The field-of-view axis: "x", "y", or "min" to use whichever is currently the minimum.
 @param [cfg.near=0.1] {Number} Position of the near plane on the View-space Z-axis.
 @param [cfg.far=10000] {Number} Position of the far plane on the View-space Z-axis.
 @extends Component
 */
(function () {

    "use strict";

    xeogl.Perspective = xeogl.Component.extend({

        type: "xeogl.Perspective",

        _init: function (cfg) {

            this._state = new xeogl.renderer.ProjTransform({
                matrix: xeogl.math.mat4()
            });
            
            this._dirty = false;
            this._fov = 60.0;
            this._near = 0.1;
            this._far = 10000.0;

            // Recompute aspect from change in canvas size
            this._canvasResized = this.scene.canvas.on("boundary", this._needUpdate, this);

            this.fov = cfg.fov;
            this.fovAxis = cfg.fovAxis;
            this.near = cfg.near;
            this.far = cfg.far;
        },

        _update: function () {

            var canvas = this.scene.canvas.canvas;
            var aspect = canvas.clientWidth / canvas.clientHeight;

            var fov = this._fov;
            var fovAxis = this._fovAxis;

            if (fovAxis == "x" || (fovAxis == "min" && aspect < 1) || (fovAxis == "max" && aspect > 1)) {
                fov = fov / aspect;
            }

            fov = Math.min(fov, 120);

            xeogl.math.perspectiveMat4(fov * (Math.PI / 180.0), aspect, this._near, this._far, this._state.matrix);

            this._renderer.imageDirty();

            this.fire("matrix", this._state.matrix);
        },

        _props: {

            /**
             * The field-of-view angle (FOV).
             *
             * Fires a {{#crossLink "Perspective/fov:event"}}{{/crossLink}} event on change.
             *
             * @property fov
             * @default 60.0
             * @type Number
             */
            fov: {

                set: function (value) {

                    this._fov = (value !== undefined && value !== null) ? value : 60.0;

                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Perspective's {{#crossLink "Perspective/fov:property"}}{{/crossLink}} property changes.
                     *
                     * @event fov
                     * @param value The property's new value
                     */
                    this.fire("fov", this._fov);
                },

                get: function () {
                    return this._fov;
                }
            },

            /**
             * The FOV axis.
             *
             * Options are "x", "y" or "min", to use the minimum axis.
             *
             * Fires a {{#crossLink "Perspective/fov:event"}}{{/crossLink}} event on change.
             *
             * @property fov
             * @default "min"
             * @type String
             */
            fovAxis: {

                set: function (value) {

                    value = value || "min";

                    if (this._fovAxis === value) {
                        return;
                    }

                    if (value !== "x" && value !== "y" && value !== "min") {
                        this.error("Unsupported value for 'fovAxis': " + value + " - defaulting to 'min'");
                        value = "min";
                    }

                    this._fovAxis = value;

                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Perspective's {{#crossLink "Perspective/fovAxis:property"}}{{/crossLink}} property changes.
                     *
                     * @event fovAxis
                     * @param value The property's new value
                     */
                    this.fire("fovAxis", this._fovAxis);
                },

                get: function () {
                    return this._fovAxis;
                }
            },

            /**
             * Position of this Perspective's near plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Perspective/near:event"}}{{/crossLink}} event on change.
             *
             * @property near
             * @default 0.1
             * @type Number
             */
            near: {

                set: function (value) {

                    this._near = (value !== undefined && value !== null) ? value : 0.1;

                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Perspective's   {{#crossLink "Perspective/near:property"}}{{/crossLink}} property changes.
                     * @event near
                     * @param value The property's new value
                     */
                    this.fire("near", this._near);
                },

                get: function () {
                    return this._near;
                }
            },

            /**
             * Position of this Perspective's far plane on the positive View-space Z-axis.
             *
             * Fires a {{#crossLink "Perspective/far:event"}}{{/crossLink}} event on change.
             *
             * @property far
             * @default 10000.0
             * @type Number
             */
            far: {

                set: function (value) {

                    this._far = (value !== undefined && value !== null) ? value : 10000;

                    this._needUpdate(0); // Ensure matrix built on next "tick"

                    /**
                     * Fired whenever this Perspective's  {{#crossLink "Perspective/far:property"}}{{/crossLink}} property changes.
                     *
                     * @event far
                     * @param value The property's new value
                     */
                    this.fire("far", this._far);
                },

                get: function () {
                    return this._far;
                }
            },

            /**
             * The Perspective's projection transform matrix.
             *
             * Fires a {{#crossLink "Perspective/matrix:event"}}{{/crossLink}} event on change.
             *
             * @property matrix
             * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
             * @type {Float32Array}
             */
            matrix: {

                get: function () {

                    if (this._updateScheduled) {
                        this._doUpdate();
                    }

                    return this._state.matrix;
                }
            }
        },

        _destroy: function () {

            this._super();

            this.scene.canvas.off(this._canvasResized);
        }
    });

})();
xeogl.version="0.7.0";